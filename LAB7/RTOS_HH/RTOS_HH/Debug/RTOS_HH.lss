
RTOS_HH.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000012d6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001e  00800060  000012d6  0000136a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000615  0080007e  0080007e  00001388  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001388  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000013b8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002a0  00000000  00000000  000013f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003085  00000000  00000000  00001694  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000010bd  00000000  00000000  00004719  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001897  00000000  00000000  000057d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000698  00000000  00000000  00007070  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000ebb  00000000  00000000  00007708  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001f76  00000000  00000000  000085c3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000268  00000000  00000000  0000a539  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 03 03 	jmp	0x606	; 0x606 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 ed       	ldi	r30, 0xD6	; 214
      68:	f2 e1       	ldi	r31, 0x12	; 18
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	ae 37       	cpi	r26, 0x7E	; 126
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	26 e0       	ldi	r18, 0x06	; 6
      78:	ae e7       	ldi	r26, 0x7E	; 126
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 39       	cpi	r26, 0x93	; 147
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 de 00 	call	0x1bc	; 0x1bc <main>
      8a:	0c 94 69 09 	jmp	0x12d2	; 0x12d2 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <initLEDport>:
void writeAllLEDs(unsigned char pattern)
{
  // Fetch the parameter, invert all bits, and send to LEDs
  // The bits has to be inverted, because HW dictates 
  // a 0 will turn ON a LED
  PORTC = ~pattern;   
      92:	8f ef       	ldi	r24, 0xFF	; 255
      94:	84 bb       	out	0x14, r24	; 20
      96:	85 bb       	out	0x15, r24	; 21
      98:	08 95       	ret

0000009a <turnOnLED>:
void turnOnLED(unsigned char led_nr)
{
// Local variable
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
      9a:	88 30       	cpi	r24, 0x08	; 8
      9c:	68 f4       	brcc	.+26     	; 0xb8 <turnOnLED+0x1e>
  {
    // Create mask based on the parameter (led_nr)
    mask = ~(0b00000001 << led_nr);
    // Turn ON the actual LED (the rest are unchanged)
    PORTC = PORTC & mask;
      9e:	45 b3       	in	r20, 0x15	; 21
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
  {
    // Create mask based on the parameter (led_nr)
    mask = ~(0b00000001 << led_nr);
      a0:	21 e0       	ldi	r18, 0x01	; 1
      a2:	30 e0       	ldi	r19, 0x00	; 0
      a4:	b9 01       	movw	r22, r18
      a6:	02 c0       	rjmp	.+4      	; 0xac <turnOnLED+0x12>
      a8:	66 0f       	add	r22, r22
      aa:	77 1f       	adc	r23, r23
      ac:	8a 95       	dec	r24
      ae:	e2 f7       	brpl	.-8      	; 0xa8 <turnOnLED+0xe>
      b0:	cb 01       	movw	r24, r22
      b2:	80 95       	com	r24
    // Turn ON the actual LED (the rest are unchanged)
    PORTC = PORTC & mask;
      b4:	84 23       	and	r24, r20
      b6:	85 bb       	out	0x15, r24	; 21
      b8:	08 95       	ret

000000ba <turnOffLED>:
void turnOffLED(unsigned char led_nr)
{
// Local variable
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
      ba:	88 30       	cpi	r24, 0x08	; 8
      bc:	60 f4       	brcc	.+24     	; 0xd6 <turnOffLED+0x1c>
  {
    // Create mask based on the parameter (led_nr)
    mask = 0b00000001 << led_nr;
    // Turn OFF the actual LED (the rest are unchanged)
    PORTC = PORTC | mask;
      be:	45 b3       	in	r20, 0x15	; 21
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
  {
    // Create mask based on the parameter (led_nr)
    mask = 0b00000001 << led_nr;
      c0:	21 e0       	ldi	r18, 0x01	; 1
      c2:	30 e0       	ldi	r19, 0x00	; 0
      c4:	b9 01       	movw	r22, r18
      c6:	02 c0       	rjmp	.+4      	; 0xcc <turnOffLED+0x12>
      c8:	66 0f       	add	r22, r22
      ca:	77 1f       	adc	r23, r23
      cc:	8a 95       	dec	r24
      ce:	e2 f7       	brpl	.-8      	; 0xc8 <turnOffLED+0xe>
      d0:	cb 01       	movw	r24, r22
    // Turn OFF the actual LED (the rest are unchanged)
    PORTC = PORTC | mask;
      d2:	84 2b       	or	r24, r20
      d4:	85 bb       	out	0x15, r24	; 21
      d6:	08 95       	ret

000000d8 <toggleLED>:
void toggleLED(unsigned char led_nr)
{
// Local variable
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
      d8:	88 30       	cpi	r24, 0x08	; 8
      da:	60 f4       	brcc	.+24     	; 0xf4 <toggleLED+0x1c>
  {
    // Create mask based on the parameter (led_nr)
    mask = 0b00000001 << led_nr;
    // Toggle the actual LED (the rest are unchanged)
    PORTC = PORTC ^ mask;
      dc:	45 b3       	in	r20, 0x15	; 21
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
  {
    // Create mask based on the parameter (led_nr)
    mask = 0b00000001 << led_nr;
      de:	21 e0       	ldi	r18, 0x01	; 1
      e0:	30 e0       	ldi	r19, 0x00	; 0
      e2:	b9 01       	movw	r22, r18
      e4:	02 c0       	rjmp	.+4      	; 0xea <toggleLED+0x12>
      e6:	66 0f       	add	r22, r22
      e8:	77 1f       	adc	r23, r23
      ea:	8a 95       	dec	r24
      ec:	e2 f7       	brpl	.-8      	; 0xe6 <toggleLED+0xe>
      ee:	cb 01       	movw	r24, r22
    // Toggle the actual LED (the rest are unchanged)
    PORTC = PORTC ^ mask;
      f0:	84 27       	eor	r24, r20
      f2:	85 bb       	out	0x15, r24	; 21
      f4:	08 95       	ret

000000f6 <initSwitchPort>:

// Reads all switches at a time
unsigned char switchStatus()
{
  return (~PINA);	
}
      f6:	1a ba       	out	0x1a, r1	; 26
      f8:	08 95       	ret

000000fa <switchOn>:
// Returns TRUE, if the switch having the number
// "switch_nr" is activated - otherwise return FALSE
unsigned char switchOn(unsigned char switch_nr)
{
unsigned char mask;
  if (switch_nr <= MAX_SWITCH_NR)
      fa:	88 30       	cpi	r24, 0x08	; 8
      fc:	60 f4       	brcc	.+24     	; 0x116 <switchOn+0x1c>
  {
    mask = 0b00000001 << switch_nr;
    return (~PINA & mask);
      fe:	99 b3       	in	r25, 0x19	; 25
unsigned char switchOn(unsigned char switch_nr)
{
unsigned char mask;
  if (switch_nr <= MAX_SWITCH_NR)
  {
    mask = 0b00000001 << switch_nr;
     100:	21 e0       	ldi	r18, 0x01	; 1
     102:	30 e0       	ldi	r19, 0x00	; 0
     104:	02 c0       	rjmp	.+4      	; 0x10a <switchOn+0x10>
     106:	22 0f       	add	r18, r18
     108:	33 1f       	adc	r19, r19
     10a:	8a 95       	dec	r24
     10c:	e2 f7       	brpl	.-8      	; 0x106 <switchOn+0xc>
    return (~PINA & mask);
     10e:	89 2f       	mov	r24, r25
     110:	80 95       	com	r24
     112:	82 23       	and	r24, r18
     114:	08 95       	ret
  }
  else
    return 0;	
     116:	80 e0       	ldi	r24, 0x00	; 0
} 
     118:	08 95       	ret

0000011a <vLEDFlashTask1>:

//Create the semaphore handle
xSemaphoreHandle semaphoreHandle = NULL;

void vLEDFlashTask1( void *pvParameters )
{
     11a:	cf 93       	push	r28
     11c:	df 93       	push	r29
     11e:	00 d0       	rcall	.+0      	; 0x120 <vLEDFlashTask1+0x6>
     120:	cd b7       	in	r28, 0x3d	; 61
     122:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	xLastWakeTime=xTaskGetTickCount();
     124:	0e 94 77 06 	call	0xcee	; 0xcee <xTaskGetTickCount>
     128:	9a 83       	std	Y+2, r25	; 0x02
     12a:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		toggleLED(0);
     12c:	80 e0       	ldi	r24, 0x00	; 0
     12e:	0e 94 6c 00 	call	0xd8	; 0xd8 <toggleLED>
		vTaskDelayUntil(&xLastWakeTime,800);
     132:	60 e2       	ldi	r22, 0x20	; 32
     134:	73 e0       	ldi	r23, 0x03	; 3
     136:	ce 01       	movw	r24, r28
     138:	01 96       	adiw	r24, 0x01	; 1
     13a:	0e 94 cb 07 	call	0xf96	; 0xf96 <vTaskDelayUntil>
	}
     13e:	f6 cf       	rjmp	.-20     	; 0x12c <vLEDFlashTask1+0x12>

00000140 <vLEDFlashTask2>:
}

void vLEDFlashTask2( void *pvParameters )
{
     140:	cf 93       	push	r28
     142:	df 93       	push	r29
     144:	00 d0       	rcall	.+0      	; 0x146 <vLEDFlashTask2+0x6>
     146:	cd b7       	in	r28, 0x3d	; 61
     148:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	xLastWakeTime=xTaskGetTickCount();
     14a:	0e 94 77 06 	call	0xcee	; 0xcee <xTaskGetTickCount>
     14e:	9a 83       	std	Y+2, r25	; 0x02
     150:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		toggleLED(1);
     152:	81 e0       	ldi	r24, 0x01	; 1
     154:	0e 94 6c 00 	call	0xd8	; 0xd8 <toggleLED>
		vTaskDelayUntil(&xLastWakeTime,500);
     158:	64 ef       	ldi	r22, 0xF4	; 244
     15a:	71 e0       	ldi	r23, 0x01	; 1
     15c:	ce 01       	movw	r24, r28
     15e:	01 96       	adiw	r24, 0x01	; 1
     160:	0e 94 cb 07 	call	0xf96	; 0xf96 <vTaskDelayUntil>
	}
     164:	f6 cf       	rjmp	.-20     	; 0x152 <vLEDFlashTask2+0x12>

00000166 <vWaitForSwitch>:

void vWaitForSwitch(void *pvParameters)
{
	while(1)
	{
		if(switchOn(7))
     166:	87 e0       	ldi	r24, 0x07	; 7
     168:	0e 94 7d 00 	call	0xfa	; 0xfa <switchOn>
     16c:	88 23       	and	r24, r24
     16e:	59 f0       	breq	.+22     	; 0x186 <vWaitForSwitch+0x20>
		{
			xSemaphoreGive(semaphoreHandle);
     170:	20 e0       	ldi	r18, 0x00	; 0
     172:	40 e0       	ldi	r20, 0x00	; 0
     174:	50 e0       	ldi	r21, 0x00	; 0
     176:	60 e0       	ldi	r22, 0x00	; 0
     178:	70 e0       	ldi	r23, 0x00	; 0
     17a:	80 91 7e 00 	lds	r24, 0x007E	; 0x80007e <__data_end>
     17e:	90 91 7f 00 	lds	r25, 0x007F	; 0x80007f <__data_end+0x1>
     182:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <xQueueGenericSend>
		}
		vTaskDelay(10);
     186:	8a e0       	ldi	r24, 0x0A	; 10
     188:	90 e0       	ldi	r25, 0x00	; 0
     18a:	0e 94 15 08 	call	0x102a	; 0x102a <vTaskDelay>
	}
     18e:	eb cf       	rjmp	.-42     	; 0x166 <vWaitForSwitch>

00000190 <vSemBlink>:

void vSemBlink(void *pvParameters)
{
	while(1)
	{
		xSemaphoreTake(semaphoreHandle, portMAX_DELAY);
     190:	20 e0       	ldi	r18, 0x00	; 0
     192:	4f ef       	ldi	r20, 0xFF	; 255
     194:	5f ef       	ldi	r21, 0xFF	; 255
     196:	60 e0       	ldi	r22, 0x00	; 0
     198:	70 e0       	ldi	r23, 0x00	; 0
     19a:	80 91 7e 00 	lds	r24, 0x007E	; 0x80007e <__data_end>
     19e:	90 91 7f 00 	lds	r25, 0x007F	; 0x80007f <__data_end+0x1>
     1a2:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <xQueueGenericReceive>
		turnOnLED(5);
     1a6:	85 e0       	ldi	r24, 0x05	; 5
     1a8:	0e 94 4d 00 	call	0x9a	; 0x9a <turnOnLED>
		vTaskDelay(10);
     1ac:	8a e0       	ldi	r24, 0x0A	; 10
     1ae:	90 e0       	ldi	r25, 0x00	; 0
     1b0:	0e 94 15 08 	call	0x102a	; 0x102a <vTaskDelay>
		turnOffLED(5);
     1b4:	85 e0       	ldi	r24, 0x05	; 5
     1b6:	0e 94 5d 00 	call	0xba	; 0xba <turnOffLED>
	}
     1ba:	ea cf       	rjmp	.-44     	; 0x190 <vSemBlink>

000001bc <main>:
}

int main(void)
{
	initLEDport();
     1bc:	0e 94 49 00 	call	0x92	; 0x92 <initLEDport>
	initSwitchPort();
     1c0:	0e 94 7b 00 	call	0xf6	; 0xf6 <initSwitchPort>
	xTaskCreate(vLEDFlashTask1, (signed char *) "LED1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     1c4:	a1 2c       	mov	r10, r1
     1c6:	b1 2c       	mov	r11, r1
     1c8:	c1 2c       	mov	r12, r1
     1ca:	d1 2c       	mov	r13, r1
     1cc:	e1 2c       	mov	r14, r1
     1ce:	f1 2c       	mov	r15, r1
     1d0:	00 e0       	ldi	r16, 0x00	; 0
     1d2:	20 e0       	ldi	r18, 0x00	; 0
     1d4:	30 e0       	ldi	r19, 0x00	; 0
     1d6:	45 e5       	ldi	r20, 0x55	; 85
     1d8:	50 e0       	ldi	r21, 0x00	; 0
     1da:	62 e6       	ldi	r22, 0x62	; 98
     1dc:	70 e0       	ldi	r23, 0x00	; 0
     1de:	8d e8       	ldi	r24, 0x8D	; 141
     1e0:	90 e0       	ldi	r25, 0x00	; 0
     1e2:	0e 94 57 05 	call	0xaae	; 0xaae <xTaskGenericCreate>
	xTaskCreate(vLEDFlashTask2, (signed char *) "LED2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     1e6:	20 e0       	ldi	r18, 0x00	; 0
     1e8:	30 e0       	ldi	r19, 0x00	; 0
     1ea:	45 e5       	ldi	r20, 0x55	; 85
     1ec:	50 e0       	ldi	r21, 0x00	; 0
     1ee:	67 e6       	ldi	r22, 0x67	; 103
     1f0:	70 e0       	ldi	r23, 0x00	; 0
     1f2:	80 ea       	ldi	r24, 0xA0	; 160
     1f4:	90 e0       	ldi	r25, 0x00	; 0
     1f6:	0e 94 57 05 	call	0xaae	; 0xaae <xTaskGenericCreate>
	xTaskCreate(vWaitForSwitch, (signed char *) "SWITCH", configMINIMAL_STACK_SIZE,NULL, tskIDLE_PRIORITY, NULL);
     1fa:	20 e0       	ldi	r18, 0x00	; 0
     1fc:	30 e0       	ldi	r19, 0x00	; 0
     1fe:	45 e5       	ldi	r20, 0x55	; 85
     200:	50 e0       	ldi	r21, 0x00	; 0
     202:	6c e6       	ldi	r22, 0x6C	; 108
     204:	70 e0       	ldi	r23, 0x00	; 0
     206:	83 eb       	ldi	r24, 0xB3	; 179
     208:	90 e0       	ldi	r25, 0x00	; 0
     20a:	0e 94 57 05 	call	0xaae	; 0xaae <xTaskGenericCreate>
	xTaskCreate(vSemBlink, (signed char *) "BLINK", configMINIMAL_STACK_SIZE,NULL, tskIDLE_PRIORITY, NULL);
     20e:	20 e0       	ldi	r18, 0x00	; 0
     210:	30 e0       	ldi	r19, 0x00	; 0
     212:	45 e5       	ldi	r20, 0x55	; 85
     214:	50 e0       	ldi	r21, 0x00	; 0
     216:	63 e7       	ldi	r22, 0x73	; 115
     218:	70 e0       	ldi	r23, 0x00	; 0
     21a:	88 ec       	ldi	r24, 0xC8	; 200
     21c:	90 e0       	ldi	r25, 0x00	; 0
     21e:	0e 94 57 05 	call	0xaae	; 0xaae <xTaskGenericCreate>
	vTaskStartScheduler();
     222:	0e 94 46 06 	call	0xc8c	; 0xc8c <vTaskStartScheduler>
	while(1)
	{}
     226:	ff cf       	rjmp	.-2      	; 0x226 <main+0x6a>

00000228 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     228:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     22a:	03 96       	adiw	r24, 0x03	; 3
     22c:	92 83       	std	Z+2, r25	; 0x02
     22e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     230:	2f ef       	ldi	r18, 0xFF	; 255
     232:	3f ef       	ldi	r19, 0xFF	; 255
     234:	34 83       	std	Z+4, r19	; 0x04
     236:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     238:	96 83       	std	Z+6, r25	; 0x06
     23a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     23c:	90 87       	std	Z+8, r25	; 0x08
     23e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     240:	10 82       	st	Z, r1
     242:	08 95       	ret

00000244 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     244:	fc 01       	movw	r30, r24
     246:	11 86       	std	Z+9, r1	; 0x09
     248:	10 86       	std	Z+8, r1	; 0x08
     24a:	08 95       	ret

0000024c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     24c:	cf 93       	push	r28
     24e:	df 93       	push	r29
     250:	fc 01       	movw	r30, r24
     252:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     254:	21 81       	ldd	r18, Z+1	; 0x01
     256:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     258:	e9 01       	movw	r28, r18
     25a:	8a 81       	ldd	r24, Y+2	; 0x02
     25c:	9b 81       	ldd	r25, Y+3	; 0x03
     25e:	13 96       	adiw	r26, 0x03	; 3
     260:	9c 93       	st	X, r25
     262:	8e 93       	st	-X, r24
     264:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     266:	81 81       	ldd	r24, Z+1	; 0x01
     268:	92 81       	ldd	r25, Z+2	; 0x02
     26a:	15 96       	adiw	r26, 0x05	; 5
     26c:	9c 93       	st	X, r25
     26e:	8e 93       	st	-X, r24
     270:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     272:	8a 81       	ldd	r24, Y+2	; 0x02
     274:	9b 81       	ldd	r25, Y+3	; 0x03
     276:	ec 01       	movw	r28, r24
     278:	7d 83       	std	Y+5, r23	; 0x05
     27a:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     27c:	e9 01       	movw	r28, r18
     27e:	7b 83       	std	Y+3, r23	; 0x03
     280:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     282:	72 83       	std	Z+2, r23	; 0x02
     284:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     286:	19 96       	adiw	r26, 0x09	; 9
     288:	fc 93       	st	X, r31
     28a:	ee 93       	st	-X, r30
     28c:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     28e:	80 81       	ld	r24, Z
     290:	8f 5f       	subi	r24, 0xFF	; 255
     292:	80 83       	st	Z, r24
}
     294:	df 91       	pop	r29
     296:	cf 91       	pop	r28
     298:	08 95       	ret

0000029a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     29a:	cf 93       	push	r28
     29c:	df 93       	push	r29
     29e:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     2a0:	48 81       	ld	r20, Y
     2a2:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     2a4:	4f 3f       	cpi	r20, 0xFF	; 255
     2a6:	2f ef       	ldi	r18, 0xFF	; 255
     2a8:	52 07       	cpc	r21, r18
     2aa:	31 f4       	brne	.+12     	; 0x2b8 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2ac:	dc 01       	movw	r26, r24
     2ae:	17 96       	adiw	r26, 0x07	; 7
     2b0:	ed 91       	ld	r30, X+
     2b2:	fc 91       	ld	r31, X
     2b4:	18 97       	sbiw	r26, 0x08	; 8
     2b6:	17 c0       	rjmp	.+46     	; 0x2e6 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     2b8:	fc 01       	movw	r30, r24
     2ba:	33 96       	adiw	r30, 0x03	; 3
     2bc:	dc 01       	movw	r26, r24
     2be:	15 96       	adiw	r26, 0x05	; 5
     2c0:	2d 91       	ld	r18, X+
     2c2:	3c 91       	ld	r19, X
     2c4:	16 97       	sbiw	r26, 0x06	; 6
     2c6:	d9 01       	movw	r26, r18
     2c8:	2d 91       	ld	r18, X+
     2ca:	3c 91       	ld	r19, X
     2cc:	42 17       	cp	r20, r18
     2ce:	53 07       	cpc	r21, r19
     2d0:	50 f0       	brcs	.+20     	; 0x2e6 <vListInsert+0x4c>
     2d2:	02 80       	ldd	r0, Z+2	; 0x02
     2d4:	f3 81       	ldd	r31, Z+3	; 0x03
     2d6:	e0 2d       	mov	r30, r0
     2d8:	a2 81       	ldd	r26, Z+2	; 0x02
     2da:	b3 81       	ldd	r27, Z+3	; 0x03
     2dc:	2d 91       	ld	r18, X+
     2de:	3c 91       	ld	r19, X
     2e0:	42 17       	cp	r20, r18
     2e2:	53 07       	cpc	r21, r19
     2e4:	b0 f7       	brcc	.-20     	; 0x2d2 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2e6:	a2 81       	ldd	r26, Z+2	; 0x02
     2e8:	b3 81       	ldd	r27, Z+3	; 0x03
     2ea:	bb 83       	std	Y+3, r27	; 0x03
     2ec:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     2ee:	15 96       	adiw	r26, 0x05	; 5
     2f0:	dc 93       	st	X, r29
     2f2:	ce 93       	st	-X, r28
     2f4:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     2f6:	fd 83       	std	Y+5, r31	; 0x05
     2f8:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     2fa:	d3 83       	std	Z+3, r29	; 0x03
     2fc:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2fe:	99 87       	std	Y+9, r25	; 0x09
     300:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     302:	fc 01       	movw	r30, r24
     304:	20 81       	ld	r18, Z
     306:	2f 5f       	subi	r18, 0xFF	; 255
     308:	20 83       	st	Z, r18
}
     30a:	df 91       	pop	r29
     30c:	cf 91       	pop	r28
     30e:	08 95       	ret

00000310 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     310:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     312:	a2 81       	ldd	r26, Z+2	; 0x02
     314:	b3 81       	ldd	r27, Z+3	; 0x03
     316:	84 81       	ldd	r24, Z+4	; 0x04
     318:	95 81       	ldd	r25, Z+5	; 0x05
     31a:	15 96       	adiw	r26, 0x05	; 5
     31c:	9c 93       	st	X, r25
     31e:	8e 93       	st	-X, r24
     320:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     322:	a4 81       	ldd	r26, Z+4	; 0x04
     324:	b5 81       	ldd	r27, Z+5	; 0x05
     326:	82 81       	ldd	r24, Z+2	; 0x02
     328:	93 81       	ldd	r25, Z+3	; 0x03
     32a:	13 96       	adiw	r26, 0x03	; 3
     32c:	9c 93       	st	X, r25
     32e:	8e 93       	st	-X, r24
     330:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     332:	a0 85       	ldd	r26, Z+8	; 0x08
     334:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     336:	11 96       	adiw	r26, 0x01	; 1
     338:	8d 91       	ld	r24, X+
     33a:	9c 91       	ld	r25, X
     33c:	12 97       	sbiw	r26, 0x02	; 2
     33e:	8e 17       	cp	r24, r30
     340:	9f 07       	cpc	r25, r31
     342:	31 f4       	brne	.+12     	; 0x350 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     344:	84 81       	ldd	r24, Z+4	; 0x04
     346:	95 81       	ldd	r25, Z+5	; 0x05
     348:	12 96       	adiw	r26, 0x02	; 2
     34a:	9c 93       	st	X, r25
     34c:	8e 93       	st	-X, r24
     34e:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     350:	11 86       	std	Z+9, r1	; 0x09
     352:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     354:	8c 91       	ld	r24, X
     356:	81 50       	subi	r24, 0x01	; 1
     358:	8c 93       	st	X, r24
     35a:	08 95       	ret

0000035c <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     35c:	31 e1       	ldi	r19, 0x11	; 17
     35e:	fc 01       	movw	r30, r24
     360:	30 83       	st	Z, r19
     362:	31 97       	sbiw	r30, 0x01	; 1
     364:	22 e2       	ldi	r18, 0x22	; 34
     366:	20 83       	st	Z, r18
     368:	31 97       	sbiw	r30, 0x01	; 1
     36a:	a3 e3       	ldi	r26, 0x33	; 51
     36c:	a0 83       	st	Z, r26
     36e:	31 97       	sbiw	r30, 0x01	; 1
     370:	60 83       	st	Z, r22
     372:	31 97       	sbiw	r30, 0x01	; 1
     374:	70 83       	st	Z, r23
     376:	31 97       	sbiw	r30, 0x01	; 1
     378:	10 82       	st	Z, r1
     37a:	31 97       	sbiw	r30, 0x01	; 1
     37c:	60 e8       	ldi	r22, 0x80	; 128
     37e:	60 83       	st	Z, r22
     380:	31 97       	sbiw	r30, 0x01	; 1
     382:	10 82       	st	Z, r1
     384:	31 97       	sbiw	r30, 0x01	; 1
     386:	62 e0       	ldi	r22, 0x02	; 2
     388:	60 83       	st	Z, r22
     38a:	31 97       	sbiw	r30, 0x01	; 1
     38c:	63 e0       	ldi	r22, 0x03	; 3
     38e:	60 83       	st	Z, r22
     390:	31 97       	sbiw	r30, 0x01	; 1
     392:	64 e0       	ldi	r22, 0x04	; 4
     394:	60 83       	st	Z, r22
     396:	31 97       	sbiw	r30, 0x01	; 1
     398:	65 e0       	ldi	r22, 0x05	; 5
     39a:	60 83       	st	Z, r22
     39c:	31 97       	sbiw	r30, 0x01	; 1
     39e:	66 e0       	ldi	r22, 0x06	; 6
     3a0:	60 83       	st	Z, r22
     3a2:	31 97       	sbiw	r30, 0x01	; 1
     3a4:	67 e0       	ldi	r22, 0x07	; 7
     3a6:	60 83       	st	Z, r22
     3a8:	31 97       	sbiw	r30, 0x01	; 1
     3aa:	68 e0       	ldi	r22, 0x08	; 8
     3ac:	60 83       	st	Z, r22
     3ae:	31 97       	sbiw	r30, 0x01	; 1
     3b0:	69 e0       	ldi	r22, 0x09	; 9
     3b2:	60 83       	st	Z, r22
     3b4:	31 97       	sbiw	r30, 0x01	; 1
     3b6:	60 e1       	ldi	r22, 0x10	; 16
     3b8:	60 83       	st	Z, r22
     3ba:	31 97       	sbiw	r30, 0x01	; 1
     3bc:	30 83       	st	Z, r19
     3be:	31 97       	sbiw	r30, 0x01	; 1
     3c0:	32 e1       	ldi	r19, 0x12	; 18
     3c2:	30 83       	st	Z, r19
     3c4:	31 97       	sbiw	r30, 0x01	; 1
     3c6:	33 e1       	ldi	r19, 0x13	; 19
     3c8:	30 83       	st	Z, r19
     3ca:	31 97       	sbiw	r30, 0x01	; 1
     3cc:	34 e1       	ldi	r19, 0x14	; 20
     3ce:	30 83       	st	Z, r19
     3d0:	31 97       	sbiw	r30, 0x01	; 1
     3d2:	35 e1       	ldi	r19, 0x15	; 21
     3d4:	30 83       	st	Z, r19
     3d6:	31 97       	sbiw	r30, 0x01	; 1
     3d8:	36 e1       	ldi	r19, 0x16	; 22
     3da:	30 83       	st	Z, r19
     3dc:	31 97       	sbiw	r30, 0x01	; 1
     3de:	37 e1       	ldi	r19, 0x17	; 23
     3e0:	30 83       	st	Z, r19
     3e2:	31 97       	sbiw	r30, 0x01	; 1
     3e4:	38 e1       	ldi	r19, 0x18	; 24
     3e6:	30 83       	st	Z, r19
     3e8:	31 97       	sbiw	r30, 0x01	; 1
     3ea:	39 e1       	ldi	r19, 0x19	; 25
     3ec:	30 83       	st	Z, r19
     3ee:	31 97       	sbiw	r30, 0x01	; 1
     3f0:	30 e2       	ldi	r19, 0x20	; 32
     3f2:	30 83       	st	Z, r19
     3f4:	31 97       	sbiw	r30, 0x01	; 1
     3f6:	31 e2       	ldi	r19, 0x21	; 33
     3f8:	30 83       	st	Z, r19
     3fa:	31 97       	sbiw	r30, 0x01	; 1
     3fc:	20 83       	st	Z, r18
     3fe:	31 97       	sbiw	r30, 0x01	; 1
     400:	23 e2       	ldi	r18, 0x23	; 35
     402:	20 83       	st	Z, r18
     404:	31 97       	sbiw	r30, 0x01	; 1
     406:	40 83       	st	Z, r20
     408:	31 97       	sbiw	r30, 0x01	; 1
     40a:	50 83       	st	Z, r21
     40c:	31 97       	sbiw	r30, 0x01	; 1
     40e:	26 e2       	ldi	r18, 0x26	; 38
     410:	20 83       	st	Z, r18
     412:	31 97       	sbiw	r30, 0x01	; 1
     414:	27 e2       	ldi	r18, 0x27	; 39
     416:	20 83       	st	Z, r18
     418:	31 97       	sbiw	r30, 0x01	; 1
     41a:	28 e2       	ldi	r18, 0x28	; 40
     41c:	20 83       	st	Z, r18
     41e:	31 97       	sbiw	r30, 0x01	; 1
     420:	29 e2       	ldi	r18, 0x29	; 41
     422:	20 83       	st	Z, r18
     424:	31 97       	sbiw	r30, 0x01	; 1
     426:	20 e3       	ldi	r18, 0x30	; 48
     428:	20 83       	st	Z, r18
     42a:	31 97       	sbiw	r30, 0x01	; 1
     42c:	21 e3       	ldi	r18, 0x31	; 49
     42e:	20 83       	st	Z, r18
     430:	86 97       	sbiw	r24, 0x26	; 38
     432:	08 95       	ret

00000434 <xPortStartScheduler>:
     434:	1b bc       	out	0x2b, r1	; 43
     436:	88 e3       	ldi	r24, 0x38	; 56
     438:	8a bd       	out	0x2a, r24	; 42
     43a:	8b e0       	ldi	r24, 0x0B	; 11
     43c:	8e bd       	out	0x2e, r24	; 46
     43e:	89 b7       	in	r24, 0x39	; 57
     440:	80 61       	ori	r24, 0x10	; 16
     442:	89 bf       	out	0x39, r24	; 57
     444:	a0 91 91 06 	lds	r26, 0x0691	; 0x800691 <pxCurrentTCB>
     448:	b0 91 92 06 	lds	r27, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
     44c:	cd 91       	ld	r28, X+
     44e:	cd bf       	out	0x3d, r28	; 61
     450:	dd 91       	ld	r29, X+
     452:	de bf       	out	0x3e, r29	; 62
     454:	ff 91       	pop	r31
     456:	ef 91       	pop	r30
     458:	df 91       	pop	r29
     45a:	cf 91       	pop	r28
     45c:	bf 91       	pop	r27
     45e:	af 91       	pop	r26
     460:	9f 91       	pop	r25
     462:	8f 91       	pop	r24
     464:	7f 91       	pop	r23
     466:	6f 91       	pop	r22
     468:	5f 91       	pop	r21
     46a:	4f 91       	pop	r20
     46c:	3f 91       	pop	r19
     46e:	2f 91       	pop	r18
     470:	1f 91       	pop	r17
     472:	0f 91       	pop	r16
     474:	ff 90       	pop	r15
     476:	ef 90       	pop	r14
     478:	df 90       	pop	r13
     47a:	cf 90       	pop	r12
     47c:	bf 90       	pop	r11
     47e:	af 90       	pop	r10
     480:	9f 90       	pop	r9
     482:	8f 90       	pop	r8
     484:	7f 90       	pop	r7
     486:	6f 90       	pop	r6
     488:	5f 90       	pop	r5
     48a:	4f 90       	pop	r4
     48c:	3f 90       	pop	r3
     48e:	2f 90       	pop	r2
     490:	1f 90       	pop	r1
     492:	0f 90       	pop	r0
     494:	0f be       	out	0x3f, r0	; 63
     496:	0f 90       	pop	r0
     498:	08 95       	ret
     49a:	81 e0       	ldi	r24, 0x01	; 1
     49c:	08 95       	ret

0000049e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     49e:	0f 92       	push	r0
     4a0:	0f b6       	in	r0, 0x3f	; 63
     4a2:	f8 94       	cli
     4a4:	0f 92       	push	r0
     4a6:	1f 92       	push	r1
     4a8:	11 24       	eor	r1, r1
     4aa:	2f 92       	push	r2
     4ac:	3f 92       	push	r3
     4ae:	4f 92       	push	r4
     4b0:	5f 92       	push	r5
     4b2:	6f 92       	push	r6
     4b4:	7f 92       	push	r7
     4b6:	8f 92       	push	r8
     4b8:	9f 92       	push	r9
     4ba:	af 92       	push	r10
     4bc:	bf 92       	push	r11
     4be:	cf 92       	push	r12
     4c0:	df 92       	push	r13
     4c2:	ef 92       	push	r14
     4c4:	ff 92       	push	r15
     4c6:	0f 93       	push	r16
     4c8:	1f 93       	push	r17
     4ca:	2f 93       	push	r18
     4cc:	3f 93       	push	r19
     4ce:	4f 93       	push	r20
     4d0:	5f 93       	push	r21
     4d2:	6f 93       	push	r22
     4d4:	7f 93       	push	r23
     4d6:	8f 93       	push	r24
     4d8:	9f 93       	push	r25
     4da:	af 93       	push	r26
     4dc:	bf 93       	push	r27
     4de:	cf 93       	push	r28
     4e0:	df 93       	push	r29
     4e2:	ef 93       	push	r30
     4e4:	ff 93       	push	r31
     4e6:	a0 91 91 06 	lds	r26, 0x0691	; 0x800691 <pxCurrentTCB>
     4ea:	b0 91 92 06 	lds	r27, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
     4ee:	0d b6       	in	r0, 0x3d	; 61
     4f0:	0d 92       	st	X+, r0
     4f2:	0e b6       	in	r0, 0x3e	; 62
     4f4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     4f6:	0e 94 35 08 	call	0x106a	; 0x106a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     4fa:	a0 91 91 06 	lds	r26, 0x0691	; 0x800691 <pxCurrentTCB>
     4fe:	b0 91 92 06 	lds	r27, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
     502:	cd 91       	ld	r28, X+
     504:	cd bf       	out	0x3d, r28	; 61
     506:	dd 91       	ld	r29, X+
     508:	de bf       	out	0x3e, r29	; 62
     50a:	ff 91       	pop	r31
     50c:	ef 91       	pop	r30
     50e:	df 91       	pop	r29
     510:	cf 91       	pop	r28
     512:	bf 91       	pop	r27
     514:	af 91       	pop	r26
     516:	9f 91       	pop	r25
     518:	8f 91       	pop	r24
     51a:	7f 91       	pop	r23
     51c:	6f 91       	pop	r22
     51e:	5f 91       	pop	r21
     520:	4f 91       	pop	r20
     522:	3f 91       	pop	r19
     524:	2f 91       	pop	r18
     526:	1f 91       	pop	r17
     528:	0f 91       	pop	r16
     52a:	ff 90       	pop	r15
     52c:	ef 90       	pop	r14
     52e:	df 90       	pop	r13
     530:	cf 90       	pop	r12
     532:	bf 90       	pop	r11
     534:	af 90       	pop	r10
     536:	9f 90       	pop	r9
     538:	8f 90       	pop	r8
     53a:	7f 90       	pop	r7
     53c:	6f 90       	pop	r6
     53e:	5f 90       	pop	r5
     540:	4f 90       	pop	r4
     542:	3f 90       	pop	r3
     544:	2f 90       	pop	r2
     546:	1f 90       	pop	r1
     548:	0f 90       	pop	r0
     54a:	0f be       	out	0x3f, r0	; 63
     54c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     54e:	08 95       	ret

00000550 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     550:	0f 92       	push	r0
     552:	0f b6       	in	r0, 0x3f	; 63
     554:	f8 94       	cli
     556:	0f 92       	push	r0
     558:	1f 92       	push	r1
     55a:	11 24       	eor	r1, r1
     55c:	2f 92       	push	r2
     55e:	3f 92       	push	r3
     560:	4f 92       	push	r4
     562:	5f 92       	push	r5
     564:	6f 92       	push	r6
     566:	7f 92       	push	r7
     568:	8f 92       	push	r8
     56a:	9f 92       	push	r9
     56c:	af 92       	push	r10
     56e:	bf 92       	push	r11
     570:	cf 92       	push	r12
     572:	df 92       	push	r13
     574:	ef 92       	push	r14
     576:	ff 92       	push	r15
     578:	0f 93       	push	r16
     57a:	1f 93       	push	r17
     57c:	2f 93       	push	r18
     57e:	3f 93       	push	r19
     580:	4f 93       	push	r20
     582:	5f 93       	push	r21
     584:	6f 93       	push	r22
     586:	7f 93       	push	r23
     588:	8f 93       	push	r24
     58a:	9f 93       	push	r25
     58c:	af 93       	push	r26
     58e:	bf 93       	push	r27
     590:	cf 93       	push	r28
     592:	df 93       	push	r29
     594:	ef 93       	push	r30
     596:	ff 93       	push	r31
     598:	a0 91 91 06 	lds	r26, 0x0691	; 0x800691 <pxCurrentTCB>
     59c:	b0 91 92 06 	lds	r27, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
     5a0:	0d b6       	in	r0, 0x3d	; 61
     5a2:	0d 92       	st	X+, r0
     5a4:	0e b6       	in	r0, 0x3e	; 62
     5a6:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     5a8:	0e 94 81 06 	call	0xd02	; 0xd02 <vTaskIncrementTick>
	vTaskSwitchContext();
     5ac:	0e 94 35 08 	call	0x106a	; 0x106a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     5b0:	a0 91 91 06 	lds	r26, 0x0691	; 0x800691 <pxCurrentTCB>
     5b4:	b0 91 92 06 	lds	r27, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
     5b8:	cd 91       	ld	r28, X+
     5ba:	cd bf       	out	0x3d, r28	; 61
     5bc:	dd 91       	ld	r29, X+
     5be:	de bf       	out	0x3e, r29	; 62
     5c0:	ff 91       	pop	r31
     5c2:	ef 91       	pop	r30
     5c4:	df 91       	pop	r29
     5c6:	cf 91       	pop	r28
     5c8:	bf 91       	pop	r27
     5ca:	af 91       	pop	r26
     5cc:	9f 91       	pop	r25
     5ce:	8f 91       	pop	r24
     5d0:	7f 91       	pop	r23
     5d2:	6f 91       	pop	r22
     5d4:	5f 91       	pop	r21
     5d6:	4f 91       	pop	r20
     5d8:	3f 91       	pop	r19
     5da:	2f 91       	pop	r18
     5dc:	1f 91       	pop	r17
     5de:	0f 91       	pop	r16
     5e0:	ff 90       	pop	r15
     5e2:	ef 90       	pop	r14
     5e4:	df 90       	pop	r13
     5e6:	cf 90       	pop	r12
     5e8:	bf 90       	pop	r11
     5ea:	af 90       	pop	r10
     5ec:	9f 90       	pop	r9
     5ee:	8f 90       	pop	r8
     5f0:	7f 90       	pop	r7
     5f2:	6f 90       	pop	r6
     5f4:	5f 90       	pop	r5
     5f6:	4f 90       	pop	r4
     5f8:	3f 90       	pop	r3
     5fa:	2f 90       	pop	r2
     5fc:	1f 90       	pop	r1
     5fe:	0f 90       	pop	r0
     600:	0f be       	out	0x3f, r0	; 63
     602:	0f 90       	pop	r0

	asm volatile ( "ret" );
     604:	08 95       	ret

00000606 <__vector_7>:
//	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     606:	0e 94 a8 02 	call	0x550	; 0x550 <vPortYieldFromTick>
		asm volatile ( "reti" );
     60a:	18 95       	reti

0000060c <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     60c:	cf 93       	push	r28
     60e:	df 93       	push	r29
     610:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     612:	0e 94 71 06 	call	0xce2	; 0xce2 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
     616:	20 91 80 00 	lds	r18, 0x0080	; 0x800080 <xNextFreeByte>
     61a:	30 91 81 00 	lds	r19, 0x0081	; 0x800081 <xNextFreeByte+0x1>
     61e:	ce 01       	movw	r24, r28
     620:	82 0f       	add	r24, r18
     622:	93 1f       	adc	r25, r19
     624:	8c 3d       	cpi	r24, 0xDC	; 220
     626:	45 e0       	ldi	r20, 0x05	; 5
     628:	94 07       	cpc	r25, r20
     62a:	58 f4       	brcc	.+22     	; 0x642 <pvPortMalloc+0x36>
     62c:	28 17       	cp	r18, r24
     62e:	39 07       	cpc	r19, r25
     630:	58 f4       	brcc	.+22     	; 0x648 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
     632:	e9 01       	movw	r28, r18
     634:	ce 57       	subi	r28, 0x7E	; 126
     636:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
     638:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <xNextFreeByte+0x1>
     63c:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <xNextFreeByte>
     640:	05 c0       	rjmp	.+10     	; 0x64c <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
     642:	c0 e0       	ldi	r28, 0x00	; 0
     644:	d0 e0       	ldi	r29, 0x00	; 0
     646:	02 c0       	rjmp	.+4      	; 0x64c <pvPortMalloc+0x40>
     648:	c0 e0       	ldi	r28, 0x00	; 0
     64a:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     64c:	0e 94 45 07 	call	0xe8a	; 0xe8a <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     650:	ce 01       	movw	r24, r28
     652:	df 91       	pop	r29
     654:	cf 91       	pop	r28
     656:	08 95       	ret

00000658 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     658:	08 95       	ret

0000065a <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     65a:	cf 93       	push	r28
     65c:	df 93       	push	r29
     65e:	ec 01       	movw	r28, r24
     660:	8c 8d       	ldd	r24, Y+28	; 0x1c
     662:	88 23       	and	r24, r24
     664:	a9 f1       	breq	.+106    	; 0x6d0 <prvCopyDataToQueue+0x76>
     666:	41 11       	cpse	r20, r1
     668:	17 c0       	rjmp	.+46     	; 0x698 <prvCopyDataToQueue+0x3e>
     66a:	48 2f       	mov	r20, r24
     66c:	50 e0       	ldi	r21, 0x00	; 0
     66e:	8c 81       	ldd	r24, Y+4	; 0x04
     670:	9d 81       	ldd	r25, Y+5	; 0x05
     672:	0e 94 4a 09 	call	0x1294	; 0x1294 <memcpy>
     676:	2c 8d       	ldd	r18, Y+28	; 0x1c
     678:	8c 81       	ldd	r24, Y+4	; 0x04
     67a:	9d 81       	ldd	r25, Y+5	; 0x05
     67c:	82 0f       	add	r24, r18
     67e:	91 1d       	adc	r25, r1
     680:	9d 83       	std	Y+5, r25	; 0x05
     682:	8c 83       	std	Y+4, r24	; 0x04
     684:	2a 81       	ldd	r18, Y+2	; 0x02
     686:	3b 81       	ldd	r19, Y+3	; 0x03
     688:	82 17       	cp	r24, r18
     68a:	93 07       	cpc	r25, r19
     68c:	08 f1       	brcs	.+66     	; 0x6d0 <prvCopyDataToQueue+0x76>
     68e:	88 81       	ld	r24, Y
     690:	99 81       	ldd	r25, Y+1	; 0x01
     692:	9d 83       	std	Y+5, r25	; 0x05
     694:	8c 83       	std	Y+4, r24	; 0x04
     696:	1c c0       	rjmp	.+56     	; 0x6d0 <prvCopyDataToQueue+0x76>
     698:	48 2f       	mov	r20, r24
     69a:	50 e0       	ldi	r21, 0x00	; 0
     69c:	8e 81       	ldd	r24, Y+6	; 0x06
     69e:	9f 81       	ldd	r25, Y+7	; 0x07
     6a0:	0e 94 4a 09 	call	0x1294	; 0x1294 <memcpy>
     6a4:	8c 8d       	ldd	r24, Y+28	; 0x1c
     6a6:	90 e0       	ldi	r25, 0x00	; 0
     6a8:	91 95       	neg	r25
     6aa:	81 95       	neg	r24
     6ac:	91 09       	sbc	r25, r1
     6ae:	2e 81       	ldd	r18, Y+6	; 0x06
     6b0:	3f 81       	ldd	r19, Y+7	; 0x07
     6b2:	28 0f       	add	r18, r24
     6b4:	39 1f       	adc	r19, r25
     6b6:	3f 83       	std	Y+7, r19	; 0x07
     6b8:	2e 83       	std	Y+6, r18	; 0x06
     6ba:	48 81       	ld	r20, Y
     6bc:	59 81       	ldd	r21, Y+1	; 0x01
     6be:	24 17       	cp	r18, r20
     6c0:	35 07       	cpc	r19, r21
     6c2:	30 f4       	brcc	.+12     	; 0x6d0 <prvCopyDataToQueue+0x76>
     6c4:	2a 81       	ldd	r18, Y+2	; 0x02
     6c6:	3b 81       	ldd	r19, Y+3	; 0x03
     6c8:	82 0f       	add	r24, r18
     6ca:	93 1f       	adc	r25, r19
     6cc:	9f 83       	std	Y+7, r25	; 0x07
     6ce:	8e 83       	std	Y+6, r24	; 0x06
     6d0:	8a 8d       	ldd	r24, Y+26	; 0x1a
     6d2:	8f 5f       	subi	r24, 0xFF	; 255
     6d4:	8a 8f       	std	Y+26, r24	; 0x1a
     6d6:	df 91       	pop	r29
     6d8:	cf 91       	pop	r28
     6da:	08 95       	ret

000006dc <prvCopyDataFromQueue>:
     6dc:	fc 01       	movw	r30, r24
     6de:	80 81       	ld	r24, Z
     6e0:	91 81       	ldd	r25, Z+1	; 0x01
     6e2:	00 97       	sbiw	r24, 0x00	; 0
     6e4:	a1 f0       	breq	.+40     	; 0x70e <prvCopyDataFromQueue+0x32>
     6e6:	44 8d       	ldd	r20, Z+28	; 0x1c
     6e8:	50 e0       	ldi	r21, 0x00	; 0
     6ea:	26 81       	ldd	r18, Z+6	; 0x06
     6ec:	37 81       	ldd	r19, Z+7	; 0x07
     6ee:	24 0f       	add	r18, r20
     6f0:	35 1f       	adc	r19, r21
     6f2:	37 83       	std	Z+7, r19	; 0x07
     6f4:	26 83       	std	Z+6, r18	; 0x06
     6f6:	a2 81       	ldd	r26, Z+2	; 0x02
     6f8:	b3 81       	ldd	r27, Z+3	; 0x03
     6fa:	2a 17       	cp	r18, r26
     6fc:	3b 07       	cpc	r19, r27
     6fe:	10 f0       	brcs	.+4      	; 0x704 <prvCopyDataFromQueue+0x28>
     700:	97 83       	std	Z+7, r25	; 0x07
     702:	86 83       	std	Z+6, r24	; 0x06
     704:	cb 01       	movw	r24, r22
     706:	66 81       	ldd	r22, Z+6	; 0x06
     708:	77 81       	ldd	r23, Z+7	; 0x07
     70a:	0e 94 4a 09 	call	0x1294	; 0x1294 <memcpy>
     70e:	08 95       	ret

00000710 <prvUnlockQueue>:
     710:	0f 93       	push	r16
     712:	1f 93       	push	r17
     714:	cf 93       	push	r28
     716:	df 93       	push	r29
     718:	ec 01       	movw	r28, r24
     71a:	0f b6       	in	r0, 0x3f	; 63
     71c:	f8 94       	cli
     71e:	0f 92       	push	r0
     720:	8e 8d       	ldd	r24, Y+30	; 0x1e
     722:	18 16       	cp	r1, r24
     724:	b4 f4       	brge	.+44     	; 0x752 <prvUnlockQueue+0x42>
     726:	89 89       	ldd	r24, Y+17	; 0x11
     728:	81 11       	cpse	r24, r1
     72a:	05 c0       	rjmp	.+10     	; 0x736 <prvUnlockQueue+0x26>
     72c:	12 c0       	rjmp	.+36     	; 0x752 <prvUnlockQueue+0x42>
     72e:	99 89       	ldd	r25, Y+17	; 0x11
     730:	91 11       	cpse	r25, r1
     732:	04 c0       	rjmp	.+8      	; 0x73c <prvUnlockQueue+0x2c>
     734:	0e c0       	rjmp	.+28     	; 0x752 <prvUnlockQueue+0x42>
     736:	8e 01       	movw	r16, r28
     738:	0f 5e       	subi	r16, 0xEF	; 239
     73a:	1f 4f       	sbci	r17, 0xFF	; 255
     73c:	c8 01       	movw	r24, r16
     73e:	0e 94 bf 08 	call	0x117e	; 0x117e <xTaskRemoveFromEventList>
     742:	81 11       	cpse	r24, r1
     744:	0e 94 46 09 	call	0x128c	; 0x128c <vTaskMissedYield>
     748:	9e 8d       	ldd	r25, Y+30	; 0x1e
     74a:	91 50       	subi	r25, 0x01	; 1
     74c:	9e 8f       	std	Y+30, r25	; 0x1e
     74e:	19 16       	cp	r1, r25
     750:	74 f3       	brlt	.-36     	; 0x72e <prvUnlockQueue+0x1e>
     752:	8f ef       	ldi	r24, 0xFF	; 255
     754:	8e 8f       	std	Y+30, r24	; 0x1e
     756:	0f 90       	pop	r0
     758:	0f be       	out	0x3f, r0	; 63
     75a:	0f b6       	in	r0, 0x3f	; 63
     75c:	f8 94       	cli
     75e:	0f 92       	push	r0
     760:	8d 8d       	ldd	r24, Y+29	; 0x1d
     762:	18 16       	cp	r1, r24
     764:	b4 f4       	brge	.+44     	; 0x792 <prvUnlockQueue+0x82>
     766:	88 85       	ldd	r24, Y+8	; 0x08
     768:	81 11       	cpse	r24, r1
     76a:	05 c0       	rjmp	.+10     	; 0x776 <prvUnlockQueue+0x66>
     76c:	12 c0       	rjmp	.+36     	; 0x792 <prvUnlockQueue+0x82>
     76e:	98 85       	ldd	r25, Y+8	; 0x08
     770:	91 11       	cpse	r25, r1
     772:	04 c0       	rjmp	.+8      	; 0x77c <prvUnlockQueue+0x6c>
     774:	0e c0       	rjmp	.+28     	; 0x792 <prvUnlockQueue+0x82>
     776:	8e 01       	movw	r16, r28
     778:	08 5f       	subi	r16, 0xF8	; 248
     77a:	1f 4f       	sbci	r17, 0xFF	; 255
     77c:	c8 01       	movw	r24, r16
     77e:	0e 94 bf 08 	call	0x117e	; 0x117e <xTaskRemoveFromEventList>
     782:	81 11       	cpse	r24, r1
     784:	0e 94 46 09 	call	0x128c	; 0x128c <vTaskMissedYield>
     788:	9d 8d       	ldd	r25, Y+29	; 0x1d
     78a:	91 50       	subi	r25, 0x01	; 1
     78c:	9d 8f       	std	Y+29, r25	; 0x1d
     78e:	19 16       	cp	r1, r25
     790:	74 f3       	brlt	.-36     	; 0x76e <prvUnlockQueue+0x5e>
     792:	8f ef       	ldi	r24, 0xFF	; 255
     794:	8d 8f       	std	Y+29, r24	; 0x1d
     796:	0f 90       	pop	r0
     798:	0f be       	out	0x3f, r0	; 63
     79a:	df 91       	pop	r29
     79c:	cf 91       	pop	r28
     79e:	1f 91       	pop	r17
     7a0:	0f 91       	pop	r16
     7a2:	08 95       	ret

000007a4 <xQueueGenericSend>:
     7a4:	9f 92       	push	r9
     7a6:	af 92       	push	r10
     7a8:	bf 92       	push	r11
     7aa:	cf 92       	push	r12
     7ac:	df 92       	push	r13
     7ae:	ef 92       	push	r14
     7b0:	ff 92       	push	r15
     7b2:	0f 93       	push	r16
     7b4:	1f 93       	push	r17
     7b6:	cf 93       	push	r28
     7b8:	df 93       	push	r29
     7ba:	00 d0       	rcall	.+0      	; 0x7bc <xQueueGenericSend+0x18>
     7bc:	00 d0       	rcall	.+0      	; 0x7be <xQueueGenericSend+0x1a>
     7be:	1f 92       	push	r1
     7c0:	cd b7       	in	r28, 0x3d	; 61
     7c2:	de b7       	in	r29, 0x3e	; 62
     7c4:	8c 01       	movw	r16, r24
     7c6:	6b 01       	movw	r12, r22
     7c8:	5d 83       	std	Y+5, r21	; 0x05
     7ca:	4c 83       	std	Y+4, r20	; 0x04
     7cc:	92 2e       	mov	r9, r18
     7ce:	b1 2c       	mov	r11, r1
     7d0:	aa 24       	eor	r10, r10
     7d2:	a3 94       	inc	r10
     7d4:	7c 01       	movw	r14, r24
     7d6:	88 e0       	ldi	r24, 0x08	; 8
     7d8:	e8 0e       	add	r14, r24
     7da:	f1 1c       	adc	r15, r1
     7dc:	0f b6       	in	r0, 0x3f	; 63
     7de:	f8 94       	cli
     7e0:	0f 92       	push	r0
     7e2:	f8 01       	movw	r30, r16
     7e4:	32 8d       	ldd	r19, Z+26	; 0x1a
     7e6:	93 8d       	ldd	r25, Z+27	; 0x1b
     7e8:	39 17       	cp	r19, r25
     7ea:	a8 f4       	brcc	.+42     	; 0x816 <xQueueGenericSend+0x72>
     7ec:	49 2d       	mov	r20, r9
     7ee:	b6 01       	movw	r22, r12
     7f0:	c8 01       	movw	r24, r16
     7f2:	0e 94 2d 03 	call	0x65a	; 0x65a <prvCopyDataToQueue>
     7f6:	f8 01       	movw	r30, r16
     7f8:	81 89       	ldd	r24, Z+17	; 0x11
     7fa:	88 23       	and	r24, r24
     7fc:	41 f0       	breq	.+16     	; 0x80e <xQueueGenericSend+0x6a>
     7fe:	c8 01       	movw	r24, r16
     800:	41 96       	adiw	r24, 0x11	; 17
     802:	0e 94 bf 08 	call	0x117e	; 0x117e <xTaskRemoveFromEventList>
     806:	81 30       	cpi	r24, 0x01	; 1
     808:	11 f4       	brne	.+4      	; 0x80e <xQueueGenericSend+0x6a>
     80a:	0e 94 4f 02 	call	0x49e	; 0x49e <vPortYield>
     80e:	0f 90       	pop	r0
     810:	0f be       	out	0x3f, r0	; 63
     812:	81 e0       	ldi	r24, 0x01	; 1
     814:	50 c0       	rjmp	.+160    	; 0x8b6 <__stack+0x57>
     816:	ec 81       	ldd	r30, Y+4	; 0x04
     818:	fd 81       	ldd	r31, Y+5	; 0x05
     81a:	ef 2b       	or	r30, r31
     81c:	21 f4       	brne	.+8      	; 0x826 <xQueueGenericSend+0x82>
     81e:	0f 90       	pop	r0
     820:	0f be       	out	0x3f, r0	; 63
     822:	80 e0       	ldi	r24, 0x00	; 0
     824:	48 c0       	rjmp	.+144    	; 0x8b6 <__stack+0x57>
     826:	b1 10       	cpse	r11, r1
     828:	05 c0       	rjmp	.+10     	; 0x834 <xQueueGenericSend+0x90>
     82a:	ce 01       	movw	r24, r28
     82c:	01 96       	adiw	r24, 0x01	; 1
     82e:	0e 94 04 09 	call	0x1208	; 0x1208 <vTaskSetTimeOutState>
     832:	ba 2c       	mov	r11, r10
     834:	0f 90       	pop	r0
     836:	0f be       	out	0x3f, r0	; 63
     838:	0e 94 71 06 	call	0xce2	; 0xce2 <vTaskSuspendAll>
     83c:	0f b6       	in	r0, 0x3f	; 63
     83e:	f8 94       	cli
     840:	0f 92       	push	r0
     842:	f8 01       	movw	r30, r16
     844:	85 8d       	ldd	r24, Z+29	; 0x1d
     846:	8f 3f       	cpi	r24, 0xFF	; 255
     848:	09 f4       	brne	.+2      	; 0x84c <xQueueGenericSend+0xa8>
     84a:	15 8e       	std	Z+29, r1	; 0x1d
     84c:	f8 01       	movw	r30, r16
     84e:	86 8d       	ldd	r24, Z+30	; 0x1e
     850:	8f 3f       	cpi	r24, 0xFF	; 255
     852:	09 f4       	brne	.+2      	; 0x856 <xQueueGenericSend+0xb2>
     854:	16 8e       	std	Z+30, r1	; 0x1e
     856:	0f 90       	pop	r0
     858:	0f be       	out	0x3f, r0	; 63
     85a:	be 01       	movw	r22, r28
     85c:	6c 5f       	subi	r22, 0xFC	; 252
     85e:	7f 4f       	sbci	r23, 0xFF	; 255
     860:	ce 01       	movw	r24, r28
     862:	01 96       	adiw	r24, 0x01	; 1
     864:	0e 94 0f 09 	call	0x121e	; 0x121e <xTaskCheckForTimeOut>
     868:	81 11       	cpse	r24, r1
     86a:	1f c0       	rjmp	.+62     	; 0x8aa <__stack+0x4b>
     86c:	0f b6       	in	r0, 0x3f	; 63
     86e:	f8 94       	cli
     870:	0f 92       	push	r0
     872:	f8 01       	movw	r30, r16
     874:	92 8d       	ldd	r25, Z+26	; 0x1a
     876:	0f 90       	pop	r0
     878:	0f be       	out	0x3f, r0	; 63
     87a:	83 8d       	ldd	r24, Z+27	; 0x1b
     87c:	98 13       	cpse	r25, r24
     87e:	0f c0       	rjmp	.+30     	; 0x89e <__stack+0x3f>
     880:	6c 81       	ldd	r22, Y+4	; 0x04
     882:	7d 81       	ldd	r23, Y+5	; 0x05
     884:	c7 01       	movw	r24, r14
     886:	0e 94 a1 08 	call	0x1142	; 0x1142 <vTaskPlaceOnEventList>
     88a:	c8 01       	movw	r24, r16
     88c:	0e 94 88 03 	call	0x710	; 0x710 <prvUnlockQueue>
     890:	0e 94 45 07 	call	0xe8a	; 0xe8a <xTaskResumeAll>
     894:	81 11       	cpse	r24, r1
     896:	a2 cf       	rjmp	.-188    	; 0x7dc <xQueueGenericSend+0x38>
     898:	0e 94 4f 02 	call	0x49e	; 0x49e <vPortYield>
     89c:	9f cf       	rjmp	.-194    	; 0x7dc <xQueueGenericSend+0x38>
     89e:	c8 01       	movw	r24, r16
     8a0:	0e 94 88 03 	call	0x710	; 0x710 <prvUnlockQueue>
     8a4:	0e 94 45 07 	call	0xe8a	; 0xe8a <xTaskResumeAll>
     8a8:	99 cf       	rjmp	.-206    	; 0x7dc <xQueueGenericSend+0x38>
     8aa:	c8 01       	movw	r24, r16
     8ac:	0e 94 88 03 	call	0x710	; 0x710 <prvUnlockQueue>
     8b0:	0e 94 45 07 	call	0xe8a	; 0xe8a <xTaskResumeAll>
     8b4:	80 e0       	ldi	r24, 0x00	; 0
     8b6:	0f 90       	pop	r0
     8b8:	0f 90       	pop	r0
     8ba:	0f 90       	pop	r0
     8bc:	0f 90       	pop	r0
     8be:	0f 90       	pop	r0
     8c0:	df 91       	pop	r29
     8c2:	cf 91       	pop	r28
     8c4:	1f 91       	pop	r17
     8c6:	0f 91       	pop	r16
     8c8:	ff 90       	pop	r15
     8ca:	ef 90       	pop	r14
     8cc:	df 90       	pop	r13
     8ce:	cf 90       	pop	r12
     8d0:	bf 90       	pop	r11
     8d2:	af 90       	pop	r10
     8d4:	9f 90       	pop	r9
     8d6:	08 95       	ret

000008d8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     8d8:	9f 92       	push	r9
     8da:	af 92       	push	r10
     8dc:	bf 92       	push	r11
     8de:	cf 92       	push	r12
     8e0:	df 92       	push	r13
     8e2:	ef 92       	push	r14
     8e4:	ff 92       	push	r15
     8e6:	0f 93       	push	r16
     8e8:	1f 93       	push	r17
     8ea:	cf 93       	push	r28
     8ec:	df 93       	push	r29
     8ee:	00 d0       	rcall	.+0      	; 0x8f0 <xQueueGenericReceive+0x18>
     8f0:	00 d0       	rcall	.+0      	; 0x8f2 <xQueueGenericReceive+0x1a>
     8f2:	1f 92       	push	r1
     8f4:	cd b7       	in	r28, 0x3d	; 61
     8f6:	de b7       	in	r29, 0x3e	; 62
     8f8:	8c 01       	movw	r16, r24
     8fa:	6b 01       	movw	r12, r22
     8fc:	5d 83       	std	Y+5, r21	; 0x05
     8fe:	4c 83       	std	Y+4, r20	; 0x04
     900:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     902:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     904:	aa 24       	eor	r10, r10
     906:	a3 94       	inc	r10
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     908:	7c 01       	movw	r14, r24
     90a:	81 e1       	ldi	r24, 0x11	; 17
     90c:	e8 0e       	add	r14, r24
     90e:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     910:	0f b6       	in	r0, 0x3f	; 63
     912:	f8 94       	cli
     914:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     916:	f8 01       	movw	r30, r16
     918:	92 8d       	ldd	r25, Z+26	; 0x1a
     91a:	99 23       	and	r25, r25
     91c:	49 f1       	breq	.+82     	; 0x970 <xQueueGenericReceive+0x98>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     91e:	e6 80       	ldd	r14, Z+6	; 0x06
     920:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     922:	b6 01       	movw	r22, r12
     924:	c8 01       	movw	r24, r16
     926:	0e 94 6e 03 	call	0x6dc	; 0x6dc <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     92a:	91 10       	cpse	r9, r1
     92c:	10 c0       	rjmp	.+32     	; 0x94e <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     92e:	f8 01       	movw	r30, r16
     930:	82 8d       	ldd	r24, Z+26	; 0x1a
     932:	81 50       	subi	r24, 0x01	; 1
     934:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     936:	80 85       	ldd	r24, Z+8	; 0x08
     938:	88 23       	and	r24, r24
     93a:	b1 f0       	breq	.+44     	; 0x968 <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     93c:	c8 01       	movw	r24, r16
     93e:	08 96       	adiw	r24, 0x08	; 8
     940:	0e 94 bf 08 	call	0x117e	; 0x117e <xTaskRemoveFromEventList>
     944:	81 30       	cpi	r24, 0x01	; 1
     946:	81 f4       	brne	.+32     	; 0x968 <xQueueGenericReceive+0x90>
						{
							portYIELD_WITHIN_API();
     948:	0e 94 4f 02 	call	0x49e	; 0x49e <vPortYield>
     94c:	0d c0       	rjmp	.+26     	; 0x968 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     94e:	f8 01       	movw	r30, r16
     950:	f7 82       	std	Z+7, r15	; 0x07
     952:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     954:	81 89       	ldd	r24, Z+17	; 0x11
     956:	88 23       	and	r24, r24
     958:	39 f0       	breq	.+14     	; 0x968 <xQueueGenericReceive+0x90>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     95a:	c8 01       	movw	r24, r16
     95c:	41 96       	adiw	r24, 0x11	; 17
     95e:	0e 94 bf 08 	call	0x117e	; 0x117e <xTaskRemoveFromEventList>
     962:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     964:	0e 94 4f 02 	call	0x49e	; 0x49e <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     968:	0f 90       	pop	r0
     96a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     96c:	81 e0       	ldi	r24, 0x01	; 1
     96e:	4f c0       	rjmp	.+158    	; 0xa0e <xQueueGenericReceive+0x136>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     970:	4c 81       	ldd	r20, Y+4	; 0x04
     972:	5d 81       	ldd	r21, Y+5	; 0x05
     974:	45 2b       	or	r20, r21
     976:	21 f4       	brne	.+8      	; 0x980 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     978:	0f 90       	pop	r0
     97a:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     97c:	80 e0       	ldi	r24, 0x00	; 0
     97e:	47 c0       	rjmp	.+142    	; 0xa0e <xQueueGenericReceive+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
     980:	b1 10       	cpse	r11, r1
     982:	05 c0       	rjmp	.+10     	; 0x98e <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     984:	ce 01       	movw	r24, r28
     986:	01 96       	adiw	r24, 0x01	; 1
     988:	0e 94 04 09 	call	0x1208	; 0x1208 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     98c:	ba 2c       	mov	r11, r10
				}
			}
		}
		taskEXIT_CRITICAL();
     98e:	0f 90       	pop	r0
     990:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     992:	0e 94 71 06 	call	0xce2	; 0xce2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     996:	0f b6       	in	r0, 0x3f	; 63
     998:	f8 94       	cli
     99a:	0f 92       	push	r0
     99c:	f8 01       	movw	r30, r16
     99e:	85 8d       	ldd	r24, Z+29	; 0x1d
     9a0:	8f 3f       	cpi	r24, 0xFF	; 255
     9a2:	09 f4       	brne	.+2      	; 0x9a6 <xQueueGenericReceive+0xce>
     9a4:	15 8e       	std	Z+29, r1	; 0x1d
     9a6:	f8 01       	movw	r30, r16
     9a8:	96 8d       	ldd	r25, Z+30	; 0x1e
     9aa:	9f 3f       	cpi	r25, 0xFF	; 255
     9ac:	09 f4       	brne	.+2      	; 0x9b0 <xQueueGenericReceive+0xd8>
     9ae:	16 8e       	std	Z+30, r1	; 0x1e
     9b0:	0f 90       	pop	r0
     9b2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     9b4:	be 01       	movw	r22, r28
     9b6:	6c 5f       	subi	r22, 0xFC	; 252
     9b8:	7f 4f       	sbci	r23, 0xFF	; 255
     9ba:	ce 01       	movw	r24, r28
     9bc:	01 96       	adiw	r24, 0x01	; 1
     9be:	0e 94 0f 09 	call	0x121e	; 0x121e <xTaskCheckForTimeOut>
     9c2:	81 11       	cpse	r24, r1
     9c4:	1e c0       	rjmp	.+60     	; 0xa02 <xQueueGenericReceive+0x12a>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     9c6:	0f b6       	in	r0, 0x3f	; 63
     9c8:	f8 94       	cli
     9ca:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     9cc:	f8 01       	movw	r30, r16
     9ce:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     9d0:	0f 90       	pop	r0
     9d2:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     9d4:	81 11       	cpse	r24, r1
     9d6:	0f c0       	rjmp	.+30     	; 0x9f6 <xQueueGenericReceive+0x11e>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     9d8:	6c 81       	ldd	r22, Y+4	; 0x04
     9da:	7d 81       	ldd	r23, Y+5	; 0x05
     9dc:	c7 01       	movw	r24, r14
     9de:	0e 94 a1 08 	call	0x1142	; 0x1142 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     9e2:	c8 01       	movw	r24, r16
     9e4:	0e 94 88 03 	call	0x710	; 0x710 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     9e8:	0e 94 45 07 	call	0xe8a	; 0xe8a <xTaskResumeAll>
     9ec:	81 11       	cpse	r24, r1
     9ee:	90 cf       	rjmp	.-224    	; 0x910 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
     9f0:	0e 94 4f 02 	call	0x49e	; 0x49e <vPortYield>
     9f4:	8d cf       	rjmp	.-230    	; 0x910 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     9f6:	c8 01       	movw	r24, r16
     9f8:	0e 94 88 03 	call	0x710	; 0x710 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     9fc:	0e 94 45 07 	call	0xe8a	; 0xe8a <xTaskResumeAll>
     a00:	87 cf       	rjmp	.-242    	; 0x910 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     a02:	c8 01       	movw	r24, r16
     a04:	0e 94 88 03 	call	0x710	; 0x710 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     a08:	0e 94 45 07 	call	0xe8a	; 0xe8a <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     a0c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     a0e:	0f 90       	pop	r0
     a10:	0f 90       	pop	r0
     a12:	0f 90       	pop	r0
     a14:	0f 90       	pop	r0
     a16:	0f 90       	pop	r0
     a18:	df 91       	pop	r29
     a1a:	cf 91       	pop	r28
     a1c:	1f 91       	pop	r17
     a1e:	0f 91       	pop	r16
     a20:	ff 90       	pop	r15
     a22:	ef 90       	pop	r14
     a24:	df 90       	pop	r13
     a26:	cf 90       	pop	r12
     a28:	bf 90       	pop	r11
     a2a:	af 90       	pop	r10
     a2c:	9f 90       	pop	r9
     a2e:	08 95       	ret

00000a30 <prvIdleTask>:
unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
}
     a30:	c8 e8       	ldi	r28, 0x88	; 136
     a32:	d6 e0       	ldi	r29, 0x06	; 6
     a34:	88 81       	ld	r24, Y
     a36:	82 30       	cpi	r24, 0x02	; 2
     a38:	e8 f3       	brcs	.-6      	; 0xa34 <prvIdleTask+0x4>
     a3a:	0e 94 4f 02 	call	0x49e	; 0x49e <vPortYield>
     a3e:	fa cf       	rjmp	.-12     	; 0xa34 <prvIdleTask+0x4>

00000a40 <prvAddCurrentTaskToDelayedList>:
     a40:	cf 93       	push	r28
     a42:	df 93       	push	r29
     a44:	ec 01       	movw	r28, r24
     a46:	e0 91 91 06 	lds	r30, 0x0691	; 0x800691 <pxCurrentTCB>
     a4a:	f0 91 92 06 	lds	r31, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
     a4e:	93 83       	std	Z+3, r25	; 0x03
     a50:	82 83       	std	Z+2, r24	; 0x02
     a52:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <xTickCount>
     a56:	90 91 67 06 	lds	r25, 0x0667	; 0x800667 <xTickCount+0x1>
     a5a:	c8 17       	cp	r28, r24
     a5c:	d9 07       	cpc	r29, r25
     a5e:	68 f4       	brcc	.+26     	; 0xa7a <prvAddCurrentTaskToDelayedList+0x3a>
     a60:	60 91 91 06 	lds	r22, 0x0691	; 0x800691 <pxCurrentTCB>
     a64:	70 91 92 06 	lds	r23, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
     a68:	80 91 72 06 	lds	r24, 0x0672	; 0x800672 <pxOverflowDelayedTaskList>
     a6c:	90 91 73 06 	lds	r25, 0x0673	; 0x800673 <pxOverflowDelayedTaskList+0x1>
     a70:	6e 5f       	subi	r22, 0xFE	; 254
     a72:	7f 4f       	sbci	r23, 0xFF	; 255
     a74:	0e 94 4d 01 	call	0x29a	; 0x29a <vListInsert>
     a78:	17 c0       	rjmp	.+46     	; 0xaa8 <prvAddCurrentTaskToDelayedList+0x68>
     a7a:	60 91 91 06 	lds	r22, 0x0691	; 0x800691 <pxCurrentTCB>
     a7e:	70 91 92 06 	lds	r23, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
     a82:	80 91 74 06 	lds	r24, 0x0674	; 0x800674 <pxDelayedTaskList>
     a86:	90 91 75 06 	lds	r25, 0x0675	; 0x800675 <pxDelayedTaskList+0x1>
     a8a:	6e 5f       	subi	r22, 0xFE	; 254
     a8c:	7f 4f       	sbci	r23, 0xFF	; 255
     a8e:	0e 94 4d 01 	call	0x29a	; 0x29a <vListInsert>
     a92:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     a96:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
     a9a:	c8 17       	cp	r28, r24
     a9c:	d9 07       	cpc	r29, r25
     a9e:	20 f4       	brcc	.+8      	; 0xaa8 <prvAddCurrentTaskToDelayedList+0x68>
     aa0:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__data_start+0x1>
     aa4:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__data_start>
     aa8:	df 91       	pop	r29
     aaa:	cf 91       	pop	r28
     aac:	08 95       	ret

00000aae <xTaskGenericCreate>:
     aae:	4f 92       	push	r4
     ab0:	5f 92       	push	r5
     ab2:	6f 92       	push	r6
     ab4:	7f 92       	push	r7
     ab6:	8f 92       	push	r8
     ab8:	9f 92       	push	r9
     aba:	af 92       	push	r10
     abc:	bf 92       	push	r11
     abe:	cf 92       	push	r12
     ac0:	df 92       	push	r13
     ac2:	ef 92       	push	r14
     ac4:	ff 92       	push	r15
     ac6:	0f 93       	push	r16
     ac8:	cf 93       	push	r28
     aca:	df 93       	push	r29
     acc:	5c 01       	movw	r10, r24
     ace:	4b 01       	movw	r8, r22
     ad0:	3a 01       	movw	r6, r20
     ad2:	29 01       	movw	r4, r18
     ad4:	81 e2       	ldi	r24, 0x21	; 33
     ad6:	90 e0       	ldi	r25, 0x00	; 0
     ad8:	0e 94 06 03 	call	0x60c	; 0x60c <pvPortMalloc>
     adc:	ec 01       	movw	r28, r24
     ade:	89 2b       	or	r24, r25
     ae0:	09 f4       	brne	.+2      	; 0xae4 <xTaskGenericCreate+0x36>
     ae2:	a5 c0       	rjmp	.+330    	; 0xc2e <xTaskGenericCreate+0x180>
     ae4:	c1 14       	cp	r12, r1
     ae6:	d1 04       	cpc	r13, r1
     ae8:	09 f0       	breq	.+2      	; 0xaec <xTaskGenericCreate+0x3e>
     aea:	9d c0       	rjmp	.+314    	; 0xc26 <xTaskGenericCreate+0x178>
     aec:	c3 01       	movw	r24, r6
     aee:	0e 94 06 03 	call	0x60c	; 0x60c <pvPortMalloc>
     af2:	98 8f       	std	Y+24, r25	; 0x18
     af4:	8f 8b       	std	Y+23, r24	; 0x17
     af6:	00 97       	sbiw	r24, 0x00	; 0
     af8:	21 f4       	brne	.+8      	; 0xb02 <xTaskGenericCreate+0x54>
     afa:	ce 01       	movw	r24, r28
     afc:	0e 94 2c 03 	call	0x658	; 0x658 <vPortFree>
     b00:	96 c0       	rjmp	.+300    	; 0xc2e <xTaskGenericCreate+0x180>
     b02:	a3 01       	movw	r20, r6
     b04:	65 ea       	ldi	r22, 0xA5	; 165
     b06:	70 e0       	ldi	r23, 0x00	; 0
     b08:	0e 94 53 09 	call	0x12a6	; 0x12a6 <memset>
     b0c:	93 01       	movw	r18, r6
     b0e:	21 50       	subi	r18, 0x01	; 1
     b10:	31 09       	sbc	r19, r1
     b12:	8f 89       	ldd	r24, Y+23	; 0x17
     b14:	98 8d       	ldd	r25, Y+24	; 0x18
     b16:	3c 01       	movw	r6, r24
     b18:	62 0e       	add	r6, r18
     b1a:	73 1e       	adc	r7, r19
     b1c:	48 e0       	ldi	r20, 0x08	; 8
     b1e:	50 e0       	ldi	r21, 0x00	; 0
     b20:	b4 01       	movw	r22, r8
     b22:	ce 01       	movw	r24, r28
     b24:	49 96       	adiw	r24, 0x19	; 25
     b26:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <strncpy>
     b2a:	18 a2       	std	Y+32, r1	; 0x20
     b2c:	1e 8a       	std	Y+22, r1	; 0x16
     b2e:	6e 01       	movw	r12, r28
     b30:	82 e0       	ldi	r24, 0x02	; 2
     b32:	c8 0e       	add	r12, r24
     b34:	d1 1c       	adc	r13, r1
     b36:	c6 01       	movw	r24, r12
     b38:	0e 94 22 01 	call	0x244	; 0x244 <vListInitialiseItem>
     b3c:	ce 01       	movw	r24, r28
     b3e:	0c 96       	adiw	r24, 0x0c	; 12
     b40:	0e 94 22 01 	call	0x244	; 0x244 <vListInitialiseItem>
     b44:	d9 87       	std	Y+9, r29	; 0x09
     b46:	c8 87       	std	Y+8, r28	; 0x08
     b48:	81 e0       	ldi	r24, 0x01	; 1
     b4a:	90 e0       	ldi	r25, 0x00	; 0
     b4c:	9d 87       	std	Y+13, r25	; 0x0d
     b4e:	8c 87       	std	Y+12, r24	; 0x0c
     b50:	db 8b       	std	Y+19, r29	; 0x13
     b52:	ca 8b       	std	Y+18, r28	; 0x12
     b54:	a2 01       	movw	r20, r4
     b56:	b5 01       	movw	r22, r10
     b58:	c3 01       	movw	r24, r6
     b5a:	0e 94 ae 01 	call	0x35c	; 0x35c <pxPortInitialiseStack>
     b5e:	99 83       	std	Y+1, r25	; 0x01
     b60:	88 83       	st	Y, r24
     b62:	e1 14       	cp	r14, r1
     b64:	f1 04       	cpc	r15, r1
     b66:	19 f0       	breq	.+6      	; 0xb6e <xTaskGenericCreate+0xc0>
     b68:	f7 01       	movw	r30, r14
     b6a:	d1 83       	std	Z+1, r29	; 0x01
     b6c:	c0 83       	st	Z, r28
     b6e:	0f b6       	in	r0, 0x3f	; 63
     b70:	f8 94       	cli
     b72:	0f 92       	push	r0
     b74:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <uxCurrentNumberOfTasks>
     b78:	8f 5f       	subi	r24, 0xFF	; 255
     b7a:	80 93 68 06 	sts	0x0668, r24	; 0x800668 <uxCurrentNumberOfTasks>
     b7e:	80 91 91 06 	lds	r24, 0x0691	; 0x800691 <pxCurrentTCB>
     b82:	90 91 92 06 	lds	r25, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
     b86:	89 2b       	or	r24, r25
     b88:	49 f4       	brne	.+18     	; 0xb9c <xTaskGenericCreate+0xee>
     b8a:	d0 93 92 06 	sts	0x0692, r29	; 0x800692 <pxCurrentTCB+0x1>
     b8e:	c0 93 91 06 	sts	0x0691, r28	; 0x800691 <pxCurrentTCB>
     b92:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <uxCurrentNumberOfTasks>
     b96:	81 30       	cpi	r24, 0x01	; 1
     b98:	81 f4       	brne	.+32     	; 0xbba <xTaskGenericCreate+0x10c>
     b9a:	4b c0       	rjmp	.+150    	; 0xc32 <xTaskGenericCreate+0x184>
     b9c:	80 91 63 06 	lds	r24, 0x0663	; 0x800663 <xSchedulerRunning>
     ba0:	81 11       	cpse	r24, r1
     ba2:	0b c0       	rjmp	.+22     	; 0xbba <xTaskGenericCreate+0x10c>
     ba4:	e0 91 91 06 	lds	r30, 0x0691	; 0x800691 <pxCurrentTCB>
     ba8:	f0 91 92 06 	lds	r31, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
     bac:	86 89       	ldd	r24, Z+22	; 0x16
     bae:	08 17       	cp	r16, r24
     bb0:	20 f0       	brcs	.+8      	; 0xbba <xTaskGenericCreate+0x10c>
     bb2:	d0 93 92 06 	sts	0x0692, r29	; 0x800692 <pxCurrentTCB+0x1>
     bb6:	c0 93 91 06 	sts	0x0691, r28	; 0x800691 <pxCurrentTCB>
     bba:	8e 89       	ldd	r24, Y+22	; 0x16
     bbc:	90 91 65 06 	lds	r25, 0x0665	; 0x800665 <uxTopUsedPriority>
     bc0:	98 17       	cp	r25, r24
     bc2:	10 f4       	brcc	.+4      	; 0xbc8 <xTaskGenericCreate+0x11a>
     bc4:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <uxTopUsedPriority>
     bc8:	90 91 5e 06 	lds	r25, 0x065E	; 0x80065e <uxTCBNumber>
     bcc:	9f 5f       	subi	r25, 0xFF	; 255
     bce:	90 93 5e 06 	sts	0x065E, r25	; 0x80065e <uxTCBNumber>
     bd2:	90 91 64 06 	lds	r25, 0x0664	; 0x800664 <uxTopReadyPriority>
     bd6:	98 17       	cp	r25, r24
     bd8:	10 f4       	brcc	.+4      	; 0xbde <xTaskGenericCreate+0x130>
     bda:	80 93 64 06 	sts	0x0664, r24	; 0x800664 <uxTopReadyPriority>
     bde:	90 e0       	ldi	r25, 0x00	; 0
     be0:	9c 01       	movw	r18, r24
     be2:	22 0f       	add	r18, r18
     be4:	33 1f       	adc	r19, r19
     be6:	22 0f       	add	r18, r18
     be8:	33 1f       	adc	r19, r19
     bea:	22 0f       	add	r18, r18
     bec:	33 1f       	adc	r19, r19
     bee:	82 0f       	add	r24, r18
     bf0:	93 1f       	adc	r25, r19
     bf2:	b6 01       	movw	r22, r12
     bf4:	88 57       	subi	r24, 0x78	; 120
     bf6:	99 4f       	sbci	r25, 0xF9	; 249
     bf8:	0e 94 26 01 	call	0x24c	; 0x24c <vListInsertEnd>
     bfc:	0f 90       	pop	r0
     bfe:	0f be       	out	0x3f, r0	; 63
     c00:	80 91 63 06 	lds	r24, 0x0663	; 0x800663 <xSchedulerRunning>
     c04:	88 23       	and	r24, r24
     c06:	59 f0       	breq	.+22     	; 0xc1e <xTaskGenericCreate+0x170>
     c08:	e0 91 91 06 	lds	r30, 0x0691	; 0x800691 <pxCurrentTCB>
     c0c:	f0 91 92 06 	lds	r31, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
     c10:	86 89       	ldd	r24, Z+22	; 0x16
     c12:	80 17       	cp	r24, r16
     c14:	30 f4       	brcc	.+12     	; 0xc22 <xTaskGenericCreate+0x174>
     c16:	0e 94 4f 02 	call	0x49e	; 0x49e <vPortYield>
     c1a:	81 e0       	ldi	r24, 0x01	; 1
     c1c:	27 c0       	rjmp	.+78     	; 0xc6c <xTaskGenericCreate+0x1be>
     c1e:	81 e0       	ldi	r24, 0x01	; 1
     c20:	25 c0       	rjmp	.+74     	; 0xc6c <xTaskGenericCreate+0x1be>
     c22:	81 e0       	ldi	r24, 0x01	; 1
     c24:	23 c0       	rjmp	.+70     	; 0xc6c <xTaskGenericCreate+0x1be>
     c26:	d8 8e       	std	Y+24, r13	; 0x18
     c28:	cf 8a       	std	Y+23, r12	; 0x17
     c2a:	c6 01       	movw	r24, r12
     c2c:	6a cf       	rjmp	.-300    	; 0xb02 <xTaskGenericCreate+0x54>
     c2e:	8f ef       	ldi	r24, 0xFF	; 255
     c30:	1d c0       	rjmp	.+58     	; 0xc6c <xTaskGenericCreate+0x1be>
     c32:	88 e8       	ldi	r24, 0x88	; 136
     c34:	96 e0       	ldi	r25, 0x06	; 6
     c36:	0e 94 14 01 	call	0x228	; 0x228 <vListInitialise>
     c3a:	8f e7       	ldi	r24, 0x7F	; 127
     c3c:	96 e0       	ldi	r25, 0x06	; 6
     c3e:	0e 94 14 01 	call	0x228	; 0x228 <vListInitialise>
     c42:	86 e7       	ldi	r24, 0x76	; 118
     c44:	96 e0       	ldi	r25, 0x06	; 6
     c46:	0e 94 14 01 	call	0x228	; 0x228 <vListInitialise>
     c4a:	89 e6       	ldi	r24, 0x69	; 105
     c4c:	96 e0       	ldi	r25, 0x06	; 6
     c4e:	0e 94 14 01 	call	0x228	; 0x228 <vListInitialise>
     c52:	8f e7       	ldi	r24, 0x7F	; 127
     c54:	96 e0       	ldi	r25, 0x06	; 6
     c56:	90 93 75 06 	sts	0x0675, r25	; 0x800675 <pxDelayedTaskList+0x1>
     c5a:	80 93 74 06 	sts	0x0674, r24	; 0x800674 <pxDelayedTaskList>
     c5e:	86 e7       	ldi	r24, 0x76	; 118
     c60:	96 e0       	ldi	r25, 0x06	; 6
     c62:	90 93 73 06 	sts	0x0673, r25	; 0x800673 <pxOverflowDelayedTaskList+0x1>
     c66:	80 93 72 06 	sts	0x0672, r24	; 0x800672 <pxOverflowDelayedTaskList>
     c6a:	a7 cf       	rjmp	.-178    	; 0xbba <xTaskGenericCreate+0x10c>
     c6c:	df 91       	pop	r29
     c6e:	cf 91       	pop	r28
     c70:	0f 91       	pop	r16
     c72:	ff 90       	pop	r15
     c74:	ef 90       	pop	r14
     c76:	df 90       	pop	r13
     c78:	cf 90       	pop	r12
     c7a:	bf 90       	pop	r11
     c7c:	af 90       	pop	r10
     c7e:	9f 90       	pop	r9
     c80:	8f 90       	pop	r8
     c82:	7f 90       	pop	r7
     c84:	6f 90       	pop	r6
     c86:	5f 90       	pop	r5
     c88:	4f 90       	pop	r4
     c8a:	08 95       	ret

00000c8c <vTaskStartScheduler>:
     c8c:	af 92       	push	r10
     c8e:	bf 92       	push	r11
     c90:	cf 92       	push	r12
     c92:	df 92       	push	r13
     c94:	ef 92       	push	r14
     c96:	ff 92       	push	r15
     c98:	0f 93       	push	r16
     c9a:	a1 2c       	mov	r10, r1
     c9c:	b1 2c       	mov	r11, r1
     c9e:	c1 2c       	mov	r12, r1
     ca0:	d1 2c       	mov	r13, r1
     ca2:	e1 2c       	mov	r14, r1
     ca4:	f1 2c       	mov	r15, r1
     ca6:	00 e0       	ldi	r16, 0x00	; 0
     ca8:	20 e0       	ldi	r18, 0x00	; 0
     caa:	30 e0       	ldi	r19, 0x00	; 0
     cac:	45 e5       	ldi	r20, 0x55	; 85
     cae:	50 e0       	ldi	r21, 0x00	; 0
     cb0:	69 e7       	ldi	r22, 0x79	; 121
     cb2:	70 e0       	ldi	r23, 0x00	; 0
     cb4:	88 e1       	ldi	r24, 0x18	; 24
     cb6:	95 e0       	ldi	r25, 0x05	; 5
     cb8:	0e 94 57 05 	call	0xaae	; 0xaae <xTaskGenericCreate>
     cbc:	81 30       	cpi	r24, 0x01	; 1
     cbe:	49 f4       	brne	.+18     	; 0xcd2 <vTaskStartScheduler+0x46>
     cc0:	f8 94       	cli
     cc2:	80 93 63 06 	sts	0x0663, r24	; 0x800663 <xSchedulerRunning>
     cc6:	10 92 67 06 	sts	0x0667, r1	; 0x800667 <xTickCount+0x1>
     cca:	10 92 66 06 	sts	0x0666, r1	; 0x800666 <xTickCount>
     cce:	0e 94 1a 02 	call	0x434	; 0x434 <xPortStartScheduler>
     cd2:	0f 91       	pop	r16
     cd4:	ff 90       	pop	r15
     cd6:	ef 90       	pop	r14
     cd8:	df 90       	pop	r13
     cda:	cf 90       	pop	r12
     cdc:	bf 90       	pop	r11
     cde:	af 90       	pop	r10
     ce0:	08 95       	ret

00000ce2 <vTaskSuspendAll>:
     ce2:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxSchedulerSuspended>
     ce6:	8f 5f       	subi	r24, 0xFF	; 255
     ce8:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <uxSchedulerSuspended>
     cec:	08 95       	ret

00000cee <xTaskGetTickCount>:
     cee:	0f b6       	in	r0, 0x3f	; 63
     cf0:	f8 94       	cli
     cf2:	0f 92       	push	r0
     cf4:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <xTickCount>
     cf8:	90 91 67 06 	lds	r25, 0x0667	; 0x800667 <xTickCount+0x1>
     cfc:	0f 90       	pop	r0
     cfe:	0f be       	out	0x3f, r0	; 63
     d00:	08 95       	ret

00000d02 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
     d02:	0f 93       	push	r16
     d04:	1f 93       	push	r17
     d06:	cf 93       	push	r28
     d08:	df 93       	push	r29
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     d0a:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxSchedulerSuspended>
     d0e:	81 11       	cpse	r24, r1
     d10:	b2 c0       	rjmp	.+356    	; 0xe76 <vTaskIncrementTick+0x174>
	{
		++xTickCount;
     d12:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <xTickCount>
     d16:	90 91 67 06 	lds	r25, 0x0667	; 0x800667 <xTickCount+0x1>
     d1a:	01 96       	adiw	r24, 0x01	; 1
     d1c:	90 93 67 06 	sts	0x0667, r25	; 0x800667 <xTickCount+0x1>
     d20:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <xTickCount>
		if( xTickCount == ( portTickType ) 0U )
     d24:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <xTickCount>
     d28:	90 91 67 06 	lds	r25, 0x0667	; 0x800667 <xTickCount+0x1>
     d2c:	89 2b       	or	r24, r25
     d2e:	99 f5       	brne	.+102    	; 0xd96 <vTaskIncrementTick+0x94>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
     d30:	80 91 74 06 	lds	r24, 0x0674	; 0x800674 <pxDelayedTaskList>
     d34:	90 91 75 06 	lds	r25, 0x0675	; 0x800675 <pxDelayedTaskList+0x1>
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     d38:	20 91 72 06 	lds	r18, 0x0672	; 0x800672 <pxOverflowDelayedTaskList>
     d3c:	30 91 73 06 	lds	r19, 0x0673	; 0x800673 <pxOverflowDelayedTaskList+0x1>
     d40:	30 93 75 06 	sts	0x0675, r19	; 0x800675 <pxDelayedTaskList+0x1>
     d44:	20 93 74 06 	sts	0x0674, r18	; 0x800674 <pxDelayedTaskList>
			pxOverflowDelayedTaskList = pxTemp;
     d48:	90 93 73 06 	sts	0x0673, r25	; 0x800673 <pxOverflowDelayedTaskList+0x1>
     d4c:	80 93 72 06 	sts	0x0672, r24	; 0x800672 <pxOverflowDelayedTaskList>
			xNumOfOverflows++;
     d50:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <xNumOfOverflows>
     d54:	8f 5f       	subi	r24, 0xFF	; 255
     d56:	80 93 5f 06 	sts	0x065F, r24	; 0x80065f <xNumOfOverflows>
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     d5a:	e0 91 74 06 	lds	r30, 0x0674	; 0x800674 <pxDelayedTaskList>
     d5e:	f0 91 75 06 	lds	r31, 0x0675	; 0x800675 <pxDelayedTaskList+0x1>
     d62:	80 81       	ld	r24, Z
     d64:	81 11       	cpse	r24, r1
     d66:	07 c0       	rjmp	.+14     	; 0xd76 <vTaskIncrementTick+0x74>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
     d68:	8f ef       	ldi	r24, 0xFF	; 255
     d6a:	9f ef       	ldi	r25, 0xFF	; 255
     d6c:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     d70:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     d74:	10 c0       	rjmp	.+32     	; 0xd96 <vTaskIncrementTick+0x94>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     d76:	e0 91 74 06 	lds	r30, 0x0674	; 0x800674 <pxDelayedTaskList>
     d7a:	f0 91 75 06 	lds	r31, 0x0675	; 0x800675 <pxDelayedTaskList+0x1>
     d7e:	05 80       	ldd	r0, Z+5	; 0x05
     d80:	f6 81       	ldd	r31, Z+6	; 0x06
     d82:	e0 2d       	mov	r30, r0
     d84:	06 80       	ldd	r0, Z+6	; 0x06
     d86:	f7 81       	ldd	r31, Z+7	; 0x07
     d88:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     d8a:	82 81       	ldd	r24, Z+2	; 0x02
     d8c:	93 81       	ldd	r25, Z+3	; 0x03
     d8e:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     d92:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     d96:	20 91 66 06 	lds	r18, 0x0666	; 0x800666 <xTickCount>
     d9a:	30 91 67 06 	lds	r19, 0x0667	; 0x800667 <xTickCount+0x1>
     d9e:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     da2:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
     da6:	28 17       	cp	r18, r24
     da8:	39 07       	cpc	r19, r25
     daa:	08 f4       	brcc	.+2      	; 0xdae <vTaskIncrementTick+0xac>
     dac:	69 c0       	rjmp	.+210    	; 0xe80 <vTaskIncrementTick+0x17e>
     dae:	e0 91 74 06 	lds	r30, 0x0674	; 0x800674 <pxDelayedTaskList>
     db2:	f0 91 75 06 	lds	r31, 0x0675	; 0x800675 <pxDelayedTaskList+0x1>
     db6:	80 81       	ld	r24, Z
     db8:	88 23       	and	r24, r24
     dba:	99 f0       	breq	.+38     	; 0xde2 <vTaskIncrementTick+0xe0>
     dbc:	e0 91 74 06 	lds	r30, 0x0674	; 0x800674 <pxDelayedTaskList>
     dc0:	f0 91 75 06 	lds	r31, 0x0675	; 0x800675 <pxDelayedTaskList+0x1>
     dc4:	05 80       	ldd	r0, Z+5	; 0x05
     dc6:	f6 81       	ldd	r31, Z+6	; 0x06
     dc8:	e0 2d       	mov	r30, r0
     dca:	c6 81       	ldd	r28, Z+6	; 0x06
     dcc:	d7 81       	ldd	r29, Z+7	; 0x07
     dce:	8a 81       	ldd	r24, Y+2	; 0x02
     dd0:	9b 81       	ldd	r25, Y+3	; 0x03
     dd2:	20 91 66 06 	lds	r18, 0x0666	; 0x800666 <xTickCount>
     dd6:	30 91 67 06 	lds	r19, 0x0667	; 0x800667 <xTickCount+0x1>
     dda:	28 17       	cp	r18, r24
     ddc:	39 07       	cpc	r19, r25
     dde:	f8 f4       	brcc	.+62     	; 0xe1e <vTaskIncrementTick+0x11c>
     de0:	19 c0       	rjmp	.+50     	; 0xe14 <vTaskIncrementTick+0x112>
     de2:	8f ef       	ldi	r24, 0xFF	; 255
     de4:	9f ef       	ldi	r25, 0xFF	; 255
     de6:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     dea:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     dee:	48 c0       	rjmp	.+144    	; 0xe80 <vTaskIncrementTick+0x17e>
     df0:	e0 91 74 06 	lds	r30, 0x0674	; 0x800674 <pxDelayedTaskList>
     df4:	f0 91 75 06 	lds	r31, 0x0675	; 0x800675 <pxDelayedTaskList+0x1>
     df8:	05 80       	ldd	r0, Z+5	; 0x05
     dfa:	f6 81       	ldd	r31, Z+6	; 0x06
     dfc:	e0 2d       	mov	r30, r0
     dfe:	c6 81       	ldd	r28, Z+6	; 0x06
     e00:	d7 81       	ldd	r29, Z+7	; 0x07
     e02:	8a 81       	ldd	r24, Y+2	; 0x02
     e04:	9b 81       	ldd	r25, Y+3	; 0x03
     e06:	20 91 66 06 	lds	r18, 0x0666	; 0x800666 <xTickCount>
     e0a:	30 91 67 06 	lds	r19, 0x0667	; 0x800667 <xTickCount+0x1>
     e0e:	28 17       	cp	r18, r24
     e10:	39 07       	cpc	r19, r25
     e12:	28 f4       	brcc	.+10     	; 0xe1e <vTaskIncrementTick+0x11c>
     e14:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
     e18:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
     e1c:	31 c0       	rjmp	.+98     	; 0xe80 <vTaskIncrementTick+0x17e>
     e1e:	8e 01       	movw	r16, r28
     e20:	0e 5f       	subi	r16, 0xFE	; 254
     e22:	1f 4f       	sbci	r17, 0xFF	; 255
     e24:	c8 01       	movw	r24, r16
     e26:	0e 94 88 01 	call	0x310	; 0x310 <vListRemove>
     e2a:	8c 89       	ldd	r24, Y+20	; 0x14
     e2c:	9d 89       	ldd	r25, Y+21	; 0x15
     e2e:	89 2b       	or	r24, r25
     e30:	21 f0       	breq	.+8      	; 0xe3a <vTaskIncrementTick+0x138>
     e32:	ce 01       	movw	r24, r28
     e34:	0c 96       	adiw	r24, 0x0c	; 12
     e36:	0e 94 88 01 	call	0x310	; 0x310 <vListRemove>
     e3a:	2e 89       	ldd	r18, Y+22	; 0x16
     e3c:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <uxTopReadyPriority>
     e40:	82 17       	cp	r24, r18
     e42:	10 f4       	brcc	.+4      	; 0xe48 <vTaskIncrementTick+0x146>
     e44:	20 93 64 06 	sts	0x0664, r18	; 0x800664 <uxTopReadyPriority>
     e48:	30 e0       	ldi	r19, 0x00	; 0
     e4a:	c9 01       	movw	r24, r18
     e4c:	88 0f       	add	r24, r24
     e4e:	99 1f       	adc	r25, r25
     e50:	88 0f       	add	r24, r24
     e52:	99 1f       	adc	r25, r25
     e54:	88 0f       	add	r24, r24
     e56:	99 1f       	adc	r25, r25
     e58:	82 0f       	add	r24, r18
     e5a:	93 1f       	adc	r25, r19
     e5c:	b8 01       	movw	r22, r16
     e5e:	88 57       	subi	r24, 0x78	; 120
     e60:	99 4f       	sbci	r25, 0xF9	; 249
     e62:	0e 94 26 01 	call	0x24c	; 0x24c <vListInsertEnd>
     e66:	e0 91 74 06 	lds	r30, 0x0674	; 0x800674 <pxDelayedTaskList>
     e6a:	f0 91 75 06 	lds	r31, 0x0675	; 0x800675 <pxDelayedTaskList+0x1>
     e6e:	80 81       	ld	r24, Z
     e70:	81 11       	cpse	r24, r1
     e72:	be cf       	rjmp	.-132    	; 0xdf0 <vTaskIncrementTick+0xee>
     e74:	b6 cf       	rjmp	.-148    	; 0xde2 <vTaskIncrementTick+0xe0>
	}
	else
	{
		++uxMissedTicks;
     e76:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <uxMissedTicks>
     e7a:	8f 5f       	subi	r24, 0xFF	; 255
     e7c:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <uxMissedTicks>
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
     e80:	df 91       	pop	r29
     e82:	cf 91       	pop	r28
     e84:	1f 91       	pop	r17
     e86:	0f 91       	pop	r16
     e88:	08 95       	ret

00000e8a <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
     e8a:	cf 92       	push	r12
     e8c:	df 92       	push	r13
     e8e:	ef 92       	push	r14
     e90:	ff 92       	push	r15
     e92:	0f 93       	push	r16
     e94:	1f 93       	push	r17
     e96:	cf 93       	push	r28
     e98:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     e9a:	0f b6       	in	r0, 0x3f	; 63
     e9c:	f8 94       	cli
     e9e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     ea0:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxSchedulerSuspended>
     ea4:	81 50       	subi	r24, 0x01	; 1
     ea6:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     eaa:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxSchedulerSuspended>
     eae:	81 11       	cpse	r24, r1
     eb0:	64 c0       	rjmp	.+200    	; 0xf7a <xTaskResumeAll+0xf0>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
     eb2:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <uxCurrentNumberOfTasks>
     eb6:	81 11       	cpse	r24, r1
     eb8:	32 c0       	rjmp	.+100    	; 0xf1e <xTaskResumeAll+0x94>
     eba:	62 c0       	rjmp	.+196    	; 0xf80 <xTaskResumeAll+0xf6>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
     ebc:	d7 01       	movw	r26, r14
     ebe:	15 96       	adiw	r26, 0x05	; 5
     ec0:	ed 91       	ld	r30, X+
     ec2:	fc 91       	ld	r31, X
     ec4:	16 97       	sbiw	r26, 0x06	; 6
     ec6:	c6 81       	ldd	r28, Z+6	; 0x06
     ec8:	d7 81       	ldd	r29, Z+7	; 0x07
					vListRemove( &( pxTCB->xEventListItem ) );
     eca:	ce 01       	movw	r24, r28
     ecc:	0c 96       	adiw	r24, 0x0c	; 12
     ece:	0e 94 88 01 	call	0x310	; 0x310 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
     ed2:	8e 01       	movw	r16, r28
     ed4:	0e 5f       	subi	r16, 0xFE	; 254
     ed6:	1f 4f       	sbci	r17, 0xFF	; 255
     ed8:	c8 01       	movw	r24, r16
     eda:	0e 94 88 01 	call	0x310	; 0x310 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     ede:	2e 89       	ldd	r18, Y+22	; 0x16
     ee0:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <uxTopReadyPriority>
     ee4:	82 17       	cp	r24, r18
     ee6:	10 f4       	brcc	.+4      	; 0xeec <xTaskResumeAll+0x62>
     ee8:	20 93 64 06 	sts	0x0664, r18	; 0x800664 <uxTopReadyPriority>
     eec:	30 e0       	ldi	r19, 0x00	; 0
     eee:	c9 01       	movw	r24, r18
     ef0:	88 0f       	add	r24, r24
     ef2:	99 1f       	adc	r25, r25
     ef4:	88 0f       	add	r24, r24
     ef6:	99 1f       	adc	r25, r25
     ef8:	88 0f       	add	r24, r24
     efa:	99 1f       	adc	r25, r25
     efc:	82 0f       	add	r24, r18
     efe:	93 1f       	adc	r25, r19
     f00:	b8 01       	movw	r22, r16
     f02:	88 57       	subi	r24, 0x78	; 120
     f04:	99 4f       	sbci	r25, 0xF9	; 249
     f06:	0e 94 26 01 	call	0x24c	; 0x24c <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     f0a:	e0 91 91 06 	lds	r30, 0x0691	; 0x800691 <pxCurrentTCB>
     f0e:	f0 91 92 06 	lds	r31, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
     f12:	9e 89       	ldd	r25, Y+22	; 0x16
     f14:	86 89       	ldd	r24, Z+22	; 0x16
     f16:	98 17       	cp	r25, r24
     f18:	58 f0       	brcs	.+22     	; 0xf30 <xTaskResumeAll+0xa6>
					{
						xYieldRequired = pdTRUE;
     f1a:	dc 2c       	mov	r13, r12
     f1c:	09 c0       	rjmp	.+18     	; 0xf30 <xTaskResumeAll+0xa6>
     f1e:	d1 2c       	mov	r13, r1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     f20:	0f 2e       	mov	r0, r31
     f22:	f9 e6       	ldi	r31, 0x69	; 105
     f24:	ef 2e       	mov	r14, r31
     f26:	f6 e0       	ldi	r31, 0x06	; 6
     f28:	ff 2e       	mov	r15, r31
     f2a:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
     f2c:	cc 24       	eor	r12, r12
     f2e:	c3 94       	inc	r12
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     f30:	f7 01       	movw	r30, r14
     f32:	80 81       	ld	r24, Z
     f34:	81 11       	cpse	r24, r1
     f36:	c2 cf       	rjmp	.-124    	; 0xebc <xTaskResumeAll+0x32>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     f38:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <uxMissedTicks>
     f3c:	88 23       	and	r24, r24
     f3e:	81 f0       	breq	.+32     	; 0xf60 <xTaskResumeAll+0xd6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     f40:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <uxMissedTicks>
     f44:	88 23       	and	r24, r24
     f46:	99 f0       	breq	.+38     	; 0xf6e <xTaskResumeAll+0xe4>
					{
						vTaskIncrementTick();
     f48:	0e 94 81 06 	call	0xd02	; 0xd02 <vTaskIncrementTick>
						--uxMissedTicks;
     f4c:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <uxMissedTicks>
     f50:	81 50       	subi	r24, 0x01	; 1
     f52:	80 93 61 06 	sts	0x0661, r24	; 0x800661 <uxMissedTicks>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     f56:	80 91 61 06 	lds	r24, 0x0661	; 0x800661 <uxMissedTicks>
     f5a:	81 11       	cpse	r24, r1
     f5c:	f5 cf       	rjmp	.-22     	; 0xf48 <xTaskResumeAll+0xbe>
     f5e:	07 c0       	rjmp	.+14     	; 0xf6e <xTaskResumeAll+0xe4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
     f60:	f1 e0       	ldi	r31, 0x01	; 1
     f62:	df 16       	cp	r13, r31
     f64:	21 f0       	breq	.+8      	; 0xf6e <xTaskResumeAll+0xe4>
     f66:	80 91 60 06 	lds	r24, 0x0660	; 0x800660 <xMissedYield>
     f6a:	81 30       	cpi	r24, 0x01	; 1
     f6c:	41 f4       	brne	.+16     	; 0xf7e <xTaskResumeAll+0xf4>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
     f6e:	10 92 60 06 	sts	0x0660, r1	; 0x800660 <xMissedYield>
					portYIELD_WITHIN_API();
     f72:	0e 94 4f 02 	call	0x49e	; 0x49e <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
     f76:	81 e0       	ldi	r24, 0x01	; 1
     f78:	03 c0       	rjmp	.+6      	; 0xf80 <xTaskResumeAll+0xf6>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
     f7a:	80 e0       	ldi	r24, 0x00	; 0
     f7c:	01 c0       	rjmp	.+2      	; 0xf80 <xTaskResumeAll+0xf6>
     f7e:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
     f80:	0f 90       	pop	r0
     f82:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     f84:	df 91       	pop	r29
     f86:	cf 91       	pop	r28
     f88:	1f 91       	pop	r17
     f8a:	0f 91       	pop	r16
     f8c:	ff 90       	pop	r15
     f8e:	ef 90       	pop	r14
     f90:	df 90       	pop	r13
     f92:	cf 90       	pop	r12
     f94:	08 95       	ret

00000f96 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
     f96:	0f 93       	push	r16
     f98:	1f 93       	push	r17
     f9a:	cf 93       	push	r28
     f9c:	df 93       	push	r29
     f9e:	8c 01       	movw	r16, r24
     fa0:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
     fa2:	0e 94 71 06 	call	0xce2	; 0xce2 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     fa6:	f8 01       	movw	r30, r16
     fa8:	20 81       	ld	r18, Z
     faa:	31 81       	ldd	r19, Z+1	; 0x01
     fac:	c2 0f       	add	r28, r18
     fae:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
     fb0:	40 91 66 06 	lds	r20, 0x0666	; 0x800666 <xTickCount>
     fb4:	50 91 67 06 	lds	r21, 0x0667	; 0x800667 <xTickCount+0x1>
     fb8:	42 17       	cp	r20, r18
     fba:	53 07       	cpc	r21, r19
     fbc:	68 f4       	brcc	.+26     	; 0xfd8 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
     fbe:	c2 17       	cp	r28, r18
     fc0:	d3 07       	cpc	r29, r19
     fc2:	50 f5       	brcc	.+84     	; 0x1018 <vTaskDelayUntil+0x82>
     fc4:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <xTickCount>
     fc8:	90 91 67 06 	lds	r25, 0x0667	; 0x800667 <xTickCount+0x1>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     fcc:	d1 83       	std	Z+1, r29	; 0x01
     fce:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
     fd0:	8c 17       	cp	r24, r28
     fd2:	9d 07       	cpc	r25, r29
     fd4:	b0 f4       	brcc	.+44     	; 0x1002 <vTaskDelayUntil+0x6c>
     fd6:	0b c0       	rjmp	.+22     	; 0xfee <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
     fd8:	c2 17       	cp	r28, r18
     fda:	d3 07       	cpc	r29, r19
     fdc:	c8 f0       	brcs	.+50     	; 0x1010 <vTaskDelayUntil+0x7a>
     fde:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <xTickCount>
     fe2:	90 91 67 06 	lds	r25, 0x0667	; 0x800667 <xTickCount+0x1>
     fe6:	8c 17       	cp	r24, r28
     fe8:	9d 07       	cpc	r25, r29
     fea:	90 f0       	brcs	.+36     	; 0x1010 <vTaskDelayUntil+0x7a>
     fec:	15 c0       	rjmp	.+42     	; 0x1018 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     fee:	80 91 91 06 	lds	r24, 0x0691	; 0x800691 <pxCurrentTCB>
     ff2:	90 91 92 06 	lds	r25, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
     ff6:	02 96       	adiw	r24, 0x02	; 2
     ff8:	0e 94 88 01 	call	0x310	; 0x310 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     ffc:	ce 01       	movw	r24, r28
     ffe:	0e 94 20 05 	call	0xa40	; 0xa40 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    1002:	0e 94 45 07 	call	0xe8a	; 0xe8a <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1006:	81 11       	cpse	r24, r1
    1008:	0b c0       	rjmp	.+22     	; 0x1020 <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    100a:	0e 94 4f 02 	call	0x49e	; 0x49e <vPortYield>
    100e:	08 c0       	rjmp	.+16     	; 0x1020 <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1010:	f8 01       	movw	r30, r16
    1012:	d1 83       	std	Z+1, r29	; 0x01
    1014:	c0 83       	st	Z, r28
    1016:	eb cf       	rjmp	.-42     	; 0xfee <vTaskDelayUntil+0x58>
    1018:	f8 01       	movw	r30, r16
    101a:	d1 83       	std	Z+1, r29	; 0x01
    101c:	c0 83       	st	Z, r28
    101e:	f1 cf       	rjmp	.-30     	; 0x1002 <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    1020:	df 91       	pop	r29
    1022:	cf 91       	pop	r28
    1024:	1f 91       	pop	r17
    1026:	0f 91       	pop	r16
    1028:	08 95       	ret

0000102a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    102a:	cf 93       	push	r28
    102c:	df 93       	push	r29
    102e:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1030:	89 2b       	or	r24, r25
    1032:	b1 f0       	breq	.+44     	; 0x1060 <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    1034:	0e 94 71 06 	call	0xce2	; 0xce2 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1038:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <xTickCount>
    103c:	90 91 67 06 	lds	r25, 0x0667	; 0x800667 <xTickCount+0x1>
    1040:	c8 0f       	add	r28, r24
    1042:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1044:	80 91 91 06 	lds	r24, 0x0691	; 0x800691 <pxCurrentTCB>
    1048:	90 91 92 06 	lds	r25, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
    104c:	02 96       	adiw	r24, 0x02	; 2
    104e:	0e 94 88 01 	call	0x310	; 0x310 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1052:	ce 01       	movw	r24, r28
    1054:	0e 94 20 05 	call	0xa40	; 0xa40 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1058:	0e 94 45 07 	call	0xe8a	; 0xe8a <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    105c:	81 11       	cpse	r24, r1
    105e:	02 c0       	rjmp	.+4      	; 0x1064 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    1060:	0e 94 4f 02 	call	0x49e	; 0x49e <vPortYield>
		}
	}
    1064:	df 91       	pop	r29
    1066:	cf 91       	pop	r28
    1068:	08 95       	ret

0000106a <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    106a:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxSchedulerSuspended>
    106e:	81 11       	cpse	r24, r1
    1070:	13 c0       	rjmp	.+38     	; 0x1098 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1072:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <uxTopReadyPriority>
    1076:	90 e0       	ldi	r25, 0x00	; 0
    1078:	fc 01       	movw	r30, r24
    107a:	ee 0f       	add	r30, r30
    107c:	ff 1f       	adc	r31, r31
    107e:	ee 0f       	add	r30, r30
    1080:	ff 1f       	adc	r31, r31
    1082:	ee 0f       	add	r30, r30
    1084:	ff 1f       	adc	r31, r31
    1086:	8e 0f       	add	r24, r30
    1088:	9f 1f       	adc	r25, r31
    108a:	fc 01       	movw	r30, r24
    108c:	e8 57       	subi	r30, 0x78	; 120
    108e:	f9 4f       	sbci	r31, 0xF9	; 249
    1090:	80 81       	ld	r24, Z
    1092:	88 23       	and	r24, r24
    1094:	29 f0       	breq	.+10     	; 0x10a0 <vTaskSwitchContext+0x36>
    1096:	1b c0       	rjmp	.+54     	; 0x10ce <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1098:	81 e0       	ldi	r24, 0x01	; 1
    109a:	80 93 60 06 	sts	0x0660, r24	; 0x800660 <xMissedYield>
    109e:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    10a0:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <uxTopReadyPriority>
    10a4:	81 50       	subi	r24, 0x01	; 1
    10a6:	80 93 64 06 	sts	0x0664, r24	; 0x800664 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    10aa:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <uxTopReadyPriority>
    10ae:	90 e0       	ldi	r25, 0x00	; 0
    10b0:	fc 01       	movw	r30, r24
    10b2:	ee 0f       	add	r30, r30
    10b4:	ff 1f       	adc	r31, r31
    10b6:	ee 0f       	add	r30, r30
    10b8:	ff 1f       	adc	r31, r31
    10ba:	ee 0f       	add	r30, r30
    10bc:	ff 1f       	adc	r31, r31
    10be:	8e 0f       	add	r24, r30
    10c0:	9f 1f       	adc	r25, r31
    10c2:	fc 01       	movw	r30, r24
    10c4:	e8 57       	subi	r30, 0x78	; 120
    10c6:	f9 4f       	sbci	r31, 0xF9	; 249
    10c8:	80 81       	ld	r24, Z
    10ca:	88 23       	and	r24, r24
    10cc:	49 f3       	breq	.-46     	; 0x10a0 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    10ce:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <uxTopReadyPriority>
    10d2:	90 e0       	ldi	r25, 0x00	; 0
    10d4:	9c 01       	movw	r18, r24
    10d6:	22 0f       	add	r18, r18
    10d8:	33 1f       	adc	r19, r19
    10da:	22 0f       	add	r18, r18
    10dc:	33 1f       	adc	r19, r19
    10de:	22 0f       	add	r18, r18
    10e0:	33 1f       	adc	r19, r19
    10e2:	28 0f       	add	r18, r24
    10e4:	39 1f       	adc	r19, r25
    10e6:	d9 01       	movw	r26, r18
    10e8:	a8 57       	subi	r26, 0x78	; 120
    10ea:	b9 4f       	sbci	r27, 0xF9	; 249
    10ec:	11 96       	adiw	r26, 0x01	; 1
    10ee:	ed 91       	ld	r30, X+
    10f0:	fc 91       	ld	r31, X
    10f2:	12 97       	sbiw	r26, 0x02	; 2
    10f4:	02 80       	ldd	r0, Z+2	; 0x02
    10f6:	f3 81       	ldd	r31, Z+3	; 0x03
    10f8:	e0 2d       	mov	r30, r0
    10fa:	12 96       	adiw	r26, 0x02	; 2
    10fc:	fc 93       	st	X, r31
    10fe:	ee 93       	st	-X, r30
    1100:	11 97       	sbiw	r26, 0x01	; 1
    1102:	25 57       	subi	r18, 0x75	; 117
    1104:	39 4f       	sbci	r19, 0xF9	; 249
    1106:	e2 17       	cp	r30, r18
    1108:	f3 07       	cpc	r31, r19
    110a:	29 f4       	brne	.+10     	; 0x1116 <vTaskSwitchContext+0xac>
    110c:	22 81       	ldd	r18, Z+2	; 0x02
    110e:	33 81       	ldd	r19, Z+3	; 0x03
    1110:	fd 01       	movw	r30, r26
    1112:	32 83       	std	Z+2, r19	; 0x02
    1114:	21 83       	std	Z+1, r18	; 0x01
    1116:	fc 01       	movw	r30, r24
    1118:	ee 0f       	add	r30, r30
    111a:	ff 1f       	adc	r31, r31
    111c:	ee 0f       	add	r30, r30
    111e:	ff 1f       	adc	r31, r31
    1120:	ee 0f       	add	r30, r30
    1122:	ff 1f       	adc	r31, r31
    1124:	8e 0f       	add	r24, r30
    1126:	9f 1f       	adc	r25, r31
    1128:	fc 01       	movw	r30, r24
    112a:	e8 57       	subi	r30, 0x78	; 120
    112c:	f9 4f       	sbci	r31, 0xF9	; 249
    112e:	01 80       	ldd	r0, Z+1	; 0x01
    1130:	f2 81       	ldd	r31, Z+2	; 0x02
    1132:	e0 2d       	mov	r30, r0
    1134:	86 81       	ldd	r24, Z+6	; 0x06
    1136:	97 81       	ldd	r25, Z+7	; 0x07
    1138:	90 93 92 06 	sts	0x0692, r25	; 0x800692 <pxCurrentTCB+0x1>
    113c:	80 93 91 06 	sts	0x0691, r24	; 0x800691 <pxCurrentTCB>
    1140:	08 95       	ret

00001142 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    1142:	cf 93       	push	r28
    1144:	df 93       	push	r29
    1146:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    1148:	20 91 91 06 	lds	r18, 0x0691	; 0x800691 <pxCurrentTCB>
    114c:	30 91 92 06 	lds	r19, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
    1150:	b9 01       	movw	r22, r18
    1152:	64 5f       	subi	r22, 0xF4	; 244
    1154:	7f 4f       	sbci	r23, 0xFF	; 255
    1156:	0e 94 4d 01 	call	0x29a	; 0x29a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    115a:	80 91 91 06 	lds	r24, 0x0691	; 0x800691 <pxCurrentTCB>
    115e:	90 91 92 06 	lds	r25, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
    1162:	02 96       	adiw	r24, 0x02	; 2
    1164:	0e 94 88 01 	call	0x310	; 0x310 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1168:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <xTickCount>
    116c:	90 91 67 06 	lds	r25, 0x0667	; 0x800667 <xTickCount+0x1>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1170:	8c 0f       	add	r24, r28
    1172:	9d 1f       	adc	r25, r29
    1174:	0e 94 20 05 	call	0xa40	; 0xa40 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    1178:	df 91       	pop	r29
    117a:	cf 91       	pop	r28
    117c:	08 95       	ret

0000117e <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    117e:	0f 93       	push	r16
    1180:	1f 93       	push	r17
    1182:	cf 93       	push	r28
    1184:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1186:	dc 01       	movw	r26, r24
    1188:	15 96       	adiw	r26, 0x05	; 5
    118a:	ed 91       	ld	r30, X+
    118c:	fc 91       	ld	r31, X
    118e:	16 97       	sbiw	r26, 0x06	; 6
    1190:	c6 81       	ldd	r28, Z+6	; 0x06
    1192:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1194:	8e 01       	movw	r16, r28
    1196:	04 5f       	subi	r16, 0xF4	; 244
    1198:	1f 4f       	sbci	r17, 0xFF	; 255
    119a:	c8 01       	movw	r24, r16
    119c:	0e 94 88 01 	call	0x310	; 0x310 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    11a0:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <uxSchedulerSuspended>
    11a4:	81 11       	cpse	r24, r1
    11a6:	1c c0       	rjmp	.+56     	; 0x11e0 <xTaskRemoveFromEventList+0x62>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    11a8:	0a 50       	subi	r16, 0x0A	; 10
    11aa:	11 09       	sbc	r17, r1
    11ac:	c8 01       	movw	r24, r16
    11ae:	0e 94 88 01 	call	0x310	; 0x310 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    11b2:	2e 89       	ldd	r18, Y+22	; 0x16
    11b4:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <uxTopReadyPriority>
    11b8:	82 17       	cp	r24, r18
    11ba:	10 f4       	brcc	.+4      	; 0x11c0 <xTaskRemoveFromEventList+0x42>
    11bc:	20 93 64 06 	sts	0x0664, r18	; 0x800664 <uxTopReadyPriority>
    11c0:	30 e0       	ldi	r19, 0x00	; 0
    11c2:	c9 01       	movw	r24, r18
    11c4:	88 0f       	add	r24, r24
    11c6:	99 1f       	adc	r25, r25
    11c8:	88 0f       	add	r24, r24
    11ca:	99 1f       	adc	r25, r25
    11cc:	88 0f       	add	r24, r24
    11ce:	99 1f       	adc	r25, r25
    11d0:	82 0f       	add	r24, r18
    11d2:	93 1f       	adc	r25, r19
    11d4:	b8 01       	movw	r22, r16
    11d6:	88 57       	subi	r24, 0x78	; 120
    11d8:	99 4f       	sbci	r25, 0xF9	; 249
    11da:	0e 94 26 01 	call	0x24c	; 0x24c <vListInsertEnd>
    11de:	05 c0       	rjmp	.+10     	; 0x11ea <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    11e0:	b8 01       	movw	r22, r16
    11e2:	89 e6       	ldi	r24, 0x69	; 105
    11e4:	96 e0       	ldi	r25, 0x06	; 6
    11e6:	0e 94 26 01 	call	0x24c	; 0x24c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    11ea:	e0 91 91 06 	lds	r30, 0x0691	; 0x800691 <pxCurrentTCB>
    11ee:	f0 91 92 06 	lds	r31, 0x0692	; 0x800692 <pxCurrentTCB+0x1>
    11f2:	81 e0       	ldi	r24, 0x01	; 1
    11f4:	2e 89       	ldd	r18, Y+22	; 0x16
    11f6:	96 89       	ldd	r25, Z+22	; 0x16
    11f8:	29 17       	cp	r18, r25
    11fa:	08 f4       	brcc	.+2      	; 0x11fe <xTaskRemoveFromEventList+0x80>
    11fc:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    11fe:	df 91       	pop	r29
    1200:	cf 91       	pop	r28
    1202:	1f 91       	pop	r17
    1204:	0f 91       	pop	r16
    1206:	08 95       	ret

00001208 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1208:	20 91 5f 06 	lds	r18, 0x065F	; 0x80065f <xNumOfOverflows>
    120c:	fc 01       	movw	r30, r24
    120e:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1210:	20 91 66 06 	lds	r18, 0x0666	; 0x800666 <xTickCount>
    1214:	30 91 67 06 	lds	r19, 0x0667	; 0x800667 <xTickCount+0x1>
    1218:	32 83       	std	Z+2, r19	; 0x02
    121a:	21 83       	std	Z+1, r18	; 0x01
    121c:	08 95       	ret

0000121e <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    121e:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1220:	0f b6       	in	r0, 0x3f	; 63
    1222:	f8 94       	cli
    1224:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    1226:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <xNumOfOverflows>
    122a:	90 81       	ld	r25, Z
    122c:	98 17       	cp	r25, r24
    122e:	49 f0       	breq	.+18     	; 0x1242 <xTaskCheckForTimeOut+0x24>
    1230:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <xTickCount>
    1234:	90 91 67 06 	lds	r25, 0x0667	; 0x800667 <xTickCount+0x1>
    1238:	21 81       	ldd	r18, Z+1	; 0x01
    123a:	32 81       	ldd	r19, Z+2	; 0x02
    123c:	82 17       	cp	r24, r18
    123e:	93 07       	cpc	r25, r19
    1240:	f8 f4       	brcc	.+62     	; 0x1280 <xTaskCheckForTimeOut+0x62>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    1242:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <xTickCount>
    1246:	90 91 67 06 	lds	r25, 0x0667	; 0x800667 <xTickCount+0x1>
    124a:	41 81       	ldd	r20, Z+1	; 0x01
    124c:	52 81       	ldd	r21, Z+2	; 0x02
    124e:	db 01       	movw	r26, r22
    1250:	2d 91       	ld	r18, X+
    1252:	3c 91       	ld	r19, X
    1254:	11 97       	sbiw	r26, 0x01	; 1
    1256:	84 1b       	sub	r24, r20
    1258:	95 0b       	sbc	r25, r21
    125a:	82 17       	cp	r24, r18
    125c:	93 07       	cpc	r25, r19
    125e:	90 f4       	brcc	.+36     	; 0x1284 <xTaskCheckForTimeOut+0x66>
    1260:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    1262:	e0 91 66 06 	lds	r30, 0x0666	; 0x800666 <xTickCount>
    1266:	f0 91 67 06 	lds	r31, 0x0667	; 0x800667 <xTickCount+0x1>
    126a:	bf 01       	movw	r22, r30
    126c:	64 1b       	sub	r22, r20
    126e:	75 0b       	sbc	r23, r21
    1270:	26 1b       	sub	r18, r22
    1272:	37 0b       	sbc	r19, r23
    1274:	2d 93       	st	X+, r18
    1276:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1278:	0e 94 04 09 	call	0x1208	; 0x1208 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    127c:	80 e0       	ldi	r24, 0x00	; 0
    127e:	03 c0       	rjmp	.+6      	; 0x1286 <xTaskCheckForTimeOut+0x68>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1280:	81 e0       	ldi	r24, 0x01	; 1
    1282:	01 c0       	rjmp	.+2      	; 0x1286 <xTaskCheckForTimeOut+0x68>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1284:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1286:	0f 90       	pop	r0
    1288:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    128a:	08 95       	ret

0000128c <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    128c:	81 e0       	ldi	r24, 0x01	; 1
    128e:	80 93 60 06 	sts	0x0660, r24	; 0x800660 <xMissedYield>
    1292:	08 95       	ret

00001294 <memcpy>:
    1294:	fb 01       	movw	r30, r22
    1296:	dc 01       	movw	r26, r24
    1298:	02 c0       	rjmp	.+4      	; 0x129e <memcpy+0xa>
    129a:	01 90       	ld	r0, Z+
    129c:	0d 92       	st	X+, r0
    129e:	41 50       	subi	r20, 0x01	; 1
    12a0:	50 40       	sbci	r21, 0x00	; 0
    12a2:	d8 f7       	brcc	.-10     	; 0x129a <memcpy+0x6>
    12a4:	08 95       	ret

000012a6 <memset>:
    12a6:	dc 01       	movw	r26, r24
    12a8:	01 c0       	rjmp	.+2      	; 0x12ac <memset+0x6>
    12aa:	6d 93       	st	X+, r22
    12ac:	41 50       	subi	r20, 0x01	; 1
    12ae:	50 40       	sbci	r21, 0x00	; 0
    12b0:	e0 f7       	brcc	.-8      	; 0x12aa <memset+0x4>
    12b2:	08 95       	ret

000012b4 <strncpy>:
    12b4:	fb 01       	movw	r30, r22
    12b6:	dc 01       	movw	r26, r24
    12b8:	41 50       	subi	r20, 0x01	; 1
    12ba:	50 40       	sbci	r21, 0x00	; 0
    12bc:	48 f0       	brcs	.+18     	; 0x12d0 <strncpy+0x1c>
    12be:	01 90       	ld	r0, Z+
    12c0:	0d 92       	st	X+, r0
    12c2:	00 20       	and	r0, r0
    12c4:	c9 f7       	brne	.-14     	; 0x12b8 <strncpy+0x4>
    12c6:	01 c0       	rjmp	.+2      	; 0x12ca <strncpy+0x16>
    12c8:	1d 92       	st	X+, r1
    12ca:	41 50       	subi	r20, 0x01	; 1
    12cc:	50 40       	sbci	r21, 0x00	; 0
    12ce:	e0 f7       	brcc	.-8      	; 0x12c8 <strncpy+0x14>
    12d0:	08 95       	ret

000012d2 <_exit>:
    12d2:	f8 94       	cli

000012d4 <__stop_program>:
    12d4:	ff cf       	rjmp	.-2      	; 0x12d4 <__stop_program>
