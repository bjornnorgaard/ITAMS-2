
RTOS_HH.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c78  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000012  00800060  00000c78  00000d0c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000613  00800072  00800072  00000d1e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d1e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000d50  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001e0  00000000  00000000  00000d8c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002036  00000000  00000000  00000f6c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d82  00000000  00000000  00002fa2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000010cc  00000000  00000000  00003d24  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000454  00000000  00000000  00004df0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000b82  00000000  00000000  00005244  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001245  00000000  00000000  00005dc6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001c8  00000000  00000000  0000700b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 91 02 	jmp	0x522	; 0x522 <__vector_7>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e8 e7       	ldi	r30, 0x78	; 120
  68:	fc e0       	ldi	r31, 0x0C	; 12
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a2 37       	cpi	r26, 0x72	; 114
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	26 e0       	ldi	r18, 0x06	; 6
  78:	a2 e7       	ldi	r26, 0x72	; 114
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a5 38       	cpi	r26, 0x85	; 133
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 82 00 	call	0x104	; 0x104 <main>
  8a:	0c 94 3a 06 	jmp	0xc74	; 0xc74 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <initLEDport>:
  if (led_nr <= MAX_LED_NR)
  {
    // Create mask based on the parameter (led_nr)
    mask = 0b00000001 << led_nr;
    // Turn OFF the actual LED (the rest are unchanged)
    PORTC = PORTC | mask;
  92:	8f ef       	ldi	r24, 0xFF	; 255
  94:	84 bb       	out	0x14, r24	; 20
  96:	85 bb       	out	0x15, r24	; 21
  98:	08 95       	ret

0000009a <toggleLED>:
void toggleLED(unsigned char led_nr)
{
// Local variable
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
  9a:	88 30       	cpi	r24, 0x08	; 8
  9c:	60 f4       	brcc	.+24     	; 0xb6 <toggleLED+0x1c>
  {
    // Create mask based on the parameter (led_nr)
    mask = 0b00000001 << led_nr;
    // Toggle the actual LED (the rest are unchanged)
    PORTC = PORTC ^ mask;
  9e:	45 b3       	in	r20, 0x15	; 21
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
  {
    // Create mask based on the parameter (led_nr)
    mask = 0b00000001 << led_nr;
  a0:	21 e0       	ldi	r18, 0x01	; 1
  a2:	30 e0       	ldi	r19, 0x00	; 0
  a4:	b9 01       	movw	r22, r18
  a6:	02 c0       	rjmp	.+4      	; 0xac <toggleLED+0x12>
  a8:	66 0f       	add	r22, r22
  aa:	77 1f       	adc	r23, r23
  ac:	8a 95       	dec	r24
  ae:	e2 f7       	brpl	.-8      	; 0xa8 <toggleLED+0xe>
  b0:	cb 01       	movw	r24, r22
    // Toggle the actual LED (the rest are unchanged)
    PORTC = PORTC ^ mask;
  b2:	84 27       	eor	r24, r20
  b4:	85 bb       	out	0x15, r24	; 21
  b6:	08 95       	ret

000000b8 <vLEDFlashTask1>:
#include "FreeRTOS.h"
#include "task.h"
#include "led.h"

void vLEDFlashTask1( void *pvParameters )
{
  b8:	cf 93       	push	r28
  ba:	df 93       	push	r29
  bc:	00 d0       	rcall	.+0      	; 0xbe <vLEDFlashTask1+0x6>
  be:	cd b7       	in	r28, 0x3d	; 61
  c0:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	xLastWakeTime=xTaskGetTickCount();
  c2:	0e 94 1a 04 	call	0x834	; 0x834 <xTaskGetTickCount>
  c6:	9a 83       	std	Y+2, r25	; 0x02
  c8:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		toggleLED(0);
  ca:	80 e0       	ldi	r24, 0x00	; 0
  cc:	0e 94 4d 00 	call	0x9a	; 0x9a <toggleLED>
		vTaskDelayUntil(&xLastWakeTime,1000);
  d0:	68 ee       	ldi	r22, 0xE8	; 232
  d2:	73 e0       	ldi	r23, 0x03	; 3
  d4:	ce 01       	movw	r24, r28
  d6:	01 96       	adiw	r24, 0x01	; 1
  d8:	0e 94 6e 05 	call	0xadc	; 0xadc <vTaskDelayUntil>
	}
  dc:	f6 cf       	rjmp	.-20     	; 0xca <vLEDFlashTask1+0x12>

000000de <vLEDFlashTask2>:
}

void vLEDFlashTask2( void *pvParameters )
{
  de:	cf 93       	push	r28
  e0:	df 93       	push	r29
  e2:	00 d0       	rcall	.+0      	; 0xe4 <vLEDFlashTask2+0x6>
  e4:	cd b7       	in	r28, 0x3d	; 61
  e6:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	xLastWakeTime=xTaskGetTickCount();
  e8:	0e 94 1a 04 	call	0x834	; 0x834 <xTaskGetTickCount>
  ec:	9a 83       	std	Y+2, r25	; 0x02
  ee:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		toggleLED(1);
  f0:	81 e0       	ldi	r24, 0x01	; 1
  f2:	0e 94 4d 00 	call	0x9a	; 0x9a <toggleLED>
		vTaskDelayUntil(&xLastWakeTime,200);
  f6:	68 ec       	ldi	r22, 0xC8	; 200
  f8:	70 e0       	ldi	r23, 0x00	; 0
  fa:	ce 01       	movw	r24, r28
  fc:	01 96       	adiw	r24, 0x01	; 1
  fe:	0e 94 6e 05 	call	0xadc	; 0xadc <vTaskDelayUntil>
	}
 102:	f6 cf       	rjmp	.-20     	; 0xf0 <vLEDFlashTask2+0x12>

00000104 <main>:



int main(void)
{
	initLEDport();
 104:	0e 94 49 00 	call	0x92	; 0x92 <initLEDport>
	xTaskCreate( vLEDFlashTask1, (signed char * ) "LED1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
 108:	a1 2c       	mov	r10, r1
 10a:	b1 2c       	mov	r11, r1
 10c:	c1 2c       	mov	r12, r1
 10e:	d1 2c       	mov	r13, r1
 110:	e1 2c       	mov	r14, r1
 112:	f1 2c       	mov	r15, r1
 114:	00 e0       	ldi	r16, 0x00	; 0
 116:	20 e0       	ldi	r18, 0x00	; 0
 118:	30 e0       	ldi	r19, 0x00	; 0
 11a:	45 e5       	ldi	r20, 0x55	; 85
 11c:	50 e0       	ldi	r21, 0x00	; 0
 11e:	62 e6       	ldi	r22, 0x62	; 98
 120:	70 e0       	ldi	r23, 0x00	; 0
 122:	8c e5       	ldi	r24, 0x5C	; 92
 124:	90 e0       	ldi	r25, 0x00	; 0
 126:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <xTaskGenericCreate>
	xTaskCreate( vLEDFlashTask2, (signed char * ) "LED2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
 12a:	20 e0       	ldi	r18, 0x00	; 0
 12c:	30 e0       	ldi	r19, 0x00	; 0
 12e:	45 e5       	ldi	r20, 0x55	; 85
 130:	50 e0       	ldi	r21, 0x00	; 0
 132:	67 e6       	ldi	r22, 0x67	; 103
 134:	70 e0       	ldi	r23, 0x00	; 0
 136:	8f e6       	ldi	r24, 0x6F	; 111
 138:	90 e0       	ldi	r25, 0x00	; 0
 13a:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <xTaskGenericCreate>
	vTaskStartScheduler();
 13e:	0e 94 e9 03 	call	0x7d2	; 0x7d2 <vTaskStartScheduler>
	while(1)
	{}
 142:	ff cf       	rjmp	.-2      	; 0x142 <main+0x3e>

00000144 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 144:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 146:	03 96       	adiw	r24, 0x03	; 3
 148:	92 83       	std	Z+2, r25	; 0x02
 14a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 14c:	2f ef       	ldi	r18, 0xFF	; 255
 14e:	3f ef       	ldi	r19, 0xFF	; 255
 150:	34 83       	std	Z+4, r19	; 0x04
 152:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 154:	96 83       	std	Z+6, r25	; 0x06
 156:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 158:	90 87       	std	Z+8, r25	; 0x08
 15a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 15c:	10 82       	st	Z, r1
 15e:	08 95       	ret

00000160 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 160:	fc 01       	movw	r30, r24
 162:	11 86       	std	Z+9, r1	; 0x09
 164:	10 86       	std	Z+8, r1	; 0x08
 166:	08 95       	ret

00000168 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 168:	cf 93       	push	r28
 16a:	df 93       	push	r29
 16c:	fc 01       	movw	r30, r24
 16e:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 170:	21 81       	ldd	r18, Z+1	; 0x01
 172:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
 174:	e9 01       	movw	r28, r18
 176:	8a 81       	ldd	r24, Y+2	; 0x02
 178:	9b 81       	ldd	r25, Y+3	; 0x03
 17a:	13 96       	adiw	r26, 0x03	; 3
 17c:	9c 93       	st	X, r25
 17e:	8e 93       	st	-X, r24
 180:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
 182:	81 81       	ldd	r24, Z+1	; 0x01
 184:	92 81       	ldd	r25, Z+2	; 0x02
 186:	15 96       	adiw	r26, 0x05	; 5
 188:	9c 93       	st	X, r25
 18a:	8e 93       	st	-X, r24
 18c:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 18e:	8a 81       	ldd	r24, Y+2	; 0x02
 190:	9b 81       	ldd	r25, Y+3	; 0x03
 192:	ec 01       	movw	r28, r24
 194:	7d 83       	std	Y+5, r23	; 0x05
 196:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 198:	e9 01       	movw	r28, r18
 19a:	7b 83       	std	Y+3, r23	; 0x03
 19c:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 19e:	72 83       	std	Z+2, r23	; 0x02
 1a0:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1a2:	19 96       	adiw	r26, 0x09	; 9
 1a4:	fc 93       	st	X, r31
 1a6:	ee 93       	st	-X, r30
 1a8:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
 1aa:	80 81       	ld	r24, Z
 1ac:	8f 5f       	subi	r24, 0xFF	; 255
 1ae:	80 83       	st	Z, r24
}
 1b0:	df 91       	pop	r29
 1b2:	cf 91       	pop	r28
 1b4:	08 95       	ret

000001b6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 1b6:	cf 93       	push	r28
 1b8:	df 93       	push	r29
 1ba:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 1bc:	48 81       	ld	r20, Y
 1be:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 1c0:	4f 3f       	cpi	r20, 0xFF	; 255
 1c2:	2f ef       	ldi	r18, 0xFF	; 255
 1c4:	52 07       	cpc	r21, r18
 1c6:	31 f4       	brne	.+12     	; 0x1d4 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 1c8:	dc 01       	movw	r26, r24
 1ca:	17 96       	adiw	r26, 0x07	; 7
 1cc:	ed 91       	ld	r30, X+
 1ce:	fc 91       	ld	r31, X
 1d0:	18 97       	sbiw	r26, 0x08	; 8
 1d2:	17 c0       	rjmp	.+46     	; 0x202 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 1d4:	fc 01       	movw	r30, r24
 1d6:	33 96       	adiw	r30, 0x03	; 3
 1d8:	dc 01       	movw	r26, r24
 1da:	15 96       	adiw	r26, 0x05	; 5
 1dc:	2d 91       	ld	r18, X+
 1de:	3c 91       	ld	r19, X
 1e0:	16 97       	sbiw	r26, 0x06	; 6
 1e2:	d9 01       	movw	r26, r18
 1e4:	2d 91       	ld	r18, X+
 1e6:	3c 91       	ld	r19, X
 1e8:	42 17       	cp	r20, r18
 1ea:	53 07       	cpc	r21, r19
 1ec:	50 f0       	brcs	.+20     	; 0x202 <vListInsert+0x4c>
 1ee:	02 80       	ldd	r0, Z+2	; 0x02
 1f0:	f3 81       	ldd	r31, Z+3	; 0x03
 1f2:	e0 2d       	mov	r30, r0
 1f4:	a2 81       	ldd	r26, Z+2	; 0x02
 1f6:	b3 81       	ldd	r27, Z+3	; 0x03
 1f8:	2d 91       	ld	r18, X+
 1fa:	3c 91       	ld	r19, X
 1fc:	42 17       	cp	r20, r18
 1fe:	53 07       	cpc	r21, r19
 200:	b0 f7       	brcc	.-20     	; 0x1ee <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 202:	a2 81       	ldd	r26, Z+2	; 0x02
 204:	b3 81       	ldd	r27, Z+3	; 0x03
 206:	bb 83       	std	Y+3, r27	; 0x03
 208:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 20a:	15 96       	adiw	r26, 0x05	; 5
 20c:	dc 93       	st	X, r29
 20e:	ce 93       	st	-X, r28
 210:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
 212:	fd 83       	std	Y+5, r31	; 0x05
 214:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 216:	d3 83       	std	Z+3, r29	; 0x03
 218:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 21a:	99 87       	std	Y+9, r25	; 0x09
 21c:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 21e:	fc 01       	movw	r30, r24
 220:	20 81       	ld	r18, Z
 222:	2f 5f       	subi	r18, 0xFF	; 255
 224:	20 83       	st	Z, r18
}
 226:	df 91       	pop	r29
 228:	cf 91       	pop	r28
 22a:	08 95       	ret

0000022c <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 22c:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 22e:	a2 81       	ldd	r26, Z+2	; 0x02
 230:	b3 81       	ldd	r27, Z+3	; 0x03
 232:	84 81       	ldd	r24, Z+4	; 0x04
 234:	95 81       	ldd	r25, Z+5	; 0x05
 236:	15 96       	adiw	r26, 0x05	; 5
 238:	9c 93       	st	X, r25
 23a:	8e 93       	st	-X, r24
 23c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 23e:	a4 81       	ldd	r26, Z+4	; 0x04
 240:	b5 81       	ldd	r27, Z+5	; 0x05
 242:	82 81       	ldd	r24, Z+2	; 0x02
 244:	93 81       	ldd	r25, Z+3	; 0x03
 246:	13 96       	adiw	r26, 0x03	; 3
 248:	9c 93       	st	X, r25
 24a:	8e 93       	st	-X, r24
 24c:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 24e:	a0 85       	ldd	r26, Z+8	; 0x08
 250:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 252:	11 96       	adiw	r26, 0x01	; 1
 254:	8d 91       	ld	r24, X+
 256:	9c 91       	ld	r25, X
 258:	12 97       	sbiw	r26, 0x02	; 2
 25a:	8e 17       	cp	r24, r30
 25c:	9f 07       	cpc	r25, r31
 25e:	31 f4       	brne	.+12     	; 0x26c <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 260:	84 81       	ldd	r24, Z+4	; 0x04
 262:	95 81       	ldd	r25, Z+5	; 0x05
 264:	12 96       	adiw	r26, 0x02	; 2
 266:	9c 93       	st	X, r25
 268:	8e 93       	st	-X, r24
 26a:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
 26c:	11 86       	std	Z+9, r1	; 0x09
 26e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 270:	8c 91       	ld	r24, X
 272:	81 50       	subi	r24, 0x01	; 1
 274:	8c 93       	st	X, r24
 276:	08 95       	ret

00000278 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 278:	31 e1       	ldi	r19, 0x11	; 17
 27a:	fc 01       	movw	r30, r24
 27c:	30 83       	st	Z, r19
 27e:	31 97       	sbiw	r30, 0x01	; 1
 280:	22 e2       	ldi	r18, 0x22	; 34
 282:	20 83       	st	Z, r18
 284:	31 97       	sbiw	r30, 0x01	; 1
 286:	a3 e3       	ldi	r26, 0x33	; 51
 288:	a0 83       	st	Z, r26
 28a:	31 97       	sbiw	r30, 0x01	; 1
 28c:	60 83       	st	Z, r22
 28e:	31 97       	sbiw	r30, 0x01	; 1
 290:	70 83       	st	Z, r23
 292:	31 97       	sbiw	r30, 0x01	; 1
 294:	10 82       	st	Z, r1
 296:	31 97       	sbiw	r30, 0x01	; 1
 298:	60 e8       	ldi	r22, 0x80	; 128
 29a:	60 83       	st	Z, r22
 29c:	31 97       	sbiw	r30, 0x01	; 1
 29e:	10 82       	st	Z, r1
 2a0:	31 97       	sbiw	r30, 0x01	; 1
 2a2:	62 e0       	ldi	r22, 0x02	; 2
 2a4:	60 83       	st	Z, r22
 2a6:	31 97       	sbiw	r30, 0x01	; 1
 2a8:	63 e0       	ldi	r22, 0x03	; 3
 2aa:	60 83       	st	Z, r22
 2ac:	31 97       	sbiw	r30, 0x01	; 1
 2ae:	64 e0       	ldi	r22, 0x04	; 4
 2b0:	60 83       	st	Z, r22
 2b2:	31 97       	sbiw	r30, 0x01	; 1
 2b4:	65 e0       	ldi	r22, 0x05	; 5
 2b6:	60 83       	st	Z, r22
 2b8:	31 97       	sbiw	r30, 0x01	; 1
 2ba:	66 e0       	ldi	r22, 0x06	; 6
 2bc:	60 83       	st	Z, r22
 2be:	31 97       	sbiw	r30, 0x01	; 1
 2c0:	67 e0       	ldi	r22, 0x07	; 7
 2c2:	60 83       	st	Z, r22
 2c4:	31 97       	sbiw	r30, 0x01	; 1
 2c6:	68 e0       	ldi	r22, 0x08	; 8
 2c8:	60 83       	st	Z, r22
 2ca:	31 97       	sbiw	r30, 0x01	; 1
 2cc:	69 e0       	ldi	r22, 0x09	; 9
 2ce:	60 83       	st	Z, r22
 2d0:	31 97       	sbiw	r30, 0x01	; 1
 2d2:	60 e1       	ldi	r22, 0x10	; 16
 2d4:	60 83       	st	Z, r22
 2d6:	31 97       	sbiw	r30, 0x01	; 1
 2d8:	30 83       	st	Z, r19
 2da:	31 97       	sbiw	r30, 0x01	; 1
 2dc:	32 e1       	ldi	r19, 0x12	; 18
 2de:	30 83       	st	Z, r19
 2e0:	31 97       	sbiw	r30, 0x01	; 1
 2e2:	33 e1       	ldi	r19, 0x13	; 19
 2e4:	30 83       	st	Z, r19
 2e6:	31 97       	sbiw	r30, 0x01	; 1
 2e8:	34 e1       	ldi	r19, 0x14	; 20
 2ea:	30 83       	st	Z, r19
 2ec:	31 97       	sbiw	r30, 0x01	; 1
 2ee:	35 e1       	ldi	r19, 0x15	; 21
 2f0:	30 83       	st	Z, r19
 2f2:	31 97       	sbiw	r30, 0x01	; 1
 2f4:	36 e1       	ldi	r19, 0x16	; 22
 2f6:	30 83       	st	Z, r19
 2f8:	31 97       	sbiw	r30, 0x01	; 1
 2fa:	37 e1       	ldi	r19, 0x17	; 23
 2fc:	30 83       	st	Z, r19
 2fe:	31 97       	sbiw	r30, 0x01	; 1
 300:	38 e1       	ldi	r19, 0x18	; 24
 302:	30 83       	st	Z, r19
 304:	31 97       	sbiw	r30, 0x01	; 1
 306:	39 e1       	ldi	r19, 0x19	; 25
 308:	30 83       	st	Z, r19
 30a:	31 97       	sbiw	r30, 0x01	; 1
 30c:	30 e2       	ldi	r19, 0x20	; 32
 30e:	30 83       	st	Z, r19
 310:	31 97       	sbiw	r30, 0x01	; 1
 312:	31 e2       	ldi	r19, 0x21	; 33
 314:	30 83       	st	Z, r19
 316:	31 97       	sbiw	r30, 0x01	; 1
 318:	20 83       	st	Z, r18
 31a:	31 97       	sbiw	r30, 0x01	; 1
 31c:	23 e2       	ldi	r18, 0x23	; 35
 31e:	20 83       	st	Z, r18
 320:	31 97       	sbiw	r30, 0x01	; 1
 322:	40 83       	st	Z, r20
 324:	31 97       	sbiw	r30, 0x01	; 1
 326:	50 83       	st	Z, r21
 328:	31 97       	sbiw	r30, 0x01	; 1
 32a:	26 e2       	ldi	r18, 0x26	; 38
 32c:	20 83       	st	Z, r18
 32e:	31 97       	sbiw	r30, 0x01	; 1
 330:	27 e2       	ldi	r18, 0x27	; 39
 332:	20 83       	st	Z, r18
 334:	31 97       	sbiw	r30, 0x01	; 1
 336:	28 e2       	ldi	r18, 0x28	; 40
 338:	20 83       	st	Z, r18
 33a:	31 97       	sbiw	r30, 0x01	; 1
 33c:	29 e2       	ldi	r18, 0x29	; 41
 33e:	20 83       	st	Z, r18
 340:	31 97       	sbiw	r30, 0x01	; 1
 342:	20 e3       	ldi	r18, 0x30	; 48
 344:	20 83       	st	Z, r18
 346:	31 97       	sbiw	r30, 0x01	; 1
 348:	21 e3       	ldi	r18, 0x31	; 49
 34a:	20 83       	st	Z, r18
 34c:	86 97       	sbiw	r24, 0x26	; 38
 34e:	08 95       	ret

00000350 <xPortStartScheduler>:
 350:	1b bc       	out	0x2b, r1	; 43
 352:	88 e3       	ldi	r24, 0x38	; 56
 354:	8a bd       	out	0x2a, r24	; 42
 356:	8b e0       	ldi	r24, 0x0B	; 11
 358:	8e bd       	out	0x2e, r24	; 46
 35a:	89 b7       	in	r24, 0x39	; 57
 35c:	80 61       	ori	r24, 0x10	; 16
 35e:	89 bf       	out	0x39, r24	; 57
 360:	a0 91 83 06 	lds	r26, 0x0683	; 0x800683 <pxCurrentTCB>
 364:	b0 91 84 06 	lds	r27, 0x0684	; 0x800684 <pxCurrentTCB+0x1>
 368:	cd 91       	ld	r28, X+
 36a:	cd bf       	out	0x3d, r28	; 61
 36c:	dd 91       	ld	r29, X+
 36e:	de bf       	out	0x3e, r29	; 62
 370:	ff 91       	pop	r31
 372:	ef 91       	pop	r30
 374:	df 91       	pop	r29
 376:	cf 91       	pop	r28
 378:	bf 91       	pop	r27
 37a:	af 91       	pop	r26
 37c:	9f 91       	pop	r25
 37e:	8f 91       	pop	r24
 380:	7f 91       	pop	r23
 382:	6f 91       	pop	r22
 384:	5f 91       	pop	r21
 386:	4f 91       	pop	r20
 388:	3f 91       	pop	r19
 38a:	2f 91       	pop	r18
 38c:	1f 91       	pop	r17
 38e:	0f 91       	pop	r16
 390:	ff 90       	pop	r15
 392:	ef 90       	pop	r14
 394:	df 90       	pop	r13
 396:	cf 90       	pop	r12
 398:	bf 90       	pop	r11
 39a:	af 90       	pop	r10
 39c:	9f 90       	pop	r9
 39e:	8f 90       	pop	r8
 3a0:	7f 90       	pop	r7
 3a2:	6f 90       	pop	r6
 3a4:	5f 90       	pop	r5
 3a6:	4f 90       	pop	r4
 3a8:	3f 90       	pop	r3
 3aa:	2f 90       	pop	r2
 3ac:	1f 90       	pop	r1
 3ae:	0f 90       	pop	r0
 3b0:	0f be       	out	0x3f, r0	; 63
 3b2:	0f 90       	pop	r0
 3b4:	08 95       	ret
 3b6:	81 e0       	ldi	r24, 0x01	; 1
 3b8:	08 95       	ret

000003ba <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 3ba:	0f 92       	push	r0
 3bc:	0f b6       	in	r0, 0x3f	; 63
 3be:	f8 94       	cli
 3c0:	0f 92       	push	r0
 3c2:	1f 92       	push	r1
 3c4:	11 24       	eor	r1, r1
 3c6:	2f 92       	push	r2
 3c8:	3f 92       	push	r3
 3ca:	4f 92       	push	r4
 3cc:	5f 92       	push	r5
 3ce:	6f 92       	push	r6
 3d0:	7f 92       	push	r7
 3d2:	8f 92       	push	r8
 3d4:	9f 92       	push	r9
 3d6:	af 92       	push	r10
 3d8:	bf 92       	push	r11
 3da:	cf 92       	push	r12
 3dc:	df 92       	push	r13
 3de:	ef 92       	push	r14
 3e0:	ff 92       	push	r15
 3e2:	0f 93       	push	r16
 3e4:	1f 93       	push	r17
 3e6:	2f 93       	push	r18
 3e8:	3f 93       	push	r19
 3ea:	4f 93       	push	r20
 3ec:	5f 93       	push	r21
 3ee:	6f 93       	push	r22
 3f0:	7f 93       	push	r23
 3f2:	8f 93       	push	r24
 3f4:	9f 93       	push	r25
 3f6:	af 93       	push	r26
 3f8:	bf 93       	push	r27
 3fa:	cf 93       	push	r28
 3fc:	df 93       	push	r29
 3fe:	ef 93       	push	r30
 400:	ff 93       	push	r31
 402:	a0 91 83 06 	lds	r26, 0x0683	; 0x800683 <pxCurrentTCB>
 406:	b0 91 84 06 	lds	r27, 0x0684	; 0x800684 <pxCurrentTCB+0x1>
 40a:	0d b6       	in	r0, 0x3d	; 61
 40c:	0d 92       	st	X+, r0
 40e:	0e b6       	in	r0, 0x3e	; 62
 410:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 412:	0e 94 b8 05 	call	0xb70	; 0xb70 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 416:	a0 91 83 06 	lds	r26, 0x0683	; 0x800683 <pxCurrentTCB>
 41a:	b0 91 84 06 	lds	r27, 0x0684	; 0x800684 <pxCurrentTCB+0x1>
 41e:	cd 91       	ld	r28, X+
 420:	cd bf       	out	0x3d, r28	; 61
 422:	dd 91       	ld	r29, X+
 424:	de bf       	out	0x3e, r29	; 62
 426:	ff 91       	pop	r31
 428:	ef 91       	pop	r30
 42a:	df 91       	pop	r29
 42c:	cf 91       	pop	r28
 42e:	bf 91       	pop	r27
 430:	af 91       	pop	r26
 432:	9f 91       	pop	r25
 434:	8f 91       	pop	r24
 436:	7f 91       	pop	r23
 438:	6f 91       	pop	r22
 43a:	5f 91       	pop	r21
 43c:	4f 91       	pop	r20
 43e:	3f 91       	pop	r19
 440:	2f 91       	pop	r18
 442:	1f 91       	pop	r17
 444:	0f 91       	pop	r16
 446:	ff 90       	pop	r15
 448:	ef 90       	pop	r14
 44a:	df 90       	pop	r13
 44c:	cf 90       	pop	r12
 44e:	bf 90       	pop	r11
 450:	af 90       	pop	r10
 452:	9f 90       	pop	r9
 454:	8f 90       	pop	r8
 456:	7f 90       	pop	r7
 458:	6f 90       	pop	r6
 45a:	5f 90       	pop	r5
 45c:	4f 90       	pop	r4
 45e:	3f 90       	pop	r3
 460:	2f 90       	pop	r2
 462:	1f 90       	pop	r1
 464:	0f 90       	pop	r0
 466:	0f be       	out	0x3f, r0	; 63
 468:	0f 90       	pop	r0

	asm volatile ( "ret" );
 46a:	08 95       	ret

0000046c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 46c:	0f 92       	push	r0
 46e:	0f b6       	in	r0, 0x3f	; 63
 470:	f8 94       	cli
 472:	0f 92       	push	r0
 474:	1f 92       	push	r1
 476:	11 24       	eor	r1, r1
 478:	2f 92       	push	r2
 47a:	3f 92       	push	r3
 47c:	4f 92       	push	r4
 47e:	5f 92       	push	r5
 480:	6f 92       	push	r6
 482:	7f 92       	push	r7
 484:	8f 92       	push	r8
 486:	9f 92       	push	r9
 488:	af 92       	push	r10
 48a:	bf 92       	push	r11
 48c:	cf 92       	push	r12
 48e:	df 92       	push	r13
 490:	ef 92       	push	r14
 492:	ff 92       	push	r15
 494:	0f 93       	push	r16
 496:	1f 93       	push	r17
 498:	2f 93       	push	r18
 49a:	3f 93       	push	r19
 49c:	4f 93       	push	r20
 49e:	5f 93       	push	r21
 4a0:	6f 93       	push	r22
 4a2:	7f 93       	push	r23
 4a4:	8f 93       	push	r24
 4a6:	9f 93       	push	r25
 4a8:	af 93       	push	r26
 4aa:	bf 93       	push	r27
 4ac:	cf 93       	push	r28
 4ae:	df 93       	push	r29
 4b0:	ef 93       	push	r30
 4b2:	ff 93       	push	r31
 4b4:	a0 91 83 06 	lds	r26, 0x0683	; 0x800683 <pxCurrentTCB>
 4b8:	b0 91 84 06 	lds	r27, 0x0684	; 0x800684 <pxCurrentTCB+0x1>
 4bc:	0d b6       	in	r0, 0x3d	; 61
 4be:	0d 92       	st	X+, r0
 4c0:	0e b6       	in	r0, 0x3e	; 62
 4c2:	0d 92       	st	X+, r0
	vTaskIncrementTick();
 4c4:	0e 94 24 04 	call	0x848	; 0x848 <vTaskIncrementTick>
	vTaskSwitchContext();
 4c8:	0e 94 b8 05 	call	0xb70	; 0xb70 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 4cc:	a0 91 83 06 	lds	r26, 0x0683	; 0x800683 <pxCurrentTCB>
 4d0:	b0 91 84 06 	lds	r27, 0x0684	; 0x800684 <pxCurrentTCB+0x1>
 4d4:	cd 91       	ld	r28, X+
 4d6:	cd bf       	out	0x3d, r28	; 61
 4d8:	dd 91       	ld	r29, X+
 4da:	de bf       	out	0x3e, r29	; 62
 4dc:	ff 91       	pop	r31
 4de:	ef 91       	pop	r30
 4e0:	df 91       	pop	r29
 4e2:	cf 91       	pop	r28
 4e4:	bf 91       	pop	r27
 4e6:	af 91       	pop	r26
 4e8:	9f 91       	pop	r25
 4ea:	8f 91       	pop	r24
 4ec:	7f 91       	pop	r23
 4ee:	6f 91       	pop	r22
 4f0:	5f 91       	pop	r21
 4f2:	4f 91       	pop	r20
 4f4:	3f 91       	pop	r19
 4f6:	2f 91       	pop	r18
 4f8:	1f 91       	pop	r17
 4fa:	0f 91       	pop	r16
 4fc:	ff 90       	pop	r15
 4fe:	ef 90       	pop	r14
 500:	df 90       	pop	r13
 502:	cf 90       	pop	r12
 504:	bf 90       	pop	r11
 506:	af 90       	pop	r10
 508:	9f 90       	pop	r9
 50a:	8f 90       	pop	r8
 50c:	7f 90       	pop	r7
 50e:	6f 90       	pop	r6
 510:	5f 90       	pop	r5
 512:	4f 90       	pop	r4
 514:	3f 90       	pop	r3
 516:	2f 90       	pop	r2
 518:	1f 90       	pop	r1
 51a:	0f 90       	pop	r0
 51c:	0f be       	out	0x3f, r0	; 63
 51e:	0f 90       	pop	r0

	asm volatile ( "ret" );
 520:	08 95       	ret

00000522 <__vector_7>:
//	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 522:	0e 94 36 02 	call	0x46c	; 0x46c <vPortYieldFromTick>
		asm volatile ( "reti" );
 526:	18 95       	reti

00000528 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 528:	cf 93       	push	r28
 52a:	df 93       	push	r29
 52c:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
 52e:	0e 94 14 04 	call	0x828	; 0x828 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
 532:	20 91 72 00 	lds	r18, 0x0072	; 0x800072 <__data_end>
 536:	30 91 73 00 	lds	r19, 0x0073	; 0x800073 <__data_end+0x1>
 53a:	ce 01       	movw	r24, r28
 53c:	82 0f       	add	r24, r18
 53e:	93 1f       	adc	r25, r19
 540:	8c 3d       	cpi	r24, 0xDC	; 220
 542:	45 e0       	ldi	r20, 0x05	; 5
 544:	94 07       	cpc	r25, r20
 546:	58 f4       	brcc	.+22     	; 0x55e <pvPortMalloc+0x36>
 548:	28 17       	cp	r18, r24
 54a:	39 07       	cpc	r19, r25
 54c:	58 f4       	brcc	.+22     	; 0x564 <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
 54e:	e9 01       	movw	r28, r18
 550:	cc 58       	subi	r28, 0x8C	; 140
 552:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
 554:	90 93 73 00 	sts	0x0073, r25	; 0x800073 <__data_end+0x1>
 558:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__data_end>
 55c:	05 c0       	rjmp	.+10     	; 0x568 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
 55e:	c0 e0       	ldi	r28, 0x00	; 0
 560:	d0 e0       	ldi	r29, 0x00	; 0
 562:	02 c0       	rjmp	.+4      	; 0x568 <pvPortMalloc+0x40>
 564:	c0 e0       	ldi	r28, 0x00	; 0
 566:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
 568:	0e 94 e8 04 	call	0x9d0	; 0x9d0 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
 56c:	ce 01       	movw	r24, r28
 56e:	df 91       	pop	r29
 570:	cf 91       	pop	r28
 572:	08 95       	ret

00000574 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 574:	08 95       	ret

00000576 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
 576:	ca e7       	ldi	r28, 0x7A	; 122
 578:	d6 e0       	ldi	r29, 0x06	; 6
 57a:	88 81       	ld	r24, Y
 57c:	82 30       	cpi	r24, 0x02	; 2
 57e:	e8 f3       	brcs	.-6      	; 0x57a <prvIdleTask+0x4>
 580:	0e 94 dd 01 	call	0x3ba	; 0x3ba <vPortYield>
 584:	fa cf       	rjmp	.-12     	; 0x57a <prvIdleTask+0x4>

00000586 <prvAddCurrentTaskToDelayedList>:
 586:	cf 93       	push	r28
 588:	df 93       	push	r29
 58a:	ec 01       	movw	r28, r24
 58c:	e0 91 83 06 	lds	r30, 0x0683	; 0x800683 <pxCurrentTCB>
 590:	f0 91 84 06 	lds	r31, 0x0684	; 0x800684 <pxCurrentTCB+0x1>
 594:	93 83       	std	Z+3, r25	; 0x03
 596:	82 83       	std	Z+2, r24	; 0x02
 598:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <xTickCount>
 59c:	90 91 59 06 	lds	r25, 0x0659	; 0x800659 <xTickCount+0x1>
 5a0:	c8 17       	cp	r28, r24
 5a2:	d9 07       	cpc	r29, r25
 5a4:	68 f4       	brcc	.+26     	; 0x5c0 <prvAddCurrentTaskToDelayedList+0x3a>
 5a6:	60 91 83 06 	lds	r22, 0x0683	; 0x800683 <pxCurrentTCB>
 5aa:	70 91 84 06 	lds	r23, 0x0684	; 0x800684 <pxCurrentTCB+0x1>
 5ae:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <pxOverflowDelayedTaskList>
 5b2:	90 91 65 06 	lds	r25, 0x0665	; 0x800665 <pxOverflowDelayedTaskList+0x1>
 5b6:	6e 5f       	subi	r22, 0xFE	; 254
 5b8:	7f 4f       	sbci	r23, 0xFF	; 255
 5ba:	0e 94 db 00 	call	0x1b6	; 0x1b6 <vListInsert>
 5be:	17 c0       	rjmp	.+46     	; 0x5ee <prvAddCurrentTaskToDelayedList+0x68>
 5c0:	60 91 83 06 	lds	r22, 0x0683	; 0x800683 <pxCurrentTCB>
 5c4:	70 91 84 06 	lds	r23, 0x0684	; 0x800684 <pxCurrentTCB+0x1>
 5c8:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <pxDelayedTaskList>
 5cc:	90 91 67 06 	lds	r25, 0x0667	; 0x800667 <pxDelayedTaskList+0x1>
 5d0:	6e 5f       	subi	r22, 0xFE	; 254
 5d2:	7f 4f       	sbci	r23, 0xFF	; 255
 5d4:	0e 94 db 00 	call	0x1b6	; 0x1b6 <vListInsert>
 5d8:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
 5dc:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
 5e0:	c8 17       	cp	r28, r24
 5e2:	d9 07       	cpc	r29, r25
 5e4:	20 f4       	brcc	.+8      	; 0x5ee <prvAddCurrentTaskToDelayedList+0x68>
 5e6:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__data_start+0x1>
 5ea:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__data_start>
 5ee:	df 91       	pop	r29
 5f0:	cf 91       	pop	r28
 5f2:	08 95       	ret

000005f4 <xTaskGenericCreate>:
 5f4:	4f 92       	push	r4
 5f6:	5f 92       	push	r5
 5f8:	6f 92       	push	r6
 5fa:	7f 92       	push	r7
 5fc:	8f 92       	push	r8
 5fe:	9f 92       	push	r9
 600:	af 92       	push	r10
 602:	bf 92       	push	r11
 604:	cf 92       	push	r12
 606:	df 92       	push	r13
 608:	ef 92       	push	r14
 60a:	ff 92       	push	r15
 60c:	0f 93       	push	r16
 60e:	cf 93       	push	r28
 610:	df 93       	push	r29
 612:	5c 01       	movw	r10, r24
 614:	4b 01       	movw	r8, r22
 616:	3a 01       	movw	r6, r20
 618:	29 01       	movw	r4, r18
 61a:	81 e2       	ldi	r24, 0x21	; 33
 61c:	90 e0       	ldi	r25, 0x00	; 0
 61e:	0e 94 94 02 	call	0x528	; 0x528 <pvPortMalloc>
 622:	ec 01       	movw	r28, r24
 624:	89 2b       	or	r24, r25
 626:	09 f4       	brne	.+2      	; 0x62a <xTaskGenericCreate+0x36>
 628:	a5 c0       	rjmp	.+330    	; 0x774 <xTaskGenericCreate+0x180>
 62a:	c1 14       	cp	r12, r1
 62c:	d1 04       	cpc	r13, r1
 62e:	09 f0       	breq	.+2      	; 0x632 <xTaskGenericCreate+0x3e>
 630:	9d c0       	rjmp	.+314    	; 0x76c <xTaskGenericCreate+0x178>
 632:	c3 01       	movw	r24, r6
 634:	0e 94 94 02 	call	0x528	; 0x528 <pvPortMalloc>
 638:	98 8f       	std	Y+24, r25	; 0x18
 63a:	8f 8b       	std	Y+23, r24	; 0x17
 63c:	00 97       	sbiw	r24, 0x00	; 0
 63e:	21 f4       	brne	.+8      	; 0x648 <xTaskGenericCreate+0x54>
 640:	ce 01       	movw	r24, r28
 642:	0e 94 ba 02 	call	0x574	; 0x574 <vPortFree>
 646:	96 c0       	rjmp	.+300    	; 0x774 <xTaskGenericCreate+0x180>
 648:	a3 01       	movw	r20, r6
 64a:	65 ea       	ldi	r22, 0xA5	; 165
 64c:	70 e0       	ldi	r23, 0x00	; 0
 64e:	0e 94 24 06 	call	0xc48	; 0xc48 <memset>
 652:	93 01       	movw	r18, r6
 654:	21 50       	subi	r18, 0x01	; 1
 656:	31 09       	sbc	r19, r1
 658:	8f 89       	ldd	r24, Y+23	; 0x17
 65a:	98 8d       	ldd	r25, Y+24	; 0x18
 65c:	3c 01       	movw	r6, r24
 65e:	62 0e       	add	r6, r18
 660:	73 1e       	adc	r7, r19
 662:	48 e0       	ldi	r20, 0x08	; 8
 664:	50 e0       	ldi	r21, 0x00	; 0
 666:	b4 01       	movw	r22, r8
 668:	ce 01       	movw	r24, r28
 66a:	49 96       	adiw	r24, 0x19	; 25
 66c:	0e 94 2b 06 	call	0xc56	; 0xc56 <strncpy>
 670:	18 a2       	std	Y+32, r1	; 0x20
 672:	1e 8a       	std	Y+22, r1	; 0x16
 674:	6e 01       	movw	r12, r28
 676:	82 e0       	ldi	r24, 0x02	; 2
 678:	c8 0e       	add	r12, r24
 67a:	d1 1c       	adc	r13, r1
 67c:	c6 01       	movw	r24, r12
 67e:	0e 94 b0 00 	call	0x160	; 0x160 <vListInitialiseItem>
 682:	ce 01       	movw	r24, r28
 684:	0c 96       	adiw	r24, 0x0c	; 12
 686:	0e 94 b0 00 	call	0x160	; 0x160 <vListInitialiseItem>
 68a:	d9 87       	std	Y+9, r29	; 0x09
 68c:	c8 87       	std	Y+8, r28	; 0x08
 68e:	81 e0       	ldi	r24, 0x01	; 1
 690:	90 e0       	ldi	r25, 0x00	; 0
 692:	9d 87       	std	Y+13, r25	; 0x0d
 694:	8c 87       	std	Y+12, r24	; 0x0c
 696:	db 8b       	std	Y+19, r29	; 0x13
 698:	ca 8b       	std	Y+18, r28	; 0x12
 69a:	a2 01       	movw	r20, r4
 69c:	b5 01       	movw	r22, r10
 69e:	c3 01       	movw	r24, r6
 6a0:	0e 94 3c 01 	call	0x278	; 0x278 <pxPortInitialiseStack>
 6a4:	99 83       	std	Y+1, r25	; 0x01
 6a6:	88 83       	st	Y, r24
 6a8:	e1 14       	cp	r14, r1
 6aa:	f1 04       	cpc	r15, r1
 6ac:	19 f0       	breq	.+6      	; 0x6b4 <xTaskGenericCreate+0xc0>
 6ae:	f7 01       	movw	r30, r14
 6b0:	d1 83       	std	Z+1, r29	; 0x01
 6b2:	c0 83       	st	Z, r28
 6b4:	0f b6       	in	r0, 0x3f	; 63
 6b6:	f8 94       	cli
 6b8:	0f 92       	push	r0
 6ba:	80 91 5a 06 	lds	r24, 0x065A	; 0x80065a <uxCurrentNumberOfTasks>
 6be:	8f 5f       	subi	r24, 0xFF	; 255
 6c0:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <uxCurrentNumberOfTasks>
 6c4:	80 91 83 06 	lds	r24, 0x0683	; 0x800683 <pxCurrentTCB>
 6c8:	90 91 84 06 	lds	r25, 0x0684	; 0x800684 <pxCurrentTCB+0x1>
 6cc:	89 2b       	or	r24, r25
 6ce:	49 f4       	brne	.+18     	; 0x6e2 <xTaskGenericCreate+0xee>
 6d0:	d0 93 84 06 	sts	0x0684, r29	; 0x800684 <pxCurrentTCB+0x1>
 6d4:	c0 93 83 06 	sts	0x0683, r28	; 0x800683 <pxCurrentTCB>
 6d8:	80 91 5a 06 	lds	r24, 0x065A	; 0x80065a <uxCurrentNumberOfTasks>
 6dc:	81 30       	cpi	r24, 0x01	; 1
 6de:	81 f4       	brne	.+32     	; 0x700 <xTaskGenericCreate+0x10c>
 6e0:	4b c0       	rjmp	.+150    	; 0x778 <xTaskGenericCreate+0x184>
 6e2:	80 91 55 06 	lds	r24, 0x0655	; 0x800655 <xSchedulerRunning>
 6e6:	81 11       	cpse	r24, r1
 6e8:	0b c0       	rjmp	.+22     	; 0x700 <xTaskGenericCreate+0x10c>
 6ea:	e0 91 83 06 	lds	r30, 0x0683	; 0x800683 <pxCurrentTCB>
 6ee:	f0 91 84 06 	lds	r31, 0x0684	; 0x800684 <pxCurrentTCB+0x1>
 6f2:	86 89       	ldd	r24, Z+22	; 0x16
 6f4:	08 17       	cp	r16, r24
 6f6:	20 f0       	brcs	.+8      	; 0x700 <xTaskGenericCreate+0x10c>
 6f8:	d0 93 84 06 	sts	0x0684, r29	; 0x800684 <pxCurrentTCB+0x1>
 6fc:	c0 93 83 06 	sts	0x0683, r28	; 0x800683 <pxCurrentTCB>
 700:	8e 89       	ldd	r24, Y+22	; 0x16
 702:	90 91 57 06 	lds	r25, 0x0657	; 0x800657 <uxTopUsedPriority>
 706:	98 17       	cp	r25, r24
 708:	10 f4       	brcc	.+4      	; 0x70e <xTaskGenericCreate+0x11a>
 70a:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <uxTopUsedPriority>
 70e:	90 91 50 06 	lds	r25, 0x0650	; 0x800650 <uxTCBNumber>
 712:	9f 5f       	subi	r25, 0xFF	; 255
 714:	90 93 50 06 	sts	0x0650, r25	; 0x800650 <uxTCBNumber>
 718:	90 91 56 06 	lds	r25, 0x0656	; 0x800656 <uxTopReadyPriority>
 71c:	98 17       	cp	r25, r24
 71e:	10 f4       	brcc	.+4      	; 0x724 <xTaskGenericCreate+0x130>
 720:	80 93 56 06 	sts	0x0656, r24	; 0x800656 <uxTopReadyPriority>
 724:	90 e0       	ldi	r25, 0x00	; 0
 726:	9c 01       	movw	r18, r24
 728:	22 0f       	add	r18, r18
 72a:	33 1f       	adc	r19, r19
 72c:	22 0f       	add	r18, r18
 72e:	33 1f       	adc	r19, r19
 730:	22 0f       	add	r18, r18
 732:	33 1f       	adc	r19, r19
 734:	82 0f       	add	r24, r18
 736:	93 1f       	adc	r25, r19
 738:	b6 01       	movw	r22, r12
 73a:	86 58       	subi	r24, 0x86	; 134
 73c:	99 4f       	sbci	r25, 0xF9	; 249
 73e:	0e 94 b4 00 	call	0x168	; 0x168 <vListInsertEnd>
 742:	0f 90       	pop	r0
 744:	0f be       	out	0x3f, r0	; 63
 746:	80 91 55 06 	lds	r24, 0x0655	; 0x800655 <xSchedulerRunning>
 74a:	88 23       	and	r24, r24
 74c:	59 f0       	breq	.+22     	; 0x764 <xTaskGenericCreate+0x170>
 74e:	e0 91 83 06 	lds	r30, 0x0683	; 0x800683 <pxCurrentTCB>
 752:	f0 91 84 06 	lds	r31, 0x0684	; 0x800684 <pxCurrentTCB+0x1>
 756:	86 89       	ldd	r24, Z+22	; 0x16
 758:	80 17       	cp	r24, r16
 75a:	30 f4       	brcc	.+12     	; 0x768 <xTaskGenericCreate+0x174>
 75c:	0e 94 dd 01 	call	0x3ba	; 0x3ba <vPortYield>
 760:	81 e0       	ldi	r24, 0x01	; 1
 762:	27 c0       	rjmp	.+78     	; 0x7b2 <xTaskGenericCreate+0x1be>
 764:	81 e0       	ldi	r24, 0x01	; 1
 766:	25 c0       	rjmp	.+74     	; 0x7b2 <xTaskGenericCreate+0x1be>
 768:	81 e0       	ldi	r24, 0x01	; 1
 76a:	23 c0       	rjmp	.+70     	; 0x7b2 <xTaskGenericCreate+0x1be>
 76c:	d8 8e       	std	Y+24, r13	; 0x18
 76e:	cf 8a       	std	Y+23, r12	; 0x17
 770:	c6 01       	movw	r24, r12
 772:	6a cf       	rjmp	.-300    	; 0x648 <xTaskGenericCreate+0x54>
 774:	8f ef       	ldi	r24, 0xFF	; 255
 776:	1d c0       	rjmp	.+58     	; 0x7b2 <xTaskGenericCreate+0x1be>
 778:	8a e7       	ldi	r24, 0x7A	; 122
 77a:	96 e0       	ldi	r25, 0x06	; 6
 77c:	0e 94 a2 00 	call	0x144	; 0x144 <vListInitialise>
 780:	81 e7       	ldi	r24, 0x71	; 113
 782:	96 e0       	ldi	r25, 0x06	; 6
 784:	0e 94 a2 00 	call	0x144	; 0x144 <vListInitialise>
 788:	88 e6       	ldi	r24, 0x68	; 104
 78a:	96 e0       	ldi	r25, 0x06	; 6
 78c:	0e 94 a2 00 	call	0x144	; 0x144 <vListInitialise>
 790:	8b e5       	ldi	r24, 0x5B	; 91
 792:	96 e0       	ldi	r25, 0x06	; 6
 794:	0e 94 a2 00 	call	0x144	; 0x144 <vListInitialise>
 798:	81 e7       	ldi	r24, 0x71	; 113
 79a:	96 e0       	ldi	r25, 0x06	; 6
 79c:	90 93 67 06 	sts	0x0667, r25	; 0x800667 <pxDelayedTaskList+0x1>
 7a0:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <pxDelayedTaskList>
 7a4:	88 e6       	ldi	r24, 0x68	; 104
 7a6:	96 e0       	ldi	r25, 0x06	; 6
 7a8:	90 93 65 06 	sts	0x0665, r25	; 0x800665 <pxOverflowDelayedTaskList+0x1>
 7ac:	80 93 64 06 	sts	0x0664, r24	; 0x800664 <pxOverflowDelayedTaskList>
 7b0:	a7 cf       	rjmp	.-178    	; 0x700 <xTaskGenericCreate+0x10c>
 7b2:	df 91       	pop	r29
 7b4:	cf 91       	pop	r28
 7b6:	0f 91       	pop	r16
 7b8:	ff 90       	pop	r15
 7ba:	ef 90       	pop	r14
 7bc:	df 90       	pop	r13
 7be:	cf 90       	pop	r12
 7c0:	bf 90       	pop	r11
 7c2:	af 90       	pop	r10
 7c4:	9f 90       	pop	r9
 7c6:	8f 90       	pop	r8
 7c8:	7f 90       	pop	r7
 7ca:	6f 90       	pop	r6
 7cc:	5f 90       	pop	r5
 7ce:	4f 90       	pop	r4
 7d0:	08 95       	ret

000007d2 <vTaskStartScheduler>:
 7d2:	af 92       	push	r10
 7d4:	bf 92       	push	r11
 7d6:	cf 92       	push	r12
 7d8:	df 92       	push	r13
 7da:	ef 92       	push	r14
 7dc:	ff 92       	push	r15
 7de:	0f 93       	push	r16
 7e0:	a1 2c       	mov	r10, r1
 7e2:	b1 2c       	mov	r11, r1
 7e4:	c1 2c       	mov	r12, r1
 7e6:	d1 2c       	mov	r13, r1
 7e8:	e1 2c       	mov	r14, r1
 7ea:	f1 2c       	mov	r15, r1
 7ec:	00 e0       	ldi	r16, 0x00	; 0
 7ee:	20 e0       	ldi	r18, 0x00	; 0
 7f0:	30 e0       	ldi	r19, 0x00	; 0
 7f2:	45 e5       	ldi	r20, 0x55	; 85
 7f4:	50 e0       	ldi	r21, 0x00	; 0
 7f6:	6c e6       	ldi	r22, 0x6C	; 108
 7f8:	70 e0       	ldi	r23, 0x00	; 0
 7fa:	8b eb       	ldi	r24, 0xBB	; 187
 7fc:	92 e0       	ldi	r25, 0x02	; 2
 7fe:	0e 94 fa 02 	call	0x5f4	; 0x5f4 <xTaskGenericCreate>
 802:	81 30       	cpi	r24, 0x01	; 1
 804:	49 f4       	brne	.+18     	; 0x818 <vTaskStartScheduler+0x46>
 806:	f8 94       	cli
 808:	80 93 55 06 	sts	0x0655, r24	; 0x800655 <xSchedulerRunning>
 80c:	10 92 59 06 	sts	0x0659, r1	; 0x800659 <xTickCount+0x1>
 810:	10 92 58 06 	sts	0x0658, r1	; 0x800658 <xTickCount>
 814:	0e 94 a8 01 	call	0x350	; 0x350 <xPortStartScheduler>
 818:	0f 91       	pop	r16
 81a:	ff 90       	pop	r15
 81c:	ef 90       	pop	r14
 81e:	df 90       	pop	r13
 820:	cf 90       	pop	r12
 822:	bf 90       	pop	r11
 824:	af 90       	pop	r10
 826:	08 95       	ret

00000828 <vTaskSuspendAll>:
 828:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
 82c:	8f 5f       	subi	r24, 0xFF	; 255
 82e:	80 93 54 06 	sts	0x0654, r24	; 0x800654 <uxSchedulerSuspended>
 832:	08 95       	ret

00000834 <xTaskGetTickCount>:
 834:	0f b6       	in	r0, 0x3f	; 63
 836:	f8 94       	cli
 838:	0f 92       	push	r0
 83a:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <xTickCount>
 83e:	90 91 59 06 	lds	r25, 0x0659	; 0x800659 <xTickCount+0x1>
 842:	0f 90       	pop	r0
 844:	0f be       	out	0x3f, r0	; 63
 846:	08 95       	ret

00000848 <vTaskIncrementTick>:
 848:	0f 93       	push	r16
 84a:	1f 93       	push	r17
 84c:	cf 93       	push	r28
 84e:	df 93       	push	r29
 850:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
 854:	81 11       	cpse	r24, r1
 856:	b2 c0       	rjmp	.+356    	; 0x9bc <__stack+0x15d>
 858:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <xTickCount>
 85c:	90 91 59 06 	lds	r25, 0x0659	; 0x800659 <xTickCount+0x1>
 860:	01 96       	adiw	r24, 0x01	; 1
 862:	90 93 59 06 	sts	0x0659, r25	; 0x800659 <xTickCount+0x1>
 866:	80 93 58 06 	sts	0x0658, r24	; 0x800658 <xTickCount>
 86a:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <xTickCount>
 86e:	90 91 59 06 	lds	r25, 0x0659	; 0x800659 <xTickCount+0x1>
 872:	89 2b       	or	r24, r25
 874:	99 f5       	brne	.+102    	; 0x8dc <__stack+0x7d>
 876:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <pxDelayedTaskList>
 87a:	90 91 67 06 	lds	r25, 0x0667	; 0x800667 <pxDelayedTaskList+0x1>
 87e:	20 91 64 06 	lds	r18, 0x0664	; 0x800664 <pxOverflowDelayedTaskList>
 882:	30 91 65 06 	lds	r19, 0x0665	; 0x800665 <pxOverflowDelayedTaskList+0x1>
 886:	30 93 67 06 	sts	0x0667, r19	; 0x800667 <pxDelayedTaskList+0x1>
 88a:	20 93 66 06 	sts	0x0666, r18	; 0x800666 <pxDelayedTaskList>
 88e:	90 93 65 06 	sts	0x0665, r25	; 0x800665 <pxOverflowDelayedTaskList+0x1>
 892:	80 93 64 06 	sts	0x0664, r24	; 0x800664 <pxOverflowDelayedTaskList>
 896:	80 91 51 06 	lds	r24, 0x0651	; 0x800651 <xNumOfOverflows>
 89a:	8f 5f       	subi	r24, 0xFF	; 255
 89c:	80 93 51 06 	sts	0x0651, r24	; 0x800651 <xNumOfOverflows>
 8a0:	e0 91 66 06 	lds	r30, 0x0666	; 0x800666 <pxDelayedTaskList>
 8a4:	f0 91 67 06 	lds	r31, 0x0667	; 0x800667 <pxDelayedTaskList+0x1>
 8a8:	80 81       	ld	r24, Z
 8aa:	81 11       	cpse	r24, r1
 8ac:	07 c0       	rjmp	.+14     	; 0x8bc <__stack+0x5d>
 8ae:	8f ef       	ldi	r24, 0xFF	; 255
 8b0:	9f ef       	ldi	r25, 0xFF	; 255
 8b2:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 8b6:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 8ba:	10 c0       	rjmp	.+32     	; 0x8dc <__stack+0x7d>
 8bc:	e0 91 66 06 	lds	r30, 0x0666	; 0x800666 <pxDelayedTaskList>
 8c0:	f0 91 67 06 	lds	r31, 0x0667	; 0x800667 <pxDelayedTaskList+0x1>
 8c4:	05 80       	ldd	r0, Z+5	; 0x05
 8c6:	f6 81       	ldd	r31, Z+6	; 0x06
 8c8:	e0 2d       	mov	r30, r0
 8ca:	06 80       	ldd	r0, Z+6	; 0x06
 8cc:	f7 81       	ldd	r31, Z+7	; 0x07
 8ce:	e0 2d       	mov	r30, r0
 8d0:	82 81       	ldd	r24, Z+2	; 0x02
 8d2:	93 81       	ldd	r25, Z+3	; 0x03
 8d4:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 8d8:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 8dc:	20 91 58 06 	lds	r18, 0x0658	; 0x800658 <xTickCount>
 8e0:	30 91 59 06 	lds	r19, 0x0659	; 0x800659 <xTickCount+0x1>
 8e4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
 8e8:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
 8ec:	28 17       	cp	r18, r24
 8ee:	39 07       	cpc	r19, r25
 8f0:	08 f4       	brcc	.+2      	; 0x8f4 <__stack+0x95>
 8f2:	69 c0       	rjmp	.+210    	; 0x9c6 <__stack+0x167>
 8f4:	e0 91 66 06 	lds	r30, 0x0666	; 0x800666 <pxDelayedTaskList>
 8f8:	f0 91 67 06 	lds	r31, 0x0667	; 0x800667 <pxDelayedTaskList+0x1>
 8fc:	80 81       	ld	r24, Z
 8fe:	88 23       	and	r24, r24
 900:	99 f0       	breq	.+38     	; 0x928 <__stack+0xc9>
 902:	e0 91 66 06 	lds	r30, 0x0666	; 0x800666 <pxDelayedTaskList>
 906:	f0 91 67 06 	lds	r31, 0x0667	; 0x800667 <pxDelayedTaskList+0x1>
 90a:	05 80       	ldd	r0, Z+5	; 0x05
 90c:	f6 81       	ldd	r31, Z+6	; 0x06
 90e:	e0 2d       	mov	r30, r0
 910:	c6 81       	ldd	r28, Z+6	; 0x06
 912:	d7 81       	ldd	r29, Z+7	; 0x07
 914:	8a 81       	ldd	r24, Y+2	; 0x02
 916:	9b 81       	ldd	r25, Y+3	; 0x03
 918:	20 91 58 06 	lds	r18, 0x0658	; 0x800658 <xTickCount>
 91c:	30 91 59 06 	lds	r19, 0x0659	; 0x800659 <xTickCount+0x1>
 920:	28 17       	cp	r18, r24
 922:	39 07       	cpc	r19, r25
 924:	f8 f4       	brcc	.+62     	; 0x964 <__stack+0x105>
 926:	19 c0       	rjmp	.+50     	; 0x95a <__stack+0xfb>
 928:	8f ef       	ldi	r24, 0xFF	; 255
 92a:	9f ef       	ldi	r25, 0xFF	; 255
 92c:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 930:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 934:	48 c0       	rjmp	.+144    	; 0x9c6 <__stack+0x167>
 936:	e0 91 66 06 	lds	r30, 0x0666	; 0x800666 <pxDelayedTaskList>
 93a:	f0 91 67 06 	lds	r31, 0x0667	; 0x800667 <pxDelayedTaskList+0x1>
 93e:	05 80       	ldd	r0, Z+5	; 0x05
 940:	f6 81       	ldd	r31, Z+6	; 0x06
 942:	e0 2d       	mov	r30, r0
 944:	c6 81       	ldd	r28, Z+6	; 0x06
 946:	d7 81       	ldd	r29, Z+7	; 0x07
 948:	8a 81       	ldd	r24, Y+2	; 0x02
 94a:	9b 81       	ldd	r25, Y+3	; 0x03
 94c:	20 91 58 06 	lds	r18, 0x0658	; 0x800658 <xTickCount>
 950:	30 91 59 06 	lds	r19, 0x0659	; 0x800659 <xTickCount+0x1>
 954:	28 17       	cp	r18, r24
 956:	39 07       	cpc	r19, r25
 958:	28 f4       	brcc	.+10     	; 0x964 <__stack+0x105>
 95a:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 95e:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 962:	31 c0       	rjmp	.+98     	; 0x9c6 <__stack+0x167>
 964:	8e 01       	movw	r16, r28
 966:	0e 5f       	subi	r16, 0xFE	; 254
 968:	1f 4f       	sbci	r17, 0xFF	; 255
 96a:	c8 01       	movw	r24, r16
 96c:	0e 94 16 01 	call	0x22c	; 0x22c <vListRemove>
 970:	8c 89       	ldd	r24, Y+20	; 0x14
 972:	9d 89       	ldd	r25, Y+21	; 0x15
 974:	89 2b       	or	r24, r25
 976:	21 f0       	breq	.+8      	; 0x980 <__stack+0x121>
 978:	ce 01       	movw	r24, r28
 97a:	0c 96       	adiw	r24, 0x0c	; 12
 97c:	0e 94 16 01 	call	0x22c	; 0x22c <vListRemove>
 980:	2e 89       	ldd	r18, Y+22	; 0x16
 982:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxTopReadyPriority>
 986:	82 17       	cp	r24, r18
 988:	10 f4       	brcc	.+4      	; 0x98e <__stack+0x12f>
 98a:	20 93 56 06 	sts	0x0656, r18	; 0x800656 <uxTopReadyPriority>
 98e:	30 e0       	ldi	r19, 0x00	; 0
 990:	c9 01       	movw	r24, r18
 992:	88 0f       	add	r24, r24
 994:	99 1f       	adc	r25, r25
 996:	88 0f       	add	r24, r24
 998:	99 1f       	adc	r25, r25
 99a:	88 0f       	add	r24, r24
 99c:	99 1f       	adc	r25, r25
 99e:	82 0f       	add	r24, r18
 9a0:	93 1f       	adc	r25, r19
 9a2:	b8 01       	movw	r22, r16
 9a4:	86 58       	subi	r24, 0x86	; 134
 9a6:	99 4f       	sbci	r25, 0xF9	; 249
 9a8:	0e 94 b4 00 	call	0x168	; 0x168 <vListInsertEnd>
 9ac:	e0 91 66 06 	lds	r30, 0x0666	; 0x800666 <pxDelayedTaskList>
 9b0:	f0 91 67 06 	lds	r31, 0x0667	; 0x800667 <pxDelayedTaskList+0x1>
 9b4:	80 81       	ld	r24, Z
 9b6:	81 11       	cpse	r24, r1
 9b8:	be cf       	rjmp	.-132    	; 0x936 <__stack+0xd7>
 9ba:	b6 cf       	rjmp	.-148    	; 0x928 <__stack+0xc9>
 9bc:	80 91 53 06 	lds	r24, 0x0653	; 0x800653 <uxMissedTicks>
 9c0:	8f 5f       	subi	r24, 0xFF	; 255
 9c2:	80 93 53 06 	sts	0x0653, r24	; 0x800653 <uxMissedTicks>
 9c6:	df 91       	pop	r29
 9c8:	cf 91       	pop	r28
 9ca:	1f 91       	pop	r17
 9cc:	0f 91       	pop	r16
 9ce:	08 95       	ret

000009d0 <xTaskResumeAll>:
 9d0:	cf 92       	push	r12
 9d2:	df 92       	push	r13
 9d4:	ef 92       	push	r14
 9d6:	ff 92       	push	r15
 9d8:	0f 93       	push	r16
 9da:	1f 93       	push	r17
 9dc:	cf 93       	push	r28
 9de:	df 93       	push	r29
 9e0:	0f b6       	in	r0, 0x3f	; 63
 9e2:	f8 94       	cli
 9e4:	0f 92       	push	r0
 9e6:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
 9ea:	81 50       	subi	r24, 0x01	; 1
 9ec:	80 93 54 06 	sts	0x0654, r24	; 0x800654 <uxSchedulerSuspended>
 9f0:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
 9f4:	81 11       	cpse	r24, r1
 9f6:	64 c0       	rjmp	.+200    	; 0xac0 <xTaskResumeAll+0xf0>
 9f8:	80 91 5a 06 	lds	r24, 0x065A	; 0x80065a <uxCurrentNumberOfTasks>
 9fc:	81 11       	cpse	r24, r1
 9fe:	32 c0       	rjmp	.+100    	; 0xa64 <xTaskResumeAll+0x94>
 a00:	62 c0       	rjmp	.+196    	; 0xac6 <xTaskResumeAll+0xf6>
 a02:	d7 01       	movw	r26, r14
 a04:	15 96       	adiw	r26, 0x05	; 5
 a06:	ed 91       	ld	r30, X+
 a08:	fc 91       	ld	r31, X
 a0a:	16 97       	sbiw	r26, 0x06	; 6
 a0c:	c6 81       	ldd	r28, Z+6	; 0x06
 a0e:	d7 81       	ldd	r29, Z+7	; 0x07
 a10:	ce 01       	movw	r24, r28
 a12:	0c 96       	adiw	r24, 0x0c	; 12
 a14:	0e 94 16 01 	call	0x22c	; 0x22c <vListRemove>
 a18:	8e 01       	movw	r16, r28
 a1a:	0e 5f       	subi	r16, 0xFE	; 254
 a1c:	1f 4f       	sbci	r17, 0xFF	; 255
 a1e:	c8 01       	movw	r24, r16
 a20:	0e 94 16 01 	call	0x22c	; 0x22c <vListRemove>
 a24:	2e 89       	ldd	r18, Y+22	; 0x16
 a26:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxTopReadyPriority>
 a2a:	82 17       	cp	r24, r18
 a2c:	10 f4       	brcc	.+4      	; 0xa32 <xTaskResumeAll+0x62>
 a2e:	20 93 56 06 	sts	0x0656, r18	; 0x800656 <uxTopReadyPriority>
 a32:	30 e0       	ldi	r19, 0x00	; 0
 a34:	c9 01       	movw	r24, r18
 a36:	88 0f       	add	r24, r24
 a38:	99 1f       	adc	r25, r25
 a3a:	88 0f       	add	r24, r24
 a3c:	99 1f       	adc	r25, r25
 a3e:	88 0f       	add	r24, r24
 a40:	99 1f       	adc	r25, r25
 a42:	82 0f       	add	r24, r18
 a44:	93 1f       	adc	r25, r19
 a46:	b8 01       	movw	r22, r16
 a48:	86 58       	subi	r24, 0x86	; 134
 a4a:	99 4f       	sbci	r25, 0xF9	; 249
 a4c:	0e 94 b4 00 	call	0x168	; 0x168 <vListInsertEnd>
 a50:	e0 91 83 06 	lds	r30, 0x0683	; 0x800683 <pxCurrentTCB>
 a54:	f0 91 84 06 	lds	r31, 0x0684	; 0x800684 <pxCurrentTCB+0x1>
 a58:	9e 89       	ldd	r25, Y+22	; 0x16
 a5a:	86 89       	ldd	r24, Z+22	; 0x16
 a5c:	98 17       	cp	r25, r24
 a5e:	58 f0       	brcs	.+22     	; 0xa76 <xTaskResumeAll+0xa6>
 a60:	dc 2c       	mov	r13, r12
 a62:	09 c0       	rjmp	.+18     	; 0xa76 <xTaskResumeAll+0xa6>
 a64:	d1 2c       	mov	r13, r1
 a66:	0f 2e       	mov	r0, r31
 a68:	fb e5       	ldi	r31, 0x5B	; 91
 a6a:	ef 2e       	mov	r14, r31
 a6c:	f6 e0       	ldi	r31, 0x06	; 6
 a6e:	ff 2e       	mov	r15, r31
 a70:	f0 2d       	mov	r31, r0
 a72:	cc 24       	eor	r12, r12
 a74:	c3 94       	inc	r12
 a76:	f7 01       	movw	r30, r14
 a78:	80 81       	ld	r24, Z
 a7a:	81 11       	cpse	r24, r1
 a7c:	c2 cf       	rjmp	.-124    	; 0xa02 <xTaskResumeAll+0x32>
 a7e:	80 91 53 06 	lds	r24, 0x0653	; 0x800653 <uxMissedTicks>
 a82:	88 23       	and	r24, r24
 a84:	81 f0       	breq	.+32     	; 0xaa6 <xTaskResumeAll+0xd6>
 a86:	80 91 53 06 	lds	r24, 0x0653	; 0x800653 <uxMissedTicks>
 a8a:	88 23       	and	r24, r24
 a8c:	99 f0       	breq	.+38     	; 0xab4 <xTaskResumeAll+0xe4>
 a8e:	0e 94 24 04 	call	0x848	; 0x848 <vTaskIncrementTick>
 a92:	80 91 53 06 	lds	r24, 0x0653	; 0x800653 <uxMissedTicks>
 a96:	81 50       	subi	r24, 0x01	; 1
 a98:	80 93 53 06 	sts	0x0653, r24	; 0x800653 <uxMissedTicks>
 a9c:	80 91 53 06 	lds	r24, 0x0653	; 0x800653 <uxMissedTicks>
 aa0:	81 11       	cpse	r24, r1
 aa2:	f5 cf       	rjmp	.-22     	; 0xa8e <xTaskResumeAll+0xbe>
 aa4:	07 c0       	rjmp	.+14     	; 0xab4 <xTaskResumeAll+0xe4>
 aa6:	f1 e0       	ldi	r31, 0x01	; 1
 aa8:	df 16       	cp	r13, r31
 aaa:	21 f0       	breq	.+8      	; 0xab4 <xTaskResumeAll+0xe4>
 aac:	80 91 52 06 	lds	r24, 0x0652	; 0x800652 <xMissedYield>
 ab0:	81 30       	cpi	r24, 0x01	; 1
 ab2:	41 f4       	brne	.+16     	; 0xac4 <xTaskResumeAll+0xf4>
 ab4:	10 92 52 06 	sts	0x0652, r1	; 0x800652 <xMissedYield>
 ab8:	0e 94 dd 01 	call	0x3ba	; 0x3ba <vPortYield>
 abc:	81 e0       	ldi	r24, 0x01	; 1
 abe:	03 c0       	rjmp	.+6      	; 0xac6 <xTaskResumeAll+0xf6>
 ac0:	80 e0       	ldi	r24, 0x00	; 0
 ac2:	01 c0       	rjmp	.+2      	; 0xac6 <xTaskResumeAll+0xf6>
 ac4:	80 e0       	ldi	r24, 0x00	; 0
 ac6:	0f 90       	pop	r0
 ac8:	0f be       	out	0x3f, r0	; 63
 aca:	df 91       	pop	r29
 acc:	cf 91       	pop	r28
 ace:	1f 91       	pop	r17
 ad0:	0f 91       	pop	r16
 ad2:	ff 90       	pop	r15
 ad4:	ef 90       	pop	r14
 ad6:	df 90       	pop	r13
 ad8:	cf 90       	pop	r12
 ada:	08 95       	ret

00000adc <vTaskDelayUntil>:
 adc:	0f 93       	push	r16
 ade:	1f 93       	push	r17
 ae0:	cf 93       	push	r28
 ae2:	df 93       	push	r29
 ae4:	8c 01       	movw	r16, r24
 ae6:	eb 01       	movw	r28, r22
 ae8:	0e 94 14 04 	call	0x828	; 0x828 <vTaskSuspendAll>
 aec:	f8 01       	movw	r30, r16
 aee:	20 81       	ld	r18, Z
 af0:	31 81       	ldd	r19, Z+1	; 0x01
 af2:	c2 0f       	add	r28, r18
 af4:	d3 1f       	adc	r29, r19
 af6:	40 91 58 06 	lds	r20, 0x0658	; 0x800658 <xTickCount>
 afa:	50 91 59 06 	lds	r21, 0x0659	; 0x800659 <xTickCount+0x1>
 afe:	42 17       	cp	r20, r18
 b00:	53 07       	cpc	r21, r19
 b02:	68 f4       	brcc	.+26     	; 0xb1e <vTaskDelayUntil+0x42>
 b04:	c2 17       	cp	r28, r18
 b06:	d3 07       	cpc	r29, r19
 b08:	50 f5       	brcc	.+84     	; 0xb5e <vTaskDelayUntil+0x82>
 b0a:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <xTickCount>
 b0e:	90 91 59 06 	lds	r25, 0x0659	; 0x800659 <xTickCount+0x1>
 b12:	d1 83       	std	Z+1, r29	; 0x01
 b14:	c0 83       	st	Z, r28
 b16:	8c 17       	cp	r24, r28
 b18:	9d 07       	cpc	r25, r29
 b1a:	b0 f4       	brcc	.+44     	; 0xb48 <vTaskDelayUntil+0x6c>
 b1c:	0b c0       	rjmp	.+22     	; 0xb34 <vTaskDelayUntil+0x58>
 b1e:	c2 17       	cp	r28, r18
 b20:	d3 07       	cpc	r29, r19
 b22:	c8 f0       	brcs	.+50     	; 0xb56 <vTaskDelayUntil+0x7a>
 b24:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <xTickCount>
 b28:	90 91 59 06 	lds	r25, 0x0659	; 0x800659 <xTickCount+0x1>
 b2c:	8c 17       	cp	r24, r28
 b2e:	9d 07       	cpc	r25, r29
 b30:	90 f0       	brcs	.+36     	; 0xb56 <vTaskDelayUntil+0x7a>
 b32:	15 c0       	rjmp	.+42     	; 0xb5e <vTaskDelayUntil+0x82>
 b34:	80 91 83 06 	lds	r24, 0x0683	; 0x800683 <pxCurrentTCB>
 b38:	90 91 84 06 	lds	r25, 0x0684	; 0x800684 <pxCurrentTCB+0x1>
 b3c:	02 96       	adiw	r24, 0x02	; 2
 b3e:	0e 94 16 01 	call	0x22c	; 0x22c <vListRemove>
 b42:	ce 01       	movw	r24, r28
 b44:	0e 94 c3 02 	call	0x586	; 0x586 <prvAddCurrentTaskToDelayedList>
 b48:	0e 94 e8 04 	call	0x9d0	; 0x9d0 <xTaskResumeAll>
 b4c:	81 11       	cpse	r24, r1
 b4e:	0b c0       	rjmp	.+22     	; 0xb66 <vTaskDelayUntil+0x8a>
 b50:	0e 94 dd 01 	call	0x3ba	; 0x3ba <vPortYield>
 b54:	08 c0       	rjmp	.+16     	; 0xb66 <vTaskDelayUntil+0x8a>
 b56:	f8 01       	movw	r30, r16
 b58:	d1 83       	std	Z+1, r29	; 0x01
 b5a:	c0 83       	st	Z, r28
 b5c:	eb cf       	rjmp	.-42     	; 0xb34 <vTaskDelayUntil+0x58>
 b5e:	f8 01       	movw	r30, r16
 b60:	d1 83       	std	Z+1, r29	; 0x01
 b62:	c0 83       	st	Z, r28
 b64:	f1 cf       	rjmp	.-30     	; 0xb48 <vTaskDelayUntil+0x6c>
 b66:	df 91       	pop	r29
 b68:	cf 91       	pop	r28
 b6a:	1f 91       	pop	r17
 b6c:	0f 91       	pop	r16
 b6e:	08 95       	ret

00000b70 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 b70:	80 91 54 06 	lds	r24, 0x0654	; 0x800654 <uxSchedulerSuspended>
 b74:	81 11       	cpse	r24, r1
 b76:	13 c0       	rjmp	.+38     	; 0xb9e <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 b78:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxTopReadyPriority>
 b7c:	90 e0       	ldi	r25, 0x00	; 0
 b7e:	fc 01       	movw	r30, r24
 b80:	ee 0f       	add	r30, r30
 b82:	ff 1f       	adc	r31, r31
 b84:	ee 0f       	add	r30, r30
 b86:	ff 1f       	adc	r31, r31
 b88:	ee 0f       	add	r30, r30
 b8a:	ff 1f       	adc	r31, r31
 b8c:	8e 0f       	add	r24, r30
 b8e:	9f 1f       	adc	r25, r31
 b90:	fc 01       	movw	r30, r24
 b92:	e6 58       	subi	r30, 0x86	; 134
 b94:	f9 4f       	sbci	r31, 0xF9	; 249
 b96:	80 81       	ld	r24, Z
 b98:	88 23       	and	r24, r24
 b9a:	29 f0       	breq	.+10     	; 0xba6 <vTaskSwitchContext+0x36>
 b9c:	1b c0       	rjmp	.+54     	; 0xbd4 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 b9e:	81 e0       	ldi	r24, 0x01	; 1
 ba0:	80 93 52 06 	sts	0x0652, r24	; 0x800652 <xMissedYield>
 ba4:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 ba6:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxTopReadyPriority>
 baa:	81 50       	subi	r24, 0x01	; 1
 bac:	80 93 56 06 	sts	0x0656, r24	; 0x800656 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 bb0:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxTopReadyPriority>
 bb4:	90 e0       	ldi	r25, 0x00	; 0
 bb6:	fc 01       	movw	r30, r24
 bb8:	ee 0f       	add	r30, r30
 bba:	ff 1f       	adc	r31, r31
 bbc:	ee 0f       	add	r30, r30
 bbe:	ff 1f       	adc	r31, r31
 bc0:	ee 0f       	add	r30, r30
 bc2:	ff 1f       	adc	r31, r31
 bc4:	8e 0f       	add	r24, r30
 bc6:	9f 1f       	adc	r25, r31
 bc8:	fc 01       	movw	r30, r24
 bca:	e6 58       	subi	r30, 0x86	; 134
 bcc:	f9 4f       	sbci	r31, 0xF9	; 249
 bce:	80 81       	ld	r24, Z
 bd0:	88 23       	and	r24, r24
 bd2:	49 f3       	breq	.-46     	; 0xba6 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 bd4:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <uxTopReadyPriority>
 bd8:	90 e0       	ldi	r25, 0x00	; 0
 bda:	9c 01       	movw	r18, r24
 bdc:	22 0f       	add	r18, r18
 bde:	33 1f       	adc	r19, r19
 be0:	22 0f       	add	r18, r18
 be2:	33 1f       	adc	r19, r19
 be4:	22 0f       	add	r18, r18
 be6:	33 1f       	adc	r19, r19
 be8:	28 0f       	add	r18, r24
 bea:	39 1f       	adc	r19, r25
 bec:	d9 01       	movw	r26, r18
 bee:	a6 58       	subi	r26, 0x86	; 134
 bf0:	b9 4f       	sbci	r27, 0xF9	; 249
 bf2:	11 96       	adiw	r26, 0x01	; 1
 bf4:	ed 91       	ld	r30, X+
 bf6:	fc 91       	ld	r31, X
 bf8:	12 97       	sbiw	r26, 0x02	; 2
 bfa:	02 80       	ldd	r0, Z+2	; 0x02
 bfc:	f3 81       	ldd	r31, Z+3	; 0x03
 bfe:	e0 2d       	mov	r30, r0
 c00:	12 96       	adiw	r26, 0x02	; 2
 c02:	fc 93       	st	X, r31
 c04:	ee 93       	st	-X, r30
 c06:	11 97       	sbiw	r26, 0x01	; 1
 c08:	23 58       	subi	r18, 0x83	; 131
 c0a:	39 4f       	sbci	r19, 0xF9	; 249
 c0c:	e2 17       	cp	r30, r18
 c0e:	f3 07       	cpc	r31, r19
 c10:	29 f4       	brne	.+10     	; 0xc1c <vTaskSwitchContext+0xac>
 c12:	22 81       	ldd	r18, Z+2	; 0x02
 c14:	33 81       	ldd	r19, Z+3	; 0x03
 c16:	fd 01       	movw	r30, r26
 c18:	32 83       	std	Z+2, r19	; 0x02
 c1a:	21 83       	std	Z+1, r18	; 0x01
 c1c:	fc 01       	movw	r30, r24
 c1e:	ee 0f       	add	r30, r30
 c20:	ff 1f       	adc	r31, r31
 c22:	ee 0f       	add	r30, r30
 c24:	ff 1f       	adc	r31, r31
 c26:	ee 0f       	add	r30, r30
 c28:	ff 1f       	adc	r31, r31
 c2a:	8e 0f       	add	r24, r30
 c2c:	9f 1f       	adc	r25, r31
 c2e:	fc 01       	movw	r30, r24
 c30:	e6 58       	subi	r30, 0x86	; 134
 c32:	f9 4f       	sbci	r31, 0xF9	; 249
 c34:	01 80       	ldd	r0, Z+1	; 0x01
 c36:	f2 81       	ldd	r31, Z+2	; 0x02
 c38:	e0 2d       	mov	r30, r0
 c3a:	86 81       	ldd	r24, Z+6	; 0x06
 c3c:	97 81       	ldd	r25, Z+7	; 0x07
 c3e:	90 93 84 06 	sts	0x0684, r25	; 0x800684 <pxCurrentTCB+0x1>
 c42:	80 93 83 06 	sts	0x0683, r24	; 0x800683 <pxCurrentTCB>
 c46:	08 95       	ret

00000c48 <memset>:
 c48:	dc 01       	movw	r26, r24
 c4a:	01 c0       	rjmp	.+2      	; 0xc4e <memset+0x6>
 c4c:	6d 93       	st	X+, r22
 c4e:	41 50       	subi	r20, 0x01	; 1
 c50:	50 40       	sbci	r21, 0x00	; 0
 c52:	e0 f7       	brcc	.-8      	; 0xc4c <memset+0x4>
 c54:	08 95       	ret

00000c56 <strncpy>:
 c56:	fb 01       	movw	r30, r22
 c58:	dc 01       	movw	r26, r24
 c5a:	41 50       	subi	r20, 0x01	; 1
 c5c:	50 40       	sbci	r21, 0x00	; 0
 c5e:	48 f0       	brcs	.+18     	; 0xc72 <strncpy+0x1c>
 c60:	01 90       	ld	r0, Z+
 c62:	0d 92       	st	X+, r0
 c64:	00 20       	and	r0, r0
 c66:	c9 f7       	brne	.-14     	; 0xc5a <strncpy+0x4>
 c68:	01 c0       	rjmp	.+2      	; 0xc6c <strncpy+0x16>
 c6a:	1d 92       	st	X+, r1
 c6c:	41 50       	subi	r20, 0x01	; 1
 c6e:	50 40       	sbci	r21, 0x00	; 0
 c70:	e0 f7       	brcc	.-8      	; 0xc6a <strncpy+0x14>
 c72:	08 95       	ret

00000c74 <_exit>:
 c74:	f8 94       	cli

00000c76 <__stop_program>:
 c76:	ff cf       	rjmp	.-2      	; 0xc76 <__stop_program>
