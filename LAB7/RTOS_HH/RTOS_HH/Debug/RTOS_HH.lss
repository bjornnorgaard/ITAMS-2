
RTOS_HH.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000cb2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000016  00800060  00000cb2  00000d46  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000613  00800076  00800076  00000d5c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d5c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000d8c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001e8  00000000  00000000  00000dc8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002112  00000000  00000000  00000fb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d82  00000000  00000000  000030c2  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001106  00000000  00000000  00003e44  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000474  00000000  00000000  00004f4c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000b91  00000000  00000000  000053c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000012b3  00000000  00000000  00005f51  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001d0  00000000  00000000  00007204  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 ae 02 	jmp	0x55c	; 0x55c <__vector_7>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e2 eb       	ldi	r30, 0xB2	; 178
  68:	fc e0       	ldi	r31, 0x0C	; 12
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a6 37       	cpi	r26, 0x76	; 118
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	26 e0       	ldi	r18, 0x06	; 6
  78:	a6 e7       	ldi	r26, 0x76	; 118
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a9 38       	cpi	r26, 0x89	; 137
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 95 00 	call	0x12a	; 0x12a <main>
  8a:	0c 94 57 06 	jmp	0xcae	; 0xcae <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <initLEDport>:
  if (led_nr <= MAX_LED_NR)
  {
    // Create mask based on the parameter (led_nr)
    mask = 0b00000001 << led_nr;
    // Turn OFF the actual LED (the rest are unchanged)
    PORTC = PORTC | mask;
  92:	8f ef       	ldi	r24, 0xFF	; 255
  94:	84 bb       	out	0x14, r24	; 20
  96:	85 bb       	out	0x15, r24	; 21
  98:	08 95       	ret

0000009a <toggleLED>:
void toggleLED(unsigned char led_nr)
{
// Local variable
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
  9a:	88 30       	cpi	r24, 0x08	; 8
  9c:	60 f4       	brcc	.+24     	; 0xb6 <toggleLED+0x1c>
  {
    // Create mask based on the parameter (led_nr)
    mask = 0b00000001 << led_nr;
    // Toggle the actual LED (the rest are unchanged)
    PORTC = PORTC ^ mask;
  9e:	45 b3       	in	r20, 0x15	; 21
unsigned char mask;
  // We only have to do anything, if led_nr < 8
  if (led_nr <= MAX_LED_NR)
  {
    // Create mask based on the parameter (led_nr)
    mask = 0b00000001 << led_nr;
  a0:	21 e0       	ldi	r18, 0x01	; 1
  a2:	30 e0       	ldi	r19, 0x00	; 0
  a4:	b9 01       	movw	r22, r18
  a6:	02 c0       	rjmp	.+4      	; 0xac <toggleLED+0x12>
  a8:	66 0f       	add	r22, r22
  aa:	77 1f       	adc	r23, r23
  ac:	8a 95       	dec	r24
  ae:	e2 f7       	brpl	.-8      	; 0xa8 <toggleLED+0xe>
  b0:	cb 01       	movw	r24, r22
    // Toggle the actual LED (the rest are unchanged)
    PORTC = PORTC ^ mask;
  b2:	84 27       	eor	r24, r20
  b4:	85 bb       	out	0x15, r24	; 21
  b6:	08 95       	ret

000000b8 <vLEDFlashTask1>:
#include "FreeRTOS.h"
#include "task.h"
#include "led.h"

void vLEDFlashTask1( void *pvParameters )
{
  b8:	cf 93       	push	r28
  ba:	df 93       	push	r29
  bc:	00 d0       	rcall	.+0      	; 0xbe <vLEDFlashTask1+0x6>
  be:	cd b7       	in	r28, 0x3d	; 61
  c0:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	xLastWakeTime=xTaskGetTickCount();
  c2:	0e 94 37 04 	call	0x86e	; 0x86e <xTaskGetTickCount>
  c6:	9a 83       	std	Y+2, r25	; 0x02
  c8:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		toggleLED(0);
  ca:	80 e0       	ldi	r24, 0x00	; 0
  cc:	0e 94 4d 00 	call	0x9a	; 0x9a <toggleLED>
		vTaskDelayUntil(&xLastWakeTime,800);
  d0:	60 e2       	ldi	r22, 0x20	; 32
  d2:	73 e0       	ldi	r23, 0x03	; 3
  d4:	ce 01       	movw	r24, r28
  d6:	01 96       	adiw	r24, 0x01	; 1
  d8:	0e 94 8b 05 	call	0xb16	; 0xb16 <vTaskDelayUntil>
	}
  dc:	f6 cf       	rjmp	.-20     	; 0xca <vLEDFlashTask1+0x12>

000000de <vLEDFlashTask2>:
}

void vLEDFlashTask2( void *pvParameters )
{
  de:	cf 93       	push	r28
  e0:	df 93       	push	r29
  e2:	00 d0       	rcall	.+0      	; 0xe4 <vLEDFlashTask2+0x6>
  e4:	cd b7       	in	r28, 0x3d	; 61
  e6:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	xLastWakeTime=xTaskGetTickCount();
  e8:	0e 94 37 04 	call	0x86e	; 0x86e <xTaskGetTickCount>
  ec:	9a 83       	std	Y+2, r25	; 0x02
  ee:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		toggleLED(1);
  f0:	81 e0       	ldi	r24, 0x01	; 1
  f2:	0e 94 4d 00 	call	0x9a	; 0x9a <toggleLED>
		vTaskDelayUntil(&xLastWakeTime,500);
  f6:	64 ef       	ldi	r22, 0xF4	; 244
  f8:	71 e0       	ldi	r23, 0x01	; 1
  fa:	ce 01       	movw	r24, r28
  fc:	01 96       	adiw	r24, 0x01	; 1
  fe:	0e 94 8b 05 	call	0xb16	; 0xb16 <vTaskDelayUntil>
	}
 102:	f6 cf       	rjmp	.-20     	; 0xf0 <vLEDFlashTask2+0x12>

00000104 <vLEDFlashTask3>:
}

void vLEDFlashTask3(void *pvParameters )
{
 104:	cf 93       	push	r28
 106:	df 93       	push	r29
 108:	00 d0       	rcall	.+0      	; 0x10a <vLEDFlashTask3+0x6>
 10a:	cd b7       	in	r28, 0x3d	; 61
 10c:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime = xTaskGetTickCount();
 10e:	0e 94 37 04 	call	0x86e	; 0x86e <xTaskGetTickCount>
 112:	9a 83       	std	Y+2, r25	; 0x02
 114:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{
		toggleLED(2);
 116:	82 e0       	ldi	r24, 0x02	; 2
 118:	0e 94 4d 00 	call	0x9a	; 0x9a <toggleLED>
		vTaskDelayUntil(&xLastWakeTime,200);
 11c:	68 ec       	ldi	r22, 0xC8	; 200
 11e:	70 e0       	ldi	r23, 0x00	; 0
 120:	ce 01       	movw	r24, r28
 122:	01 96       	adiw	r24, 0x01	; 1
 124:	0e 94 8b 05 	call	0xb16	; 0xb16 <vTaskDelayUntil>
	}
 128:	f6 cf       	rjmp	.-20     	; 0x116 <vLEDFlashTask3+0x12>

0000012a <main>:
}

int main(void)
{
	initLEDport();
 12a:	0e 94 49 00 	call	0x92	; 0x92 <initLEDport>
	xTaskCreate( vLEDFlashTask1, (signed char * ) "LED1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
 12e:	a1 2c       	mov	r10, r1
 130:	b1 2c       	mov	r11, r1
 132:	c1 2c       	mov	r12, r1
 134:	d1 2c       	mov	r13, r1
 136:	e1 2c       	mov	r14, r1
 138:	f1 2c       	mov	r15, r1
 13a:	00 e0       	ldi	r16, 0x00	; 0
 13c:	20 e0       	ldi	r18, 0x00	; 0
 13e:	30 e0       	ldi	r19, 0x00	; 0
 140:	45 e5       	ldi	r20, 0x55	; 85
 142:	50 e0       	ldi	r21, 0x00	; 0
 144:	62 e6       	ldi	r22, 0x62	; 98
 146:	70 e0       	ldi	r23, 0x00	; 0
 148:	8c e5       	ldi	r24, 0x5C	; 92
 14a:	90 e0       	ldi	r25, 0x00	; 0
 14c:	0e 94 17 03 	call	0x62e	; 0x62e <xTaskGenericCreate>
	xTaskCreate( vLEDFlashTask2, (signed char * ) "LED2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
 150:	20 e0       	ldi	r18, 0x00	; 0
 152:	30 e0       	ldi	r19, 0x00	; 0
 154:	45 e5       	ldi	r20, 0x55	; 85
 156:	50 e0       	ldi	r21, 0x00	; 0
 158:	67 e6       	ldi	r22, 0x67	; 103
 15a:	70 e0       	ldi	r23, 0x00	; 0
 15c:	8f e6       	ldi	r24, 0x6F	; 111
 15e:	90 e0       	ldi	r25, 0x00	; 0
 160:	0e 94 17 03 	call	0x62e	; 0x62e <xTaskGenericCreate>
	xTaskCreate( vLEDFlashTask3, (signed char * ) "LED3", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
 164:	20 e0       	ldi	r18, 0x00	; 0
 166:	30 e0       	ldi	r19, 0x00	; 0
 168:	45 e5       	ldi	r20, 0x55	; 85
 16a:	50 e0       	ldi	r21, 0x00	; 0
 16c:	6c e6       	ldi	r22, 0x6C	; 108
 16e:	70 e0       	ldi	r23, 0x00	; 0
 170:	82 e8       	ldi	r24, 0x82	; 130
 172:	90 e0       	ldi	r25, 0x00	; 0
 174:	0e 94 17 03 	call	0x62e	; 0x62e <xTaskGenericCreate>
	vTaskStartScheduler();
 178:	0e 94 06 04 	call	0x80c	; 0x80c <vTaskStartScheduler>
	while(1)
	{}
 17c:	ff cf       	rjmp	.-2      	; 0x17c <main+0x52>

0000017e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
 17e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
 180:	03 96       	adiw	r24, 0x03	; 3
 182:	92 83       	std	Z+2, r25	; 0x02
 184:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 186:	2f ef       	ldi	r18, 0xFF	; 255
 188:	3f ef       	ldi	r19, 0xFF	; 255
 18a:	34 83       	std	Z+4, r19	; 0x04
 18c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
 18e:	96 83       	std	Z+6, r25	; 0x06
 190:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
 192:	90 87       	std	Z+8, r25	; 0x08
 194:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
 196:	10 82       	st	Z, r1
 198:	08 95       	ret

0000019a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 19a:	fc 01       	movw	r30, r24
 19c:	11 86       	std	Z+9, r1	; 0x09
 19e:	10 86       	std	Z+8, r1	; 0x08
 1a0:	08 95       	ret

000001a2 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
 1a2:	cf 93       	push	r28
 1a4:	df 93       	push	r29
 1a6:	fc 01       	movw	r30, r24
 1a8:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
 1aa:	21 81       	ldd	r18, Z+1	; 0x01
 1ac:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
 1ae:	e9 01       	movw	r28, r18
 1b0:	8a 81       	ldd	r24, Y+2	; 0x02
 1b2:	9b 81       	ldd	r25, Y+3	; 0x03
 1b4:	13 96       	adiw	r26, 0x03	; 3
 1b6:	9c 93       	st	X, r25
 1b8:	8e 93       	st	-X, r24
 1ba:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
 1bc:	81 81       	ldd	r24, Z+1	; 0x01
 1be:	92 81       	ldd	r25, Z+2	; 0x02
 1c0:	15 96       	adiw	r26, 0x05	; 5
 1c2:	9c 93       	st	X, r25
 1c4:	8e 93       	st	-X, r24
 1c6:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 1c8:	8a 81       	ldd	r24, Y+2	; 0x02
 1ca:	9b 81       	ldd	r25, Y+3	; 0x03
 1cc:	ec 01       	movw	r28, r24
 1ce:	7d 83       	std	Y+5, r23	; 0x05
 1d0:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
 1d2:	e9 01       	movw	r28, r18
 1d4:	7b 83       	std	Y+3, r23	; 0x03
 1d6:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
 1d8:	72 83       	std	Z+2, r23	; 0x02
 1da:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1dc:	19 96       	adiw	r26, 0x09	; 9
 1de:	fc 93       	st	X, r31
 1e0:	ee 93       	st	-X, r30
 1e2:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
 1e4:	80 81       	ld	r24, Z
 1e6:	8f 5f       	subi	r24, 0xFF	; 255
 1e8:	80 83       	st	Z, r24
}
 1ea:	df 91       	pop	r29
 1ec:	cf 91       	pop	r28
 1ee:	08 95       	ret

000001f0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
 1f0:	cf 93       	push	r28
 1f2:	df 93       	push	r29
 1f4:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
 1f6:	48 81       	ld	r20, Y
 1f8:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 1fa:	4f 3f       	cpi	r20, 0xFF	; 255
 1fc:	2f ef       	ldi	r18, 0xFF	; 255
 1fe:	52 07       	cpc	r21, r18
 200:	31 f4       	brne	.+12     	; 0x20e <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 202:	dc 01       	movw	r26, r24
 204:	17 96       	adiw	r26, 0x07	; 7
 206:	ed 91       	ld	r30, X+
 208:	fc 91       	ld	r31, X
 20a:	18 97       	sbiw	r26, 0x08	; 8
 20c:	17 c0       	rjmp	.+46     	; 0x23c <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
 20e:	fc 01       	movw	r30, r24
 210:	33 96       	adiw	r30, 0x03	; 3
 212:	dc 01       	movw	r26, r24
 214:	15 96       	adiw	r26, 0x05	; 5
 216:	2d 91       	ld	r18, X+
 218:	3c 91       	ld	r19, X
 21a:	16 97       	sbiw	r26, 0x06	; 6
 21c:	d9 01       	movw	r26, r18
 21e:	2d 91       	ld	r18, X+
 220:	3c 91       	ld	r19, X
 222:	42 17       	cp	r20, r18
 224:	53 07       	cpc	r21, r19
 226:	50 f0       	brcs	.+20     	; 0x23c <vListInsert+0x4c>
 228:	02 80       	ldd	r0, Z+2	; 0x02
 22a:	f3 81       	ldd	r31, Z+3	; 0x03
 22c:	e0 2d       	mov	r30, r0
 22e:	a2 81       	ldd	r26, Z+2	; 0x02
 230:	b3 81       	ldd	r27, Z+3	; 0x03
 232:	2d 91       	ld	r18, X+
 234:	3c 91       	ld	r19, X
 236:	42 17       	cp	r20, r18
 238:	53 07       	cpc	r21, r19
 23a:	b0 f7       	brcc	.-20     	; 0x228 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 23c:	a2 81       	ldd	r26, Z+2	; 0x02
 23e:	b3 81       	ldd	r27, Z+3	; 0x03
 240:	bb 83       	std	Y+3, r27	; 0x03
 242:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
 244:	15 96       	adiw	r26, 0x05	; 5
 246:	dc 93       	st	X, r29
 248:	ce 93       	st	-X, r28
 24a:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
 24c:	fd 83       	std	Y+5, r31	; 0x05
 24e:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
 250:	d3 83       	std	Z+3, r29	; 0x03
 252:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 254:	99 87       	std	Y+9, r25	; 0x09
 256:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 258:	fc 01       	movw	r30, r24
 25a:	20 81       	ld	r18, Z
 25c:	2f 5f       	subi	r18, 0xFF	; 255
 25e:	20 83       	st	Z, r18
}
 260:	df 91       	pop	r29
 262:	cf 91       	pop	r28
 264:	08 95       	ret

00000266 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
 266:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 268:	a2 81       	ldd	r26, Z+2	; 0x02
 26a:	b3 81       	ldd	r27, Z+3	; 0x03
 26c:	84 81       	ldd	r24, Z+4	; 0x04
 26e:	95 81       	ldd	r25, Z+5	; 0x05
 270:	15 96       	adiw	r26, 0x05	; 5
 272:	9c 93       	st	X, r25
 274:	8e 93       	st	-X, r24
 276:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 278:	a4 81       	ldd	r26, Z+4	; 0x04
 27a:	b5 81       	ldd	r27, Z+5	; 0x05
 27c:	82 81       	ldd	r24, Z+2	; 0x02
 27e:	93 81       	ldd	r25, Z+3	; 0x03
 280:	13 96       	adiw	r26, 0x03	; 3
 282:	9c 93       	st	X, r25
 284:	8e 93       	st	-X, r24
 286:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
 288:	a0 85       	ldd	r26, Z+8	; 0x08
 28a:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 28c:	11 96       	adiw	r26, 0x01	; 1
 28e:	8d 91       	ld	r24, X+
 290:	9c 91       	ld	r25, X
 292:	12 97       	sbiw	r26, 0x02	; 2
 294:	8e 17       	cp	r24, r30
 296:	9f 07       	cpc	r25, r31
 298:	31 f4       	brne	.+12     	; 0x2a6 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 29a:	84 81       	ldd	r24, Z+4	; 0x04
 29c:	95 81       	ldd	r25, Z+5	; 0x05
 29e:	12 96       	adiw	r26, 0x02	; 2
 2a0:	9c 93       	st	X, r25
 2a2:	8e 93       	st	-X, r24
 2a4:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
 2a6:	11 86       	std	Z+9, r1	; 0x09
 2a8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 2aa:	8c 91       	ld	r24, X
 2ac:	81 50       	subi	r24, 0x01	; 1
 2ae:	8c 93       	st	X, r24
 2b0:	08 95       	ret

000002b2 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 2b2:	31 e1       	ldi	r19, 0x11	; 17
 2b4:	fc 01       	movw	r30, r24
 2b6:	30 83       	st	Z, r19
 2b8:	31 97       	sbiw	r30, 0x01	; 1
 2ba:	22 e2       	ldi	r18, 0x22	; 34
 2bc:	20 83       	st	Z, r18
 2be:	31 97       	sbiw	r30, 0x01	; 1
 2c0:	a3 e3       	ldi	r26, 0x33	; 51
 2c2:	a0 83       	st	Z, r26
 2c4:	31 97       	sbiw	r30, 0x01	; 1
 2c6:	60 83       	st	Z, r22
 2c8:	31 97       	sbiw	r30, 0x01	; 1
 2ca:	70 83       	st	Z, r23
 2cc:	31 97       	sbiw	r30, 0x01	; 1
 2ce:	10 82       	st	Z, r1
 2d0:	31 97       	sbiw	r30, 0x01	; 1
 2d2:	60 e8       	ldi	r22, 0x80	; 128
 2d4:	60 83       	st	Z, r22
 2d6:	31 97       	sbiw	r30, 0x01	; 1
 2d8:	10 82       	st	Z, r1
 2da:	31 97       	sbiw	r30, 0x01	; 1
 2dc:	62 e0       	ldi	r22, 0x02	; 2
 2de:	60 83       	st	Z, r22
 2e0:	31 97       	sbiw	r30, 0x01	; 1
 2e2:	63 e0       	ldi	r22, 0x03	; 3
 2e4:	60 83       	st	Z, r22
 2e6:	31 97       	sbiw	r30, 0x01	; 1
 2e8:	64 e0       	ldi	r22, 0x04	; 4
 2ea:	60 83       	st	Z, r22
 2ec:	31 97       	sbiw	r30, 0x01	; 1
 2ee:	65 e0       	ldi	r22, 0x05	; 5
 2f0:	60 83       	st	Z, r22
 2f2:	31 97       	sbiw	r30, 0x01	; 1
 2f4:	66 e0       	ldi	r22, 0x06	; 6
 2f6:	60 83       	st	Z, r22
 2f8:	31 97       	sbiw	r30, 0x01	; 1
 2fa:	67 e0       	ldi	r22, 0x07	; 7
 2fc:	60 83       	st	Z, r22
 2fe:	31 97       	sbiw	r30, 0x01	; 1
 300:	68 e0       	ldi	r22, 0x08	; 8
 302:	60 83       	st	Z, r22
 304:	31 97       	sbiw	r30, 0x01	; 1
 306:	69 e0       	ldi	r22, 0x09	; 9
 308:	60 83       	st	Z, r22
 30a:	31 97       	sbiw	r30, 0x01	; 1
 30c:	60 e1       	ldi	r22, 0x10	; 16
 30e:	60 83       	st	Z, r22
 310:	31 97       	sbiw	r30, 0x01	; 1
 312:	30 83       	st	Z, r19
 314:	31 97       	sbiw	r30, 0x01	; 1
 316:	32 e1       	ldi	r19, 0x12	; 18
 318:	30 83       	st	Z, r19
 31a:	31 97       	sbiw	r30, 0x01	; 1
 31c:	33 e1       	ldi	r19, 0x13	; 19
 31e:	30 83       	st	Z, r19
 320:	31 97       	sbiw	r30, 0x01	; 1
 322:	34 e1       	ldi	r19, 0x14	; 20
 324:	30 83       	st	Z, r19
 326:	31 97       	sbiw	r30, 0x01	; 1
 328:	35 e1       	ldi	r19, 0x15	; 21
 32a:	30 83       	st	Z, r19
 32c:	31 97       	sbiw	r30, 0x01	; 1
 32e:	36 e1       	ldi	r19, 0x16	; 22
 330:	30 83       	st	Z, r19
 332:	31 97       	sbiw	r30, 0x01	; 1
 334:	37 e1       	ldi	r19, 0x17	; 23
 336:	30 83       	st	Z, r19
 338:	31 97       	sbiw	r30, 0x01	; 1
 33a:	38 e1       	ldi	r19, 0x18	; 24
 33c:	30 83       	st	Z, r19
 33e:	31 97       	sbiw	r30, 0x01	; 1
 340:	39 e1       	ldi	r19, 0x19	; 25
 342:	30 83       	st	Z, r19
 344:	31 97       	sbiw	r30, 0x01	; 1
 346:	30 e2       	ldi	r19, 0x20	; 32
 348:	30 83       	st	Z, r19
 34a:	31 97       	sbiw	r30, 0x01	; 1
 34c:	31 e2       	ldi	r19, 0x21	; 33
 34e:	30 83       	st	Z, r19
 350:	31 97       	sbiw	r30, 0x01	; 1
 352:	20 83       	st	Z, r18
 354:	31 97       	sbiw	r30, 0x01	; 1
 356:	23 e2       	ldi	r18, 0x23	; 35
 358:	20 83       	st	Z, r18
 35a:	31 97       	sbiw	r30, 0x01	; 1
 35c:	40 83       	st	Z, r20
 35e:	31 97       	sbiw	r30, 0x01	; 1
 360:	50 83       	st	Z, r21
 362:	31 97       	sbiw	r30, 0x01	; 1
 364:	26 e2       	ldi	r18, 0x26	; 38
 366:	20 83       	st	Z, r18
 368:	31 97       	sbiw	r30, 0x01	; 1
 36a:	27 e2       	ldi	r18, 0x27	; 39
 36c:	20 83       	st	Z, r18
 36e:	31 97       	sbiw	r30, 0x01	; 1
 370:	28 e2       	ldi	r18, 0x28	; 40
 372:	20 83       	st	Z, r18
 374:	31 97       	sbiw	r30, 0x01	; 1
 376:	29 e2       	ldi	r18, 0x29	; 41
 378:	20 83       	st	Z, r18
 37a:	31 97       	sbiw	r30, 0x01	; 1
 37c:	20 e3       	ldi	r18, 0x30	; 48
 37e:	20 83       	st	Z, r18
 380:	31 97       	sbiw	r30, 0x01	; 1
 382:	21 e3       	ldi	r18, 0x31	; 49
 384:	20 83       	st	Z, r18
 386:	86 97       	sbiw	r24, 0x26	; 38
 388:	08 95       	ret

0000038a <xPortStartScheduler>:
 38a:	1b bc       	out	0x2b, r1	; 43
 38c:	88 e3       	ldi	r24, 0x38	; 56
 38e:	8a bd       	out	0x2a, r24	; 42
 390:	8b e0       	ldi	r24, 0x0B	; 11
 392:	8e bd       	out	0x2e, r24	; 46
 394:	89 b7       	in	r24, 0x39	; 57
 396:	80 61       	ori	r24, 0x10	; 16
 398:	89 bf       	out	0x39, r24	; 57
 39a:	a0 91 87 06 	lds	r26, 0x0687	; 0x800687 <pxCurrentTCB>
 39e:	b0 91 88 06 	lds	r27, 0x0688	; 0x800688 <pxCurrentTCB+0x1>
 3a2:	cd 91       	ld	r28, X+
 3a4:	cd bf       	out	0x3d, r28	; 61
 3a6:	dd 91       	ld	r29, X+
 3a8:	de bf       	out	0x3e, r29	; 62
 3aa:	ff 91       	pop	r31
 3ac:	ef 91       	pop	r30
 3ae:	df 91       	pop	r29
 3b0:	cf 91       	pop	r28
 3b2:	bf 91       	pop	r27
 3b4:	af 91       	pop	r26
 3b6:	9f 91       	pop	r25
 3b8:	8f 91       	pop	r24
 3ba:	7f 91       	pop	r23
 3bc:	6f 91       	pop	r22
 3be:	5f 91       	pop	r21
 3c0:	4f 91       	pop	r20
 3c2:	3f 91       	pop	r19
 3c4:	2f 91       	pop	r18
 3c6:	1f 91       	pop	r17
 3c8:	0f 91       	pop	r16
 3ca:	ff 90       	pop	r15
 3cc:	ef 90       	pop	r14
 3ce:	df 90       	pop	r13
 3d0:	cf 90       	pop	r12
 3d2:	bf 90       	pop	r11
 3d4:	af 90       	pop	r10
 3d6:	9f 90       	pop	r9
 3d8:	8f 90       	pop	r8
 3da:	7f 90       	pop	r7
 3dc:	6f 90       	pop	r6
 3de:	5f 90       	pop	r5
 3e0:	4f 90       	pop	r4
 3e2:	3f 90       	pop	r3
 3e4:	2f 90       	pop	r2
 3e6:	1f 90       	pop	r1
 3e8:	0f 90       	pop	r0
 3ea:	0f be       	out	0x3f, r0	; 63
 3ec:	0f 90       	pop	r0
 3ee:	08 95       	ret
 3f0:	81 e0       	ldi	r24, 0x01	; 1
 3f2:	08 95       	ret

000003f4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 3f4:	0f 92       	push	r0
 3f6:	0f b6       	in	r0, 0x3f	; 63
 3f8:	f8 94       	cli
 3fa:	0f 92       	push	r0
 3fc:	1f 92       	push	r1
 3fe:	11 24       	eor	r1, r1
 400:	2f 92       	push	r2
 402:	3f 92       	push	r3
 404:	4f 92       	push	r4
 406:	5f 92       	push	r5
 408:	6f 92       	push	r6
 40a:	7f 92       	push	r7
 40c:	8f 92       	push	r8
 40e:	9f 92       	push	r9
 410:	af 92       	push	r10
 412:	bf 92       	push	r11
 414:	cf 92       	push	r12
 416:	df 92       	push	r13
 418:	ef 92       	push	r14
 41a:	ff 92       	push	r15
 41c:	0f 93       	push	r16
 41e:	1f 93       	push	r17
 420:	2f 93       	push	r18
 422:	3f 93       	push	r19
 424:	4f 93       	push	r20
 426:	5f 93       	push	r21
 428:	6f 93       	push	r22
 42a:	7f 93       	push	r23
 42c:	8f 93       	push	r24
 42e:	9f 93       	push	r25
 430:	af 93       	push	r26
 432:	bf 93       	push	r27
 434:	cf 93       	push	r28
 436:	df 93       	push	r29
 438:	ef 93       	push	r30
 43a:	ff 93       	push	r31
 43c:	a0 91 87 06 	lds	r26, 0x0687	; 0x800687 <pxCurrentTCB>
 440:	b0 91 88 06 	lds	r27, 0x0688	; 0x800688 <pxCurrentTCB+0x1>
 444:	0d b6       	in	r0, 0x3d	; 61
 446:	0d 92       	st	X+, r0
 448:	0e b6       	in	r0, 0x3e	; 62
 44a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 44c:	0e 94 d5 05 	call	0xbaa	; 0xbaa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 450:	a0 91 87 06 	lds	r26, 0x0687	; 0x800687 <pxCurrentTCB>
 454:	b0 91 88 06 	lds	r27, 0x0688	; 0x800688 <pxCurrentTCB+0x1>
 458:	cd 91       	ld	r28, X+
 45a:	cd bf       	out	0x3d, r28	; 61
 45c:	dd 91       	ld	r29, X+
 45e:	de bf       	out	0x3e, r29	; 62
 460:	ff 91       	pop	r31
 462:	ef 91       	pop	r30
 464:	df 91       	pop	r29
 466:	cf 91       	pop	r28
 468:	bf 91       	pop	r27
 46a:	af 91       	pop	r26
 46c:	9f 91       	pop	r25
 46e:	8f 91       	pop	r24
 470:	7f 91       	pop	r23
 472:	6f 91       	pop	r22
 474:	5f 91       	pop	r21
 476:	4f 91       	pop	r20
 478:	3f 91       	pop	r19
 47a:	2f 91       	pop	r18
 47c:	1f 91       	pop	r17
 47e:	0f 91       	pop	r16
 480:	ff 90       	pop	r15
 482:	ef 90       	pop	r14
 484:	df 90       	pop	r13
 486:	cf 90       	pop	r12
 488:	bf 90       	pop	r11
 48a:	af 90       	pop	r10
 48c:	9f 90       	pop	r9
 48e:	8f 90       	pop	r8
 490:	7f 90       	pop	r7
 492:	6f 90       	pop	r6
 494:	5f 90       	pop	r5
 496:	4f 90       	pop	r4
 498:	3f 90       	pop	r3
 49a:	2f 90       	pop	r2
 49c:	1f 90       	pop	r1
 49e:	0f 90       	pop	r0
 4a0:	0f be       	out	0x3f, r0	; 63
 4a2:	0f 90       	pop	r0

	asm volatile ( "ret" );
 4a4:	08 95       	ret

000004a6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 4a6:	0f 92       	push	r0
 4a8:	0f b6       	in	r0, 0x3f	; 63
 4aa:	f8 94       	cli
 4ac:	0f 92       	push	r0
 4ae:	1f 92       	push	r1
 4b0:	11 24       	eor	r1, r1
 4b2:	2f 92       	push	r2
 4b4:	3f 92       	push	r3
 4b6:	4f 92       	push	r4
 4b8:	5f 92       	push	r5
 4ba:	6f 92       	push	r6
 4bc:	7f 92       	push	r7
 4be:	8f 92       	push	r8
 4c0:	9f 92       	push	r9
 4c2:	af 92       	push	r10
 4c4:	bf 92       	push	r11
 4c6:	cf 92       	push	r12
 4c8:	df 92       	push	r13
 4ca:	ef 92       	push	r14
 4cc:	ff 92       	push	r15
 4ce:	0f 93       	push	r16
 4d0:	1f 93       	push	r17
 4d2:	2f 93       	push	r18
 4d4:	3f 93       	push	r19
 4d6:	4f 93       	push	r20
 4d8:	5f 93       	push	r21
 4da:	6f 93       	push	r22
 4dc:	7f 93       	push	r23
 4de:	8f 93       	push	r24
 4e0:	9f 93       	push	r25
 4e2:	af 93       	push	r26
 4e4:	bf 93       	push	r27
 4e6:	cf 93       	push	r28
 4e8:	df 93       	push	r29
 4ea:	ef 93       	push	r30
 4ec:	ff 93       	push	r31
 4ee:	a0 91 87 06 	lds	r26, 0x0687	; 0x800687 <pxCurrentTCB>
 4f2:	b0 91 88 06 	lds	r27, 0x0688	; 0x800688 <pxCurrentTCB+0x1>
 4f6:	0d b6       	in	r0, 0x3d	; 61
 4f8:	0d 92       	st	X+, r0
 4fa:	0e b6       	in	r0, 0x3e	; 62
 4fc:	0d 92       	st	X+, r0
	vTaskIncrementTick();
 4fe:	0e 94 41 04 	call	0x882	; 0x882 <vTaskIncrementTick>
	vTaskSwitchContext();
 502:	0e 94 d5 05 	call	0xbaa	; 0xbaa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 506:	a0 91 87 06 	lds	r26, 0x0687	; 0x800687 <pxCurrentTCB>
 50a:	b0 91 88 06 	lds	r27, 0x0688	; 0x800688 <pxCurrentTCB+0x1>
 50e:	cd 91       	ld	r28, X+
 510:	cd bf       	out	0x3d, r28	; 61
 512:	dd 91       	ld	r29, X+
 514:	de bf       	out	0x3e, r29	; 62
 516:	ff 91       	pop	r31
 518:	ef 91       	pop	r30
 51a:	df 91       	pop	r29
 51c:	cf 91       	pop	r28
 51e:	bf 91       	pop	r27
 520:	af 91       	pop	r26
 522:	9f 91       	pop	r25
 524:	8f 91       	pop	r24
 526:	7f 91       	pop	r23
 528:	6f 91       	pop	r22
 52a:	5f 91       	pop	r21
 52c:	4f 91       	pop	r20
 52e:	3f 91       	pop	r19
 530:	2f 91       	pop	r18
 532:	1f 91       	pop	r17
 534:	0f 91       	pop	r16
 536:	ff 90       	pop	r15
 538:	ef 90       	pop	r14
 53a:	df 90       	pop	r13
 53c:	cf 90       	pop	r12
 53e:	bf 90       	pop	r11
 540:	af 90       	pop	r10
 542:	9f 90       	pop	r9
 544:	8f 90       	pop	r8
 546:	7f 90       	pop	r7
 548:	6f 90       	pop	r6
 54a:	5f 90       	pop	r5
 54c:	4f 90       	pop	r4
 54e:	3f 90       	pop	r3
 550:	2f 90       	pop	r2
 552:	1f 90       	pop	r1
 554:	0f 90       	pop	r0
 556:	0f be       	out	0x3f, r0	; 63
 558:	0f 90       	pop	r0

	asm volatile ( "ret" );
 55a:	08 95       	ret

0000055c <__vector_7>:
//	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
//	void SIG_OUTPUT_COMPARE1A( void )
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
 55c:	0e 94 53 02 	call	0x4a6	; 0x4a6 <vPortYieldFromTick>
		asm volatile ( "reti" );
 560:	18 95       	reti

00000562 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 562:	cf 93       	push	r28
 564:	df 93       	push	r29
 566:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
 568:	0e 94 31 04 	call	0x862	; 0x862 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
 56c:	20 91 76 00 	lds	r18, 0x0076	; 0x800076 <__data_end>
 570:	30 91 77 00 	lds	r19, 0x0077	; 0x800077 <__data_end+0x1>
 574:	ce 01       	movw	r24, r28
 576:	82 0f       	add	r24, r18
 578:	93 1f       	adc	r25, r19
 57a:	8c 3d       	cpi	r24, 0xDC	; 220
 57c:	45 e0       	ldi	r20, 0x05	; 5
 57e:	94 07       	cpc	r25, r20
 580:	58 f4       	brcc	.+22     	; 0x598 <pvPortMalloc+0x36>
 582:	28 17       	cp	r18, r24
 584:	39 07       	cpc	r19, r25
 586:	58 f4       	brcc	.+22     	; 0x59e <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
 588:	e9 01       	movw	r28, r18
 58a:	c8 58       	subi	r28, 0x88	; 136
 58c:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
 58e:	90 93 77 00 	sts	0x0077, r25	; 0x800077 <__data_end+0x1>
 592:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <__data_end>
 596:	05 c0       	rjmp	.+10     	; 0x5a2 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
 598:	c0 e0       	ldi	r28, 0x00	; 0
 59a:	d0 e0       	ldi	r29, 0x00	; 0
 59c:	02 c0       	rjmp	.+4      	; 0x5a2 <pvPortMalloc+0x40>
 59e:	c0 e0       	ldi	r28, 0x00	; 0
 5a0:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
 5a2:	0e 94 05 05 	call	0xa0a	; 0xa0a <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
 5a6:	ce 01       	movw	r24, r28
 5a8:	df 91       	pop	r29
 5aa:	cf 91       	pop	r28
 5ac:	08 95       	ret

000005ae <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 5ae:	08 95       	ret

000005b0 <prvIdleTask>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
 5b0:	ce e7       	ldi	r28, 0x7E	; 126
 5b2:	d6 e0       	ldi	r29, 0x06	; 6
 5b4:	88 81       	ld	r24, Y
 5b6:	82 30       	cpi	r24, 0x02	; 2
 5b8:	e8 f3       	brcs	.-6      	; 0x5b4 <prvIdleTask+0x4>
 5ba:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <vPortYield>
 5be:	fa cf       	rjmp	.-12     	; 0x5b4 <prvIdleTask+0x4>

000005c0 <prvAddCurrentTaskToDelayedList>:
 5c0:	cf 93       	push	r28
 5c2:	df 93       	push	r29
 5c4:	ec 01       	movw	r28, r24
 5c6:	e0 91 87 06 	lds	r30, 0x0687	; 0x800687 <pxCurrentTCB>
 5ca:	f0 91 88 06 	lds	r31, 0x0688	; 0x800688 <pxCurrentTCB+0x1>
 5ce:	93 83       	std	Z+3, r25	; 0x03
 5d0:	82 83       	std	Z+2, r24	; 0x02
 5d2:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <xTickCount>
 5d6:	90 91 5d 06 	lds	r25, 0x065D	; 0x80065d <xTickCount+0x1>
 5da:	c8 17       	cp	r28, r24
 5dc:	d9 07       	cpc	r29, r25
 5de:	68 f4       	brcc	.+26     	; 0x5fa <prvAddCurrentTaskToDelayedList+0x3a>
 5e0:	60 91 87 06 	lds	r22, 0x0687	; 0x800687 <pxCurrentTCB>
 5e4:	70 91 88 06 	lds	r23, 0x0688	; 0x800688 <pxCurrentTCB+0x1>
 5e8:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <pxOverflowDelayedTaskList>
 5ec:	90 91 69 06 	lds	r25, 0x0669	; 0x800669 <pxOverflowDelayedTaskList+0x1>
 5f0:	6e 5f       	subi	r22, 0xFE	; 254
 5f2:	7f 4f       	sbci	r23, 0xFF	; 255
 5f4:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <vListInsert>
 5f8:	17 c0       	rjmp	.+46     	; 0x628 <prvAddCurrentTaskToDelayedList+0x68>
 5fa:	60 91 87 06 	lds	r22, 0x0687	; 0x800687 <pxCurrentTCB>
 5fe:	70 91 88 06 	lds	r23, 0x0688	; 0x800688 <pxCurrentTCB+0x1>
 602:	80 91 6a 06 	lds	r24, 0x066A	; 0x80066a <pxDelayedTaskList>
 606:	90 91 6b 06 	lds	r25, 0x066B	; 0x80066b <pxDelayedTaskList+0x1>
 60a:	6e 5f       	subi	r22, 0xFE	; 254
 60c:	7f 4f       	sbci	r23, 0xFF	; 255
 60e:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <vListInsert>
 612:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
 616:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
 61a:	c8 17       	cp	r28, r24
 61c:	d9 07       	cpc	r29, r25
 61e:	20 f4       	brcc	.+8      	; 0x628 <prvAddCurrentTaskToDelayedList+0x68>
 620:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__data_start+0x1>
 624:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__data_start>
 628:	df 91       	pop	r29
 62a:	cf 91       	pop	r28
 62c:	08 95       	ret

0000062e <xTaskGenericCreate>:
 62e:	4f 92       	push	r4
 630:	5f 92       	push	r5
 632:	6f 92       	push	r6
 634:	7f 92       	push	r7
 636:	8f 92       	push	r8
 638:	9f 92       	push	r9
 63a:	af 92       	push	r10
 63c:	bf 92       	push	r11
 63e:	cf 92       	push	r12
 640:	df 92       	push	r13
 642:	ef 92       	push	r14
 644:	ff 92       	push	r15
 646:	0f 93       	push	r16
 648:	cf 93       	push	r28
 64a:	df 93       	push	r29
 64c:	5c 01       	movw	r10, r24
 64e:	4b 01       	movw	r8, r22
 650:	3a 01       	movw	r6, r20
 652:	29 01       	movw	r4, r18
 654:	81 e2       	ldi	r24, 0x21	; 33
 656:	90 e0       	ldi	r25, 0x00	; 0
 658:	0e 94 b1 02 	call	0x562	; 0x562 <pvPortMalloc>
 65c:	ec 01       	movw	r28, r24
 65e:	89 2b       	or	r24, r25
 660:	09 f4       	brne	.+2      	; 0x664 <xTaskGenericCreate+0x36>
 662:	a5 c0       	rjmp	.+330    	; 0x7ae <xTaskGenericCreate+0x180>
 664:	c1 14       	cp	r12, r1
 666:	d1 04       	cpc	r13, r1
 668:	09 f0       	breq	.+2      	; 0x66c <xTaskGenericCreate+0x3e>
 66a:	9d c0       	rjmp	.+314    	; 0x7a6 <xTaskGenericCreate+0x178>
 66c:	c3 01       	movw	r24, r6
 66e:	0e 94 b1 02 	call	0x562	; 0x562 <pvPortMalloc>
 672:	98 8f       	std	Y+24, r25	; 0x18
 674:	8f 8b       	std	Y+23, r24	; 0x17
 676:	00 97       	sbiw	r24, 0x00	; 0
 678:	21 f4       	brne	.+8      	; 0x682 <xTaskGenericCreate+0x54>
 67a:	ce 01       	movw	r24, r28
 67c:	0e 94 d7 02 	call	0x5ae	; 0x5ae <vPortFree>
 680:	96 c0       	rjmp	.+300    	; 0x7ae <xTaskGenericCreate+0x180>
 682:	a3 01       	movw	r20, r6
 684:	65 ea       	ldi	r22, 0xA5	; 165
 686:	70 e0       	ldi	r23, 0x00	; 0
 688:	0e 94 41 06 	call	0xc82	; 0xc82 <memset>
 68c:	93 01       	movw	r18, r6
 68e:	21 50       	subi	r18, 0x01	; 1
 690:	31 09       	sbc	r19, r1
 692:	8f 89       	ldd	r24, Y+23	; 0x17
 694:	98 8d       	ldd	r25, Y+24	; 0x18
 696:	3c 01       	movw	r6, r24
 698:	62 0e       	add	r6, r18
 69a:	73 1e       	adc	r7, r19
 69c:	48 e0       	ldi	r20, 0x08	; 8
 69e:	50 e0       	ldi	r21, 0x00	; 0
 6a0:	b4 01       	movw	r22, r8
 6a2:	ce 01       	movw	r24, r28
 6a4:	49 96       	adiw	r24, 0x19	; 25
 6a6:	0e 94 48 06 	call	0xc90	; 0xc90 <strncpy>
 6aa:	18 a2       	std	Y+32, r1	; 0x20
 6ac:	1e 8a       	std	Y+22, r1	; 0x16
 6ae:	6e 01       	movw	r12, r28
 6b0:	82 e0       	ldi	r24, 0x02	; 2
 6b2:	c8 0e       	add	r12, r24
 6b4:	d1 1c       	adc	r13, r1
 6b6:	c6 01       	movw	r24, r12
 6b8:	0e 94 cd 00 	call	0x19a	; 0x19a <vListInitialiseItem>
 6bc:	ce 01       	movw	r24, r28
 6be:	0c 96       	adiw	r24, 0x0c	; 12
 6c0:	0e 94 cd 00 	call	0x19a	; 0x19a <vListInitialiseItem>
 6c4:	d9 87       	std	Y+9, r29	; 0x09
 6c6:	c8 87       	std	Y+8, r28	; 0x08
 6c8:	81 e0       	ldi	r24, 0x01	; 1
 6ca:	90 e0       	ldi	r25, 0x00	; 0
 6cc:	9d 87       	std	Y+13, r25	; 0x0d
 6ce:	8c 87       	std	Y+12, r24	; 0x0c
 6d0:	db 8b       	std	Y+19, r29	; 0x13
 6d2:	ca 8b       	std	Y+18, r28	; 0x12
 6d4:	a2 01       	movw	r20, r4
 6d6:	b5 01       	movw	r22, r10
 6d8:	c3 01       	movw	r24, r6
 6da:	0e 94 59 01 	call	0x2b2	; 0x2b2 <pxPortInitialiseStack>
 6de:	99 83       	std	Y+1, r25	; 0x01
 6e0:	88 83       	st	Y, r24
 6e2:	e1 14       	cp	r14, r1
 6e4:	f1 04       	cpc	r15, r1
 6e6:	19 f0       	breq	.+6      	; 0x6ee <xTaskGenericCreate+0xc0>
 6e8:	f7 01       	movw	r30, r14
 6ea:	d1 83       	std	Z+1, r29	; 0x01
 6ec:	c0 83       	st	Z, r28
 6ee:	0f b6       	in	r0, 0x3f	; 63
 6f0:	f8 94       	cli
 6f2:	0f 92       	push	r0
 6f4:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxCurrentNumberOfTasks>
 6f8:	8f 5f       	subi	r24, 0xFF	; 255
 6fa:	80 93 5e 06 	sts	0x065E, r24	; 0x80065e <uxCurrentNumberOfTasks>
 6fe:	80 91 87 06 	lds	r24, 0x0687	; 0x800687 <pxCurrentTCB>
 702:	90 91 88 06 	lds	r25, 0x0688	; 0x800688 <pxCurrentTCB+0x1>
 706:	89 2b       	or	r24, r25
 708:	49 f4       	brne	.+18     	; 0x71c <xTaskGenericCreate+0xee>
 70a:	d0 93 88 06 	sts	0x0688, r29	; 0x800688 <pxCurrentTCB+0x1>
 70e:	c0 93 87 06 	sts	0x0687, r28	; 0x800687 <pxCurrentTCB>
 712:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxCurrentNumberOfTasks>
 716:	81 30       	cpi	r24, 0x01	; 1
 718:	81 f4       	brne	.+32     	; 0x73a <xTaskGenericCreate+0x10c>
 71a:	4b c0       	rjmp	.+150    	; 0x7b2 <xTaskGenericCreate+0x184>
 71c:	80 91 59 06 	lds	r24, 0x0659	; 0x800659 <xSchedulerRunning>
 720:	81 11       	cpse	r24, r1
 722:	0b c0       	rjmp	.+22     	; 0x73a <xTaskGenericCreate+0x10c>
 724:	e0 91 87 06 	lds	r30, 0x0687	; 0x800687 <pxCurrentTCB>
 728:	f0 91 88 06 	lds	r31, 0x0688	; 0x800688 <pxCurrentTCB+0x1>
 72c:	86 89       	ldd	r24, Z+22	; 0x16
 72e:	08 17       	cp	r16, r24
 730:	20 f0       	brcs	.+8      	; 0x73a <xTaskGenericCreate+0x10c>
 732:	d0 93 88 06 	sts	0x0688, r29	; 0x800688 <pxCurrentTCB+0x1>
 736:	c0 93 87 06 	sts	0x0687, r28	; 0x800687 <pxCurrentTCB>
 73a:	8e 89       	ldd	r24, Y+22	; 0x16
 73c:	90 91 5b 06 	lds	r25, 0x065B	; 0x80065b <uxTopUsedPriority>
 740:	98 17       	cp	r25, r24
 742:	10 f4       	brcc	.+4      	; 0x748 <xTaskGenericCreate+0x11a>
 744:	80 93 5b 06 	sts	0x065B, r24	; 0x80065b <uxTopUsedPriority>
 748:	90 91 54 06 	lds	r25, 0x0654	; 0x800654 <uxTCBNumber>
 74c:	9f 5f       	subi	r25, 0xFF	; 255
 74e:	90 93 54 06 	sts	0x0654, r25	; 0x800654 <uxTCBNumber>
 752:	90 91 5a 06 	lds	r25, 0x065A	; 0x80065a <uxTopReadyPriority>
 756:	98 17       	cp	r25, r24
 758:	10 f4       	brcc	.+4      	; 0x75e <xTaskGenericCreate+0x130>
 75a:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <uxTopReadyPriority>
 75e:	90 e0       	ldi	r25, 0x00	; 0
 760:	9c 01       	movw	r18, r24
 762:	22 0f       	add	r18, r18
 764:	33 1f       	adc	r19, r19
 766:	22 0f       	add	r18, r18
 768:	33 1f       	adc	r19, r19
 76a:	22 0f       	add	r18, r18
 76c:	33 1f       	adc	r19, r19
 76e:	82 0f       	add	r24, r18
 770:	93 1f       	adc	r25, r19
 772:	b6 01       	movw	r22, r12
 774:	82 58       	subi	r24, 0x82	; 130
 776:	99 4f       	sbci	r25, 0xF9	; 249
 778:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <vListInsertEnd>
 77c:	0f 90       	pop	r0
 77e:	0f be       	out	0x3f, r0	; 63
 780:	80 91 59 06 	lds	r24, 0x0659	; 0x800659 <xSchedulerRunning>
 784:	88 23       	and	r24, r24
 786:	59 f0       	breq	.+22     	; 0x79e <xTaskGenericCreate+0x170>
 788:	e0 91 87 06 	lds	r30, 0x0687	; 0x800687 <pxCurrentTCB>
 78c:	f0 91 88 06 	lds	r31, 0x0688	; 0x800688 <pxCurrentTCB+0x1>
 790:	86 89       	ldd	r24, Z+22	; 0x16
 792:	80 17       	cp	r24, r16
 794:	30 f4       	brcc	.+12     	; 0x7a2 <xTaskGenericCreate+0x174>
 796:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <vPortYield>
 79a:	81 e0       	ldi	r24, 0x01	; 1
 79c:	27 c0       	rjmp	.+78     	; 0x7ec <xTaskGenericCreate+0x1be>
 79e:	81 e0       	ldi	r24, 0x01	; 1
 7a0:	25 c0       	rjmp	.+74     	; 0x7ec <xTaskGenericCreate+0x1be>
 7a2:	81 e0       	ldi	r24, 0x01	; 1
 7a4:	23 c0       	rjmp	.+70     	; 0x7ec <xTaskGenericCreate+0x1be>
 7a6:	d8 8e       	std	Y+24, r13	; 0x18
 7a8:	cf 8a       	std	Y+23, r12	; 0x17
 7aa:	c6 01       	movw	r24, r12
 7ac:	6a cf       	rjmp	.-300    	; 0x682 <xTaskGenericCreate+0x54>
 7ae:	8f ef       	ldi	r24, 0xFF	; 255
 7b0:	1d c0       	rjmp	.+58     	; 0x7ec <xTaskGenericCreate+0x1be>
 7b2:	8e e7       	ldi	r24, 0x7E	; 126
 7b4:	96 e0       	ldi	r25, 0x06	; 6
 7b6:	0e 94 bf 00 	call	0x17e	; 0x17e <vListInitialise>
 7ba:	85 e7       	ldi	r24, 0x75	; 117
 7bc:	96 e0       	ldi	r25, 0x06	; 6
 7be:	0e 94 bf 00 	call	0x17e	; 0x17e <vListInitialise>
 7c2:	8c e6       	ldi	r24, 0x6C	; 108
 7c4:	96 e0       	ldi	r25, 0x06	; 6
 7c6:	0e 94 bf 00 	call	0x17e	; 0x17e <vListInitialise>
 7ca:	8f e5       	ldi	r24, 0x5F	; 95
 7cc:	96 e0       	ldi	r25, 0x06	; 6
 7ce:	0e 94 bf 00 	call	0x17e	; 0x17e <vListInitialise>
 7d2:	85 e7       	ldi	r24, 0x75	; 117
 7d4:	96 e0       	ldi	r25, 0x06	; 6
 7d6:	90 93 6b 06 	sts	0x066B, r25	; 0x80066b <pxDelayedTaskList+0x1>
 7da:	80 93 6a 06 	sts	0x066A, r24	; 0x80066a <pxDelayedTaskList>
 7de:	8c e6       	ldi	r24, 0x6C	; 108
 7e0:	96 e0       	ldi	r25, 0x06	; 6
 7e2:	90 93 69 06 	sts	0x0669, r25	; 0x800669 <pxOverflowDelayedTaskList+0x1>
 7e6:	80 93 68 06 	sts	0x0668, r24	; 0x800668 <pxOverflowDelayedTaskList>
 7ea:	a7 cf       	rjmp	.-178    	; 0x73a <xTaskGenericCreate+0x10c>
 7ec:	df 91       	pop	r29
 7ee:	cf 91       	pop	r28
 7f0:	0f 91       	pop	r16
 7f2:	ff 90       	pop	r15
 7f4:	ef 90       	pop	r14
 7f6:	df 90       	pop	r13
 7f8:	cf 90       	pop	r12
 7fa:	bf 90       	pop	r11
 7fc:	af 90       	pop	r10
 7fe:	9f 90       	pop	r9
 800:	8f 90       	pop	r8
 802:	7f 90       	pop	r7
 804:	6f 90       	pop	r6
 806:	5f 90       	pop	r5
 808:	4f 90       	pop	r4
 80a:	08 95       	ret

0000080c <vTaskStartScheduler>:
 80c:	af 92       	push	r10
 80e:	bf 92       	push	r11
 810:	cf 92       	push	r12
 812:	df 92       	push	r13
 814:	ef 92       	push	r14
 816:	ff 92       	push	r15
 818:	0f 93       	push	r16
 81a:	a1 2c       	mov	r10, r1
 81c:	b1 2c       	mov	r11, r1
 81e:	c1 2c       	mov	r12, r1
 820:	d1 2c       	mov	r13, r1
 822:	e1 2c       	mov	r14, r1
 824:	f1 2c       	mov	r15, r1
 826:	00 e0       	ldi	r16, 0x00	; 0
 828:	20 e0       	ldi	r18, 0x00	; 0
 82a:	30 e0       	ldi	r19, 0x00	; 0
 82c:	45 e5       	ldi	r20, 0x55	; 85
 82e:	50 e0       	ldi	r21, 0x00	; 0
 830:	61 e7       	ldi	r22, 0x71	; 113
 832:	70 e0       	ldi	r23, 0x00	; 0
 834:	88 ed       	ldi	r24, 0xD8	; 216
 836:	92 e0       	ldi	r25, 0x02	; 2
 838:	0e 94 17 03 	call	0x62e	; 0x62e <xTaskGenericCreate>
 83c:	81 30       	cpi	r24, 0x01	; 1
 83e:	49 f4       	brne	.+18     	; 0x852 <vTaskStartScheduler+0x46>
 840:	f8 94       	cli
 842:	80 93 59 06 	sts	0x0659, r24	; 0x800659 <xSchedulerRunning>
 846:	10 92 5d 06 	sts	0x065D, r1	; 0x80065d <xTickCount+0x1>
 84a:	10 92 5c 06 	sts	0x065C, r1	; 0x80065c <xTickCount>
 84e:	0e 94 c5 01 	call	0x38a	; 0x38a <xPortStartScheduler>
 852:	0f 91       	pop	r16
 854:	ff 90       	pop	r15
 856:	ef 90       	pop	r14
 858:	df 90       	pop	r13
 85a:	cf 90       	pop	r12
 85c:	bf 90       	pop	r11
 85e:	af 90       	pop	r10
 860:	08 95       	ret

00000862 <vTaskSuspendAll>:
 862:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <uxSchedulerSuspended>
 866:	8f 5f       	subi	r24, 0xFF	; 255
 868:	80 93 58 06 	sts	0x0658, r24	; 0x800658 <uxSchedulerSuspended>
 86c:	08 95       	ret

0000086e <xTaskGetTickCount>:
 86e:	0f b6       	in	r0, 0x3f	; 63
 870:	f8 94       	cli
 872:	0f 92       	push	r0
 874:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <xTickCount>
 878:	90 91 5d 06 	lds	r25, 0x065D	; 0x80065d <xTickCount+0x1>
 87c:	0f 90       	pop	r0
 87e:	0f be       	out	0x3f, r0	; 63
 880:	08 95       	ret

00000882 <vTaskIncrementTick>:
 882:	0f 93       	push	r16
 884:	1f 93       	push	r17
 886:	cf 93       	push	r28
 888:	df 93       	push	r29
 88a:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <uxSchedulerSuspended>
 88e:	81 11       	cpse	r24, r1
 890:	b2 c0       	rjmp	.+356    	; 0x9f6 <vTaskIncrementTick+0x174>
 892:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <xTickCount>
 896:	90 91 5d 06 	lds	r25, 0x065D	; 0x80065d <xTickCount+0x1>
 89a:	01 96       	adiw	r24, 0x01	; 1
 89c:	90 93 5d 06 	sts	0x065D, r25	; 0x80065d <xTickCount+0x1>
 8a0:	80 93 5c 06 	sts	0x065C, r24	; 0x80065c <xTickCount>
 8a4:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <xTickCount>
 8a8:	90 91 5d 06 	lds	r25, 0x065D	; 0x80065d <xTickCount+0x1>
 8ac:	89 2b       	or	r24, r25
 8ae:	99 f5       	brne	.+102    	; 0x916 <vTaskIncrementTick+0x94>
 8b0:	80 91 6a 06 	lds	r24, 0x066A	; 0x80066a <pxDelayedTaskList>
 8b4:	90 91 6b 06 	lds	r25, 0x066B	; 0x80066b <pxDelayedTaskList+0x1>
 8b8:	20 91 68 06 	lds	r18, 0x0668	; 0x800668 <pxOverflowDelayedTaskList>
 8bc:	30 91 69 06 	lds	r19, 0x0669	; 0x800669 <pxOverflowDelayedTaskList+0x1>
 8c0:	30 93 6b 06 	sts	0x066B, r19	; 0x80066b <pxDelayedTaskList+0x1>
 8c4:	20 93 6a 06 	sts	0x066A, r18	; 0x80066a <pxDelayedTaskList>
 8c8:	90 93 69 06 	sts	0x0669, r25	; 0x800669 <pxOverflowDelayedTaskList+0x1>
 8cc:	80 93 68 06 	sts	0x0668, r24	; 0x800668 <pxOverflowDelayedTaskList>
 8d0:	80 91 55 06 	lds	r24, 0x0655	; 0x800655 <xNumOfOverflows>
 8d4:	8f 5f       	subi	r24, 0xFF	; 255
 8d6:	80 93 55 06 	sts	0x0655, r24	; 0x800655 <xNumOfOverflows>
 8da:	e0 91 6a 06 	lds	r30, 0x066A	; 0x80066a <pxDelayedTaskList>
 8de:	f0 91 6b 06 	lds	r31, 0x066B	; 0x80066b <pxDelayedTaskList+0x1>
 8e2:	80 81       	ld	r24, Z
 8e4:	81 11       	cpse	r24, r1
 8e6:	07 c0       	rjmp	.+14     	; 0x8f6 <vTaskIncrementTick+0x74>
 8e8:	8f ef       	ldi	r24, 0xFF	; 255
 8ea:	9f ef       	ldi	r25, 0xFF	; 255
 8ec:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 8f0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 8f4:	10 c0       	rjmp	.+32     	; 0x916 <vTaskIncrementTick+0x94>
 8f6:	e0 91 6a 06 	lds	r30, 0x066A	; 0x80066a <pxDelayedTaskList>
 8fa:	f0 91 6b 06 	lds	r31, 0x066B	; 0x80066b <pxDelayedTaskList+0x1>
 8fe:	05 80       	ldd	r0, Z+5	; 0x05
 900:	f6 81       	ldd	r31, Z+6	; 0x06
 902:	e0 2d       	mov	r30, r0
 904:	06 80       	ldd	r0, Z+6	; 0x06
 906:	f7 81       	ldd	r31, Z+7	; 0x07
 908:	e0 2d       	mov	r30, r0
 90a:	82 81       	ldd	r24, Z+2	; 0x02
 90c:	93 81       	ldd	r25, Z+3	; 0x03
 90e:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 912:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 916:	20 91 5c 06 	lds	r18, 0x065C	; 0x80065c <xTickCount>
 91a:	30 91 5d 06 	lds	r19, 0x065D	; 0x80065d <xTickCount+0x1>
 91e:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
 922:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__data_start+0x1>
 926:	28 17       	cp	r18, r24
 928:	39 07       	cpc	r19, r25
 92a:	08 f4       	brcc	.+2      	; 0x92e <vTaskIncrementTick+0xac>
 92c:	69 c0       	rjmp	.+210    	; 0xa00 <vTaskIncrementTick+0x17e>
 92e:	e0 91 6a 06 	lds	r30, 0x066A	; 0x80066a <pxDelayedTaskList>
 932:	f0 91 6b 06 	lds	r31, 0x066B	; 0x80066b <pxDelayedTaskList+0x1>
 936:	80 81       	ld	r24, Z
 938:	88 23       	and	r24, r24
 93a:	99 f0       	breq	.+38     	; 0x962 <vTaskIncrementTick+0xe0>
 93c:	e0 91 6a 06 	lds	r30, 0x066A	; 0x80066a <pxDelayedTaskList>
 940:	f0 91 6b 06 	lds	r31, 0x066B	; 0x80066b <pxDelayedTaskList+0x1>
 944:	05 80       	ldd	r0, Z+5	; 0x05
 946:	f6 81       	ldd	r31, Z+6	; 0x06
 948:	e0 2d       	mov	r30, r0
 94a:	c6 81       	ldd	r28, Z+6	; 0x06
 94c:	d7 81       	ldd	r29, Z+7	; 0x07
 94e:	8a 81       	ldd	r24, Y+2	; 0x02
 950:	9b 81       	ldd	r25, Y+3	; 0x03
 952:	20 91 5c 06 	lds	r18, 0x065C	; 0x80065c <xTickCount>
 956:	30 91 5d 06 	lds	r19, 0x065D	; 0x80065d <xTickCount+0x1>
 95a:	28 17       	cp	r18, r24
 95c:	39 07       	cpc	r19, r25
 95e:	f8 f4       	brcc	.+62     	; 0x99e <vTaskIncrementTick+0x11c>
 960:	19 c0       	rjmp	.+50     	; 0x994 <vTaskIncrementTick+0x112>
 962:	8f ef       	ldi	r24, 0xFF	; 255
 964:	9f ef       	ldi	r25, 0xFF	; 255
 966:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 96a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 96e:	48 c0       	rjmp	.+144    	; 0xa00 <vTaskIncrementTick+0x17e>
 970:	e0 91 6a 06 	lds	r30, 0x066A	; 0x80066a <pxDelayedTaskList>
 974:	f0 91 6b 06 	lds	r31, 0x066B	; 0x80066b <pxDelayedTaskList+0x1>
 978:	05 80       	ldd	r0, Z+5	; 0x05
 97a:	f6 81       	ldd	r31, Z+6	; 0x06
 97c:	e0 2d       	mov	r30, r0
 97e:	c6 81       	ldd	r28, Z+6	; 0x06
 980:	d7 81       	ldd	r29, Z+7	; 0x07
 982:	8a 81       	ldd	r24, Y+2	; 0x02
 984:	9b 81       	ldd	r25, Y+3	; 0x03
 986:	20 91 5c 06 	lds	r18, 0x065C	; 0x80065c <xTickCount>
 98a:	30 91 5d 06 	lds	r19, 0x065D	; 0x80065d <xTickCount+0x1>
 98e:	28 17       	cp	r18, r24
 990:	39 07       	cpc	r19, r25
 992:	28 f4       	brcc	.+10     	; 0x99e <vTaskIncrementTick+0x11c>
 994:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__data_start+0x1>
 998:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
 99c:	31 c0       	rjmp	.+98     	; 0xa00 <vTaskIncrementTick+0x17e>
 99e:	8e 01       	movw	r16, r28
 9a0:	0e 5f       	subi	r16, 0xFE	; 254
 9a2:	1f 4f       	sbci	r17, 0xFF	; 255
 9a4:	c8 01       	movw	r24, r16
 9a6:	0e 94 33 01 	call	0x266	; 0x266 <vListRemove>
 9aa:	8c 89       	ldd	r24, Y+20	; 0x14
 9ac:	9d 89       	ldd	r25, Y+21	; 0x15
 9ae:	89 2b       	or	r24, r25
 9b0:	21 f0       	breq	.+8      	; 0x9ba <vTaskIncrementTick+0x138>
 9b2:	ce 01       	movw	r24, r28
 9b4:	0c 96       	adiw	r24, 0x0c	; 12
 9b6:	0e 94 33 01 	call	0x266	; 0x266 <vListRemove>
 9ba:	2e 89       	ldd	r18, Y+22	; 0x16
 9bc:	80 91 5a 06 	lds	r24, 0x065A	; 0x80065a <uxTopReadyPriority>
 9c0:	82 17       	cp	r24, r18
 9c2:	10 f4       	brcc	.+4      	; 0x9c8 <vTaskIncrementTick+0x146>
 9c4:	20 93 5a 06 	sts	0x065A, r18	; 0x80065a <uxTopReadyPriority>
 9c8:	30 e0       	ldi	r19, 0x00	; 0
 9ca:	c9 01       	movw	r24, r18
 9cc:	88 0f       	add	r24, r24
 9ce:	99 1f       	adc	r25, r25
 9d0:	88 0f       	add	r24, r24
 9d2:	99 1f       	adc	r25, r25
 9d4:	88 0f       	add	r24, r24
 9d6:	99 1f       	adc	r25, r25
 9d8:	82 0f       	add	r24, r18
 9da:	93 1f       	adc	r25, r19
 9dc:	b8 01       	movw	r22, r16
 9de:	82 58       	subi	r24, 0x82	; 130
 9e0:	99 4f       	sbci	r25, 0xF9	; 249
 9e2:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <vListInsertEnd>
 9e6:	e0 91 6a 06 	lds	r30, 0x066A	; 0x80066a <pxDelayedTaskList>
 9ea:	f0 91 6b 06 	lds	r31, 0x066B	; 0x80066b <pxDelayedTaskList+0x1>
 9ee:	80 81       	ld	r24, Z
 9f0:	81 11       	cpse	r24, r1
 9f2:	be cf       	rjmp	.-132    	; 0x970 <vTaskIncrementTick+0xee>
 9f4:	b6 cf       	rjmp	.-148    	; 0x962 <vTaskIncrementTick+0xe0>
 9f6:	80 91 57 06 	lds	r24, 0x0657	; 0x800657 <uxMissedTicks>
 9fa:	8f 5f       	subi	r24, 0xFF	; 255
 9fc:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <uxMissedTicks>
 a00:	df 91       	pop	r29
 a02:	cf 91       	pop	r28
 a04:	1f 91       	pop	r17
 a06:	0f 91       	pop	r16
 a08:	08 95       	ret

00000a0a <xTaskResumeAll>:
 a0a:	cf 92       	push	r12
 a0c:	df 92       	push	r13
 a0e:	ef 92       	push	r14
 a10:	ff 92       	push	r15
 a12:	0f 93       	push	r16
 a14:	1f 93       	push	r17
 a16:	cf 93       	push	r28
 a18:	df 93       	push	r29
 a1a:	0f b6       	in	r0, 0x3f	; 63
 a1c:	f8 94       	cli
 a1e:	0f 92       	push	r0
 a20:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <uxSchedulerSuspended>
 a24:	81 50       	subi	r24, 0x01	; 1
 a26:	80 93 58 06 	sts	0x0658, r24	; 0x800658 <uxSchedulerSuspended>
 a2a:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <uxSchedulerSuspended>
 a2e:	81 11       	cpse	r24, r1
 a30:	64 c0       	rjmp	.+200    	; 0xafa <xTaskResumeAll+0xf0>
 a32:	80 91 5e 06 	lds	r24, 0x065E	; 0x80065e <uxCurrentNumberOfTasks>
 a36:	81 11       	cpse	r24, r1
 a38:	32 c0       	rjmp	.+100    	; 0xa9e <xTaskResumeAll+0x94>
 a3a:	62 c0       	rjmp	.+196    	; 0xb00 <xTaskResumeAll+0xf6>
 a3c:	d7 01       	movw	r26, r14
 a3e:	15 96       	adiw	r26, 0x05	; 5
 a40:	ed 91       	ld	r30, X+
 a42:	fc 91       	ld	r31, X
 a44:	16 97       	sbiw	r26, 0x06	; 6
 a46:	c6 81       	ldd	r28, Z+6	; 0x06
 a48:	d7 81       	ldd	r29, Z+7	; 0x07
 a4a:	ce 01       	movw	r24, r28
 a4c:	0c 96       	adiw	r24, 0x0c	; 12
 a4e:	0e 94 33 01 	call	0x266	; 0x266 <vListRemove>
 a52:	8e 01       	movw	r16, r28
 a54:	0e 5f       	subi	r16, 0xFE	; 254
 a56:	1f 4f       	sbci	r17, 0xFF	; 255
 a58:	c8 01       	movw	r24, r16
 a5a:	0e 94 33 01 	call	0x266	; 0x266 <vListRemove>
 a5e:	2e 89       	ldd	r18, Y+22	; 0x16
 a60:	80 91 5a 06 	lds	r24, 0x065A	; 0x80065a <uxTopReadyPriority>
 a64:	82 17       	cp	r24, r18
 a66:	10 f4       	brcc	.+4      	; 0xa6c <xTaskResumeAll+0x62>
 a68:	20 93 5a 06 	sts	0x065A, r18	; 0x80065a <uxTopReadyPriority>
 a6c:	30 e0       	ldi	r19, 0x00	; 0
 a6e:	c9 01       	movw	r24, r18
 a70:	88 0f       	add	r24, r24
 a72:	99 1f       	adc	r25, r25
 a74:	88 0f       	add	r24, r24
 a76:	99 1f       	adc	r25, r25
 a78:	88 0f       	add	r24, r24
 a7a:	99 1f       	adc	r25, r25
 a7c:	82 0f       	add	r24, r18
 a7e:	93 1f       	adc	r25, r19
 a80:	b8 01       	movw	r22, r16
 a82:	82 58       	subi	r24, 0x82	; 130
 a84:	99 4f       	sbci	r25, 0xF9	; 249
 a86:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <vListInsertEnd>
 a8a:	e0 91 87 06 	lds	r30, 0x0687	; 0x800687 <pxCurrentTCB>
 a8e:	f0 91 88 06 	lds	r31, 0x0688	; 0x800688 <pxCurrentTCB+0x1>
 a92:	9e 89       	ldd	r25, Y+22	; 0x16
 a94:	86 89       	ldd	r24, Z+22	; 0x16
 a96:	98 17       	cp	r25, r24
 a98:	58 f0       	brcs	.+22     	; 0xab0 <xTaskResumeAll+0xa6>
 a9a:	dc 2c       	mov	r13, r12
 a9c:	09 c0       	rjmp	.+18     	; 0xab0 <xTaskResumeAll+0xa6>
 a9e:	d1 2c       	mov	r13, r1
 aa0:	0f 2e       	mov	r0, r31
 aa2:	ff e5       	ldi	r31, 0x5F	; 95
 aa4:	ef 2e       	mov	r14, r31
 aa6:	f6 e0       	ldi	r31, 0x06	; 6
 aa8:	ff 2e       	mov	r15, r31
 aaa:	f0 2d       	mov	r31, r0
 aac:	cc 24       	eor	r12, r12
 aae:	c3 94       	inc	r12
 ab0:	f7 01       	movw	r30, r14
 ab2:	80 81       	ld	r24, Z
 ab4:	81 11       	cpse	r24, r1
 ab6:	c2 cf       	rjmp	.-124    	; 0xa3c <xTaskResumeAll+0x32>
 ab8:	80 91 57 06 	lds	r24, 0x0657	; 0x800657 <uxMissedTicks>
 abc:	88 23       	and	r24, r24
 abe:	81 f0       	breq	.+32     	; 0xae0 <xTaskResumeAll+0xd6>
 ac0:	80 91 57 06 	lds	r24, 0x0657	; 0x800657 <uxMissedTicks>
 ac4:	88 23       	and	r24, r24
 ac6:	99 f0       	breq	.+38     	; 0xaee <xTaskResumeAll+0xe4>
 ac8:	0e 94 41 04 	call	0x882	; 0x882 <vTaskIncrementTick>
 acc:	80 91 57 06 	lds	r24, 0x0657	; 0x800657 <uxMissedTicks>
 ad0:	81 50       	subi	r24, 0x01	; 1
 ad2:	80 93 57 06 	sts	0x0657, r24	; 0x800657 <uxMissedTicks>
 ad6:	80 91 57 06 	lds	r24, 0x0657	; 0x800657 <uxMissedTicks>
 ada:	81 11       	cpse	r24, r1
 adc:	f5 cf       	rjmp	.-22     	; 0xac8 <xTaskResumeAll+0xbe>
 ade:	07 c0       	rjmp	.+14     	; 0xaee <xTaskResumeAll+0xe4>
 ae0:	f1 e0       	ldi	r31, 0x01	; 1
 ae2:	df 16       	cp	r13, r31
 ae4:	21 f0       	breq	.+8      	; 0xaee <xTaskResumeAll+0xe4>
 ae6:	80 91 56 06 	lds	r24, 0x0656	; 0x800656 <xMissedYield>
 aea:	81 30       	cpi	r24, 0x01	; 1
 aec:	41 f4       	brne	.+16     	; 0xafe <xTaskResumeAll+0xf4>
 aee:	10 92 56 06 	sts	0x0656, r1	; 0x800656 <xMissedYield>
 af2:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <vPortYield>
 af6:	81 e0       	ldi	r24, 0x01	; 1
 af8:	03 c0       	rjmp	.+6      	; 0xb00 <xTaskResumeAll+0xf6>
 afa:	80 e0       	ldi	r24, 0x00	; 0
 afc:	01 c0       	rjmp	.+2      	; 0xb00 <xTaskResumeAll+0xf6>
 afe:	80 e0       	ldi	r24, 0x00	; 0
 b00:	0f 90       	pop	r0
 b02:	0f be       	out	0x3f, r0	; 63
 b04:	df 91       	pop	r29
 b06:	cf 91       	pop	r28
 b08:	1f 91       	pop	r17
 b0a:	0f 91       	pop	r16
 b0c:	ff 90       	pop	r15
 b0e:	ef 90       	pop	r14
 b10:	df 90       	pop	r13
 b12:	cf 90       	pop	r12
 b14:	08 95       	ret

00000b16 <vTaskDelayUntil>:
 b16:	0f 93       	push	r16
 b18:	1f 93       	push	r17
 b1a:	cf 93       	push	r28
 b1c:	df 93       	push	r29
 b1e:	8c 01       	movw	r16, r24
 b20:	eb 01       	movw	r28, r22
 b22:	0e 94 31 04 	call	0x862	; 0x862 <vTaskSuspendAll>
 b26:	f8 01       	movw	r30, r16
 b28:	20 81       	ld	r18, Z
 b2a:	31 81       	ldd	r19, Z+1	; 0x01
 b2c:	c2 0f       	add	r28, r18
 b2e:	d3 1f       	adc	r29, r19
 b30:	40 91 5c 06 	lds	r20, 0x065C	; 0x80065c <xTickCount>
 b34:	50 91 5d 06 	lds	r21, 0x065D	; 0x80065d <xTickCount+0x1>
 b38:	42 17       	cp	r20, r18
 b3a:	53 07       	cpc	r21, r19
 b3c:	68 f4       	brcc	.+26     	; 0xb58 <vTaskDelayUntil+0x42>
 b3e:	c2 17       	cp	r28, r18
 b40:	d3 07       	cpc	r29, r19
 b42:	50 f5       	brcc	.+84     	; 0xb98 <vTaskDelayUntil+0x82>
 b44:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <xTickCount>
 b48:	90 91 5d 06 	lds	r25, 0x065D	; 0x80065d <xTickCount+0x1>
 b4c:	d1 83       	std	Z+1, r29	; 0x01
 b4e:	c0 83       	st	Z, r28
 b50:	8c 17       	cp	r24, r28
 b52:	9d 07       	cpc	r25, r29
 b54:	b0 f4       	brcc	.+44     	; 0xb82 <vTaskDelayUntil+0x6c>
 b56:	0b c0       	rjmp	.+22     	; 0xb6e <vTaskDelayUntil+0x58>
 b58:	c2 17       	cp	r28, r18
 b5a:	d3 07       	cpc	r29, r19
 b5c:	c8 f0       	brcs	.+50     	; 0xb90 <vTaskDelayUntil+0x7a>
 b5e:	80 91 5c 06 	lds	r24, 0x065C	; 0x80065c <xTickCount>
 b62:	90 91 5d 06 	lds	r25, 0x065D	; 0x80065d <xTickCount+0x1>
 b66:	8c 17       	cp	r24, r28
 b68:	9d 07       	cpc	r25, r29
 b6a:	90 f0       	brcs	.+36     	; 0xb90 <vTaskDelayUntil+0x7a>
 b6c:	15 c0       	rjmp	.+42     	; 0xb98 <vTaskDelayUntil+0x82>
 b6e:	80 91 87 06 	lds	r24, 0x0687	; 0x800687 <pxCurrentTCB>
 b72:	90 91 88 06 	lds	r25, 0x0688	; 0x800688 <pxCurrentTCB+0x1>
 b76:	02 96       	adiw	r24, 0x02	; 2
 b78:	0e 94 33 01 	call	0x266	; 0x266 <vListRemove>
 b7c:	ce 01       	movw	r24, r28
 b7e:	0e 94 e0 02 	call	0x5c0	; 0x5c0 <prvAddCurrentTaskToDelayedList>
 b82:	0e 94 05 05 	call	0xa0a	; 0xa0a <xTaskResumeAll>
 b86:	81 11       	cpse	r24, r1
 b88:	0b c0       	rjmp	.+22     	; 0xba0 <vTaskDelayUntil+0x8a>
 b8a:	0e 94 fa 01 	call	0x3f4	; 0x3f4 <vPortYield>
 b8e:	08 c0       	rjmp	.+16     	; 0xba0 <vTaskDelayUntil+0x8a>
 b90:	f8 01       	movw	r30, r16
 b92:	d1 83       	std	Z+1, r29	; 0x01
 b94:	c0 83       	st	Z, r28
 b96:	eb cf       	rjmp	.-42     	; 0xb6e <vTaskDelayUntil+0x58>
 b98:	f8 01       	movw	r30, r16
 b9a:	d1 83       	std	Z+1, r29	; 0x01
 b9c:	c0 83       	st	Z, r28
 b9e:	f1 cf       	rjmp	.-30     	; 0xb82 <vTaskDelayUntil+0x6c>
 ba0:	df 91       	pop	r29
 ba2:	cf 91       	pop	r28
 ba4:	1f 91       	pop	r17
 ba6:	0f 91       	pop	r16
 ba8:	08 95       	ret

00000baa <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
 baa:	80 91 58 06 	lds	r24, 0x0658	; 0x800658 <uxSchedulerSuspended>
 bae:	81 11       	cpse	r24, r1
 bb0:	13 c0       	rjmp	.+38     	; 0xbd8 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 bb2:	80 91 5a 06 	lds	r24, 0x065A	; 0x80065a <uxTopReadyPriority>
 bb6:	90 e0       	ldi	r25, 0x00	; 0
 bb8:	fc 01       	movw	r30, r24
 bba:	ee 0f       	add	r30, r30
 bbc:	ff 1f       	adc	r31, r31
 bbe:	ee 0f       	add	r30, r30
 bc0:	ff 1f       	adc	r31, r31
 bc2:	ee 0f       	add	r30, r30
 bc4:	ff 1f       	adc	r31, r31
 bc6:	8e 0f       	add	r24, r30
 bc8:	9f 1f       	adc	r25, r31
 bca:	fc 01       	movw	r30, r24
 bcc:	e2 58       	subi	r30, 0x82	; 130
 bce:	f9 4f       	sbci	r31, 0xF9	; 249
 bd0:	80 81       	ld	r24, Z
 bd2:	88 23       	and	r24, r24
 bd4:	29 f0       	breq	.+10     	; 0xbe0 <vTaskSwitchContext+0x36>
 bd6:	1b c0       	rjmp	.+54     	; 0xc0e <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
 bd8:	81 e0       	ldi	r24, 0x01	; 1
 bda:	80 93 56 06 	sts	0x0656, r24	; 0x800656 <xMissedYield>
 bde:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
 be0:	80 91 5a 06 	lds	r24, 0x065A	; 0x80065a <uxTopReadyPriority>
 be4:	81 50       	subi	r24, 0x01	; 1
 be6:	80 93 5a 06 	sts	0x065A, r24	; 0x80065a <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
 bea:	80 91 5a 06 	lds	r24, 0x065A	; 0x80065a <uxTopReadyPriority>
 bee:	90 e0       	ldi	r25, 0x00	; 0
 bf0:	fc 01       	movw	r30, r24
 bf2:	ee 0f       	add	r30, r30
 bf4:	ff 1f       	adc	r31, r31
 bf6:	ee 0f       	add	r30, r30
 bf8:	ff 1f       	adc	r31, r31
 bfa:	ee 0f       	add	r30, r30
 bfc:	ff 1f       	adc	r31, r31
 bfe:	8e 0f       	add	r24, r30
 c00:	9f 1f       	adc	r25, r31
 c02:	fc 01       	movw	r30, r24
 c04:	e2 58       	subi	r30, 0x82	; 130
 c06:	f9 4f       	sbci	r31, 0xF9	; 249
 c08:	80 81       	ld	r24, Z
 c0a:	88 23       	and	r24, r24
 c0c:	49 f3       	breq	.-46     	; 0xbe0 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
 c0e:	80 91 5a 06 	lds	r24, 0x065A	; 0x80065a <uxTopReadyPriority>
 c12:	90 e0       	ldi	r25, 0x00	; 0
 c14:	9c 01       	movw	r18, r24
 c16:	22 0f       	add	r18, r18
 c18:	33 1f       	adc	r19, r19
 c1a:	22 0f       	add	r18, r18
 c1c:	33 1f       	adc	r19, r19
 c1e:	22 0f       	add	r18, r18
 c20:	33 1f       	adc	r19, r19
 c22:	28 0f       	add	r18, r24
 c24:	39 1f       	adc	r19, r25
 c26:	d9 01       	movw	r26, r18
 c28:	a2 58       	subi	r26, 0x82	; 130
 c2a:	b9 4f       	sbci	r27, 0xF9	; 249
 c2c:	11 96       	adiw	r26, 0x01	; 1
 c2e:	ed 91       	ld	r30, X+
 c30:	fc 91       	ld	r31, X
 c32:	12 97       	sbiw	r26, 0x02	; 2
 c34:	02 80       	ldd	r0, Z+2	; 0x02
 c36:	f3 81       	ldd	r31, Z+3	; 0x03
 c38:	e0 2d       	mov	r30, r0
 c3a:	12 96       	adiw	r26, 0x02	; 2
 c3c:	fc 93       	st	X, r31
 c3e:	ee 93       	st	-X, r30
 c40:	11 97       	sbiw	r26, 0x01	; 1
 c42:	2f 57       	subi	r18, 0x7F	; 127
 c44:	39 4f       	sbci	r19, 0xF9	; 249
 c46:	e2 17       	cp	r30, r18
 c48:	f3 07       	cpc	r31, r19
 c4a:	29 f4       	brne	.+10     	; 0xc56 <vTaskSwitchContext+0xac>
 c4c:	22 81       	ldd	r18, Z+2	; 0x02
 c4e:	33 81       	ldd	r19, Z+3	; 0x03
 c50:	fd 01       	movw	r30, r26
 c52:	32 83       	std	Z+2, r19	; 0x02
 c54:	21 83       	std	Z+1, r18	; 0x01
 c56:	fc 01       	movw	r30, r24
 c58:	ee 0f       	add	r30, r30
 c5a:	ff 1f       	adc	r31, r31
 c5c:	ee 0f       	add	r30, r30
 c5e:	ff 1f       	adc	r31, r31
 c60:	ee 0f       	add	r30, r30
 c62:	ff 1f       	adc	r31, r31
 c64:	8e 0f       	add	r24, r30
 c66:	9f 1f       	adc	r25, r31
 c68:	fc 01       	movw	r30, r24
 c6a:	e2 58       	subi	r30, 0x82	; 130
 c6c:	f9 4f       	sbci	r31, 0xF9	; 249
 c6e:	01 80       	ldd	r0, Z+1	; 0x01
 c70:	f2 81       	ldd	r31, Z+2	; 0x02
 c72:	e0 2d       	mov	r30, r0
 c74:	86 81       	ldd	r24, Z+6	; 0x06
 c76:	97 81       	ldd	r25, Z+7	; 0x07
 c78:	90 93 88 06 	sts	0x0688, r25	; 0x800688 <pxCurrentTCB+0x1>
 c7c:	80 93 87 06 	sts	0x0687, r24	; 0x800687 <pxCurrentTCB>
 c80:	08 95       	ret

00000c82 <memset>:
 c82:	dc 01       	movw	r26, r24
 c84:	01 c0       	rjmp	.+2      	; 0xc88 <memset+0x6>
 c86:	6d 93       	st	X+, r22
 c88:	41 50       	subi	r20, 0x01	; 1
 c8a:	50 40       	sbci	r21, 0x00	; 0
 c8c:	e0 f7       	brcc	.-8      	; 0xc86 <memset+0x4>
 c8e:	08 95       	ret

00000c90 <strncpy>:
 c90:	fb 01       	movw	r30, r22
 c92:	dc 01       	movw	r26, r24
 c94:	41 50       	subi	r20, 0x01	; 1
 c96:	50 40       	sbci	r21, 0x00	; 0
 c98:	48 f0       	brcs	.+18     	; 0xcac <strncpy+0x1c>
 c9a:	01 90       	ld	r0, Z+
 c9c:	0d 92       	st	X+, r0
 c9e:	00 20       	and	r0, r0
 ca0:	c9 f7       	brne	.-14     	; 0xc94 <strncpy+0x4>
 ca2:	01 c0       	rjmp	.+2      	; 0xca6 <strncpy+0x16>
 ca4:	1d 92       	st	X+, r1
 ca6:	41 50       	subi	r20, 0x01	; 1
 ca8:	50 40       	sbci	r21, 0x00	; 0
 caa:	e0 f7       	brcc	.-8      	; 0xca4 <strncpy+0x14>
 cac:	08 95       	ret

00000cae <_exit>:
 cae:	f8 94       	cli

00000cb0 <__stop_program>:
 cb0:	ff cf       	rjmp	.-2      	; 0xcb0 <__stop_program>
