
HHBoot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .bootloader   00000234  00007800  00007800  00000138  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .text         000000c4  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         00000000  00800060  00800060  0000036c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .comment      00000030  00000000  00000000  0000036c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000039c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000090  00000000  00000000  000003d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000b9d  00000000  00000000  00000468  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000746  00000000  00000000  00001005  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000671  00000000  00000000  0000174b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000cc  00000000  00000000  00001dbc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000003ad  00000000  00000000  00001e88  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000317  00000000  00000000  00002235  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000060  00000000  00000000  0000254c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .bootloader:

00007800 <main>:
#define	SIGNATURE_BYTE_2 0x95
#define	SIGNATURE_BYTE_3 0x02

BOOTLOADER_SECTION int main()
{
	initLEDport('C');
    7800:	83 e4       	ldi	r24, 0x43	; 67
    7802:	90 e0       	ldi	r25, 0x00	; 0
    7804:	0e 94 36 00 	call	0x6c	; 0x6c <initLEDport>
    7808:	0c e0       	ldi	r16, 0x0C	; 12
    780a:	10 e0       	ldi	r17, 0x00	; 0

	for (unsigned int i = 0; i < 12; i++)
	{
		toggleLED(7);
    780c:	87 e0       	ldi	r24, 0x07	; 7
    780e:	0e 94 51 00 	call	0xa2	; 0xa2 <toggleLED>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    7812:	2f ef       	ldi	r18, 0xFF	; 255
    7814:	8f e3       	ldi	r24, 0x3F	; 63
    7816:	92 e0       	ldi	r25, 0x02	; 2
    7818:	21 50       	subi	r18, 0x01	; 1
    781a:	80 40       	sbci	r24, 0x00	; 0
    781c:	90 40       	sbci	r25, 0x00	; 0
    781e:	e1 f7       	brne	.-8      	; 0x7818 <main+0x18>
    7820:	00 c0       	rjmp	.+0      	; 0x7822 <main+0x22>
    7822:	00 00       	nop
    7824:	01 50       	subi	r16, 0x01	; 1
    7826:	11 09       	sbc	r17, r1

BOOTLOADER_SECTION int main()
{
	initLEDport('C');

	for (unsigned int i = 0; i < 12; i++)
    7828:	89 f7       	brne	.-30     	; 0x780c <main+0xc>
	char val;
	unsigned int address;
	unsigned int temp_int;
	
	// Disable all interrupts while boot loading
	__asm ("cli");
    782a:	f8 94       	cli
	// Clear SREG
	__asm ("eor r1,r1");
    782c:	11 24       	eor	r1, r1
	__asm ("out 0x3f,r1");
    782e:	1f be       	out	0x3f, r1	; 63

	// Stack pointer = 0x085F (= RAMEND)
	__asm ("ldi r28,0x5F");
    7830:	cf e5       	ldi	r28, 0x5F	; 95
	__asm ("ldi r29,0x08");
    7832:	d8 e0       	ldi	r29, 0x08	; 8
	__asm ("out 0x3e,r29");
    7834:	de bf       	out	0x3e, r29	; 62
	__asm ("out 0x3d,r28" );
    7836:	cd bf       	out	0x3d, r28	; 61

	// Initialize UART: 115200 bit/s, 8 data bits, no parity
	InitUART();
    7838:	0e 94 08 3d 	call	0x7a10	; 0x7a10 <InitUART>
		// Read program memory.
		else if(val=='R')
		{
			// Send high byte, then low byte of flash word.
			boot_spm_busy_wait();
			boot_rww_enable();
    783c:	0f 2e       	mov	r0, r31
    783e:	f1 e1       	ldi	r31, 0x11	; 17
    7840:	8f 2e       	mov	r8, r31
    7842:	f0 2d       	mov	r31, r0
				SendChar('?');
			}
			else
			{
				boot_spm_busy_wait();
				boot_page_write(address << 1); // Convert word-address to byte-address and write.
    7844:	0f 2e       	mov	r0, r31
    7846:	f5 e0       	ldi	r31, 0x05	; 5
    7848:	9f 2e       	mov	r9, r31
    784a:	f0 2d       	mov	r31, r0
		// Write program memory, high byte.
		else if(val=='C')
		{
			temp_int |= ((unsigned int)ReadChar()<<8); // Get and insert high byte.
			boot_spm_busy_wait();
			boot_page_fill((address << 1), temp_int ); // Convert word-address to byte-address and fill.
    784c:	01 e0       	ldi	r16, 0x01	; 1
    784e:	a1 2c       	mov	r10, r1
    7850:	b1 2c       	mov	r11, r1
		else if(val=='e')
		{
			for(address = 0; address < APP_END; address += PAGESIZE)
			{ // NOTE: Here we use address as a byte-address, not word-address, for convenience.
				boot_spm_busy_wait();
				boot_page_erase(address);
    7852:	13 e0       	ldi	r17, 0x03	; 3
	InitUART();
	
	while (1)
	{

		val = ReadChar();
    7854:	0e 94 12 3d 	call	0x7a24	; 0x7a24 <ReadChar>

		// Check auto increment status.
		if(val=='a')
    7858:	81 36       	cpi	r24, 0x61	; 97
    785a:	21 f4       	brne	.+8      	; 0x7864 <main+0x64>
		{
			SendChar('Y'); // Yes, we do auto increment.
    785c:	89 e5       	ldi	r24, 0x59	; 89
    785e:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
    7862:	f8 cf       	rjmp	.-16     	; 0x7854 <main+0x54>
		}

		// Set address.
		else if(val=='A') // Set address...
    7864:	81 34       	cpi	r24, 0x41	; 65
    7866:	69 f4       	brne	.+26     	; 0x7882 <main+0x82>
		{ // NOTE: Flash addresses are given in words, not bytes.
			address=((unsigned int)ReadChar()<<8) | ReadChar(); // Read address high and low byte.
    7868:	0e 94 12 3d 	call	0x7a24	; 0x7a24 <ReadChar>
    786c:	c8 2f       	mov	r28, r24
    786e:	0e 94 12 3d 	call	0x7a24	; 0x7a24 <ReadChar>
    7872:	d0 e0       	ldi	r29, 0x00	; 0
    7874:	dc 2f       	mov	r29, r28
    7876:	cc 27       	eor	r28, r28
    7878:	c8 2b       	or	r28, r24
			SendChar('\r'); // Send OK back.
    787a:	8d e0       	ldi	r24, 0x0D	; 13
    787c:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
    7880:	e9 cf       	rjmp	.-46     	; 0x7854 <main+0x54>
		}

		// Chip erase.
		else if(val=='e')
    7882:	85 36       	cpi	r24, 0x65	; 101
    7884:	99 f4       	brne	.+38     	; 0x78ac <main+0xac>
    7886:	ca 2d       	mov	r28, r10
    7888:	db 2d       	mov	r29, r11
		{
			for(address = 0; address < APP_END; address += PAGESIZE)
			{ // NOTE: Here we use address as a byte-address, not word-address, for convenience.
				boot_spm_busy_wait();
    788a:	07 b6       	in	r0, 0x37	; 55
    788c:	00 fc       	sbrc	r0, 0
    788e:	fd cf       	rjmp	.-6      	; 0x788a <main+0x8a>
				boot_page_erase(address);
    7890:	fe 01       	movw	r30, r28
    7892:	10 93 57 00 	sts	0x0057, r17	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7896:	e8 95       	spm
		}

		// Chip erase.
		else if(val=='e')
		{
			for(address = 0; address < APP_END; address += PAGESIZE)
    7898:	c0 58       	subi	r28, 0x80	; 128
    789a:	df 4f       	sbci	r29, 0xFF	; 255
    789c:	c1 15       	cp	r28, r1
    789e:	fc e3       	ldi	r31, 0x3C	; 60
    78a0:	df 07       	cpc	r29, r31
    78a2:	99 f7       	brne	.-26     	; 0x788a <main+0x8a>
			{ // NOTE: Here we use address as a byte-address, not word-address, for convenience.
				boot_spm_busy_wait();
				boot_page_erase(address);
			}
			SendChar('\r'); // Send OK back.
    78a4:	8d e0       	ldi	r24, 0x0D	; 13
    78a6:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
    78aa:	d4 cf       	rjmp	.-88     	; 0x7854 <main+0x54>
		}

		// Read program memory.
		else if(val=='R')
    78ac:	82 35       	cpi	r24, 0x52	; 82
    78ae:	a1 f4       	brne	.+40     	; 0x78d8 <main+0xd8>
		{
			// Send high byte, then low byte of flash word.
			boot_spm_busy_wait();
    78b0:	07 b6       	in	r0, 0x37	; 55
    78b2:	00 fc       	sbrc	r0, 0
    78b4:	fd cf       	rjmp	.-6      	; 0x78b0 <main+0xb0>
			boot_rww_enable();
    78b6:	80 92 57 00 	sts	0x0057, r8	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    78ba:	e8 95       	spm
			SendChar( pgm_read_byte_near((address << 1)+1 ) );
    78bc:	6e 01       	movw	r12, r28
    78be:	cc 0c       	add	r12, r12
    78c0:	dd 1c       	adc	r13, r13
    78c2:	f6 01       	movw	r30, r12
    78c4:	31 96       	adiw	r30, 0x01	; 1
    78c6:	84 91       	lpm	r24, Z
    78c8:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
			SendChar( pgm_read_byte_near(address << 1) );
    78cc:	f6 01       	movw	r30, r12
    78ce:	84 91       	lpm	r24, Z
    78d0:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
			address++; // Auto-advance to next Flash word.
    78d4:	21 96       	adiw	r28, 0x01	; 1
    78d6:	be cf       	rjmp	.-132    	; 0x7854 <main+0x54>
		}

		// Write program memory, low byte.
		else if(val=='c')
    78d8:	83 36       	cpi	r24, 0x63	; 99
    78da:	41 f4       	brne	.+16     	; 0x78ec <main+0xec>
		{ // NOTE: Always use this command before sending high byte.
			temp_int = ReadChar(); // Get low byte for later _FILL_TEMP_WORD.
    78dc:	0e 94 12 3d 	call	0x7a24	; 0x7a24 <ReadChar>
    78e0:	e8 2e       	mov	r14, r24
    78e2:	f1 2c       	mov	r15, r1
			SendChar('\r'); // Send OK back.
    78e4:	8d e0       	ldi	r24, 0x0D	; 13
    78e6:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
    78ea:	b4 cf       	rjmp	.-152    	; 0x7854 <main+0x54>
		}
		
		// Write program memory, high byte.
		else if(val=='C')
    78ec:	83 34       	cpi	r24, 0x43	; 67
    78ee:	99 f4       	brne	.+38     	; 0x7916 <main+0x116>
		{
			temp_int |= ((unsigned int)ReadChar()<<8); // Get and insert high byte.
    78f0:	0e 94 12 3d 	call	0x7a24	; 0x7a24 <ReadChar>
    78f4:	f8 2a       	or	r15, r24
			boot_spm_busy_wait();
    78f6:	07 b6       	in	r0, 0x37	; 55
    78f8:	00 fc       	sbrc	r0, 0
    78fa:	fd cf       	rjmp	.-6      	; 0x78f6 <main+0xf6>
			boot_page_fill((address << 1), temp_int ); // Convert word-address to byte-address and fill.
    78fc:	fe 01       	movw	r30, r28
    78fe:	ee 0f       	add	r30, r30
    7900:	ff 1f       	adc	r31, r31
    7902:	07 01       	movw	r0, r14
    7904:	00 93 57 00 	sts	0x0057, r16	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7908:	e8 95       	spm
    790a:	11 24       	eor	r1, r1
			address++; // Auto-advance to next Flash word.
    790c:	21 96       	adiw	r28, 0x01	; 1
			SendChar('\r'); // Send OK back.
    790e:	8d e0       	ldi	r24, 0x0D	; 13
    7910:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
    7914:	9f cf       	rjmp	.-194    	; 0x7854 <main+0x54>
		}

		// Write page.
		else if(val== 'm')
    7916:	8d 36       	cpi	r24, 0x6D	; 109
    7918:	a9 f4       	brne	.+42     	; 0x7944 <main+0x144>
		{
			if( address >= (APP_END>>1) ) // Protect boot loader area.
    791a:	cf 3f       	cpi	r28, 0xFF	; 255
    791c:	fd e1       	ldi	r31, 0x1D	; 29
    791e:	df 07       	cpc	r29, r31
    7920:	20 f0       	brcs	.+8      	; 0x792a <main+0x12a>
			{
				SendChar('?');
    7922:	8f e3       	ldi	r24, 0x3F	; 63
    7924:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
    7928:	09 c0       	rjmp	.+18     	; 0x793c <main+0x13c>
			}
			else
			{
				boot_spm_busy_wait();
    792a:	07 b6       	in	r0, 0x37	; 55
    792c:	00 fc       	sbrc	r0, 0
    792e:	fd cf       	rjmp	.-6      	; 0x792a <main+0x12a>
				boot_page_write(address << 1); // Convert word-address to byte-address and write.
    7930:	fe 01       	movw	r30, r28
    7932:	ee 0f       	add	r30, r30
    7934:	ff 1f       	adc	r31, r31
    7936:	90 92 57 00 	sts	0x0057, r9	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    793a:	e8 95       	spm
			}
			SendChar('\r'); // Send OK back.
    793c:	8d e0       	ldi	r24, 0x0D	; 13
    793e:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
    7942:	88 cf       	rjmp	.-240    	; 0x7854 <main+0x54>
		}

		// Enter and leave programming mode.
		else if( (val=='P') || (val=='L') )
    7944:	80 35       	cpi	r24, 0x50	; 80
    7946:	11 f0       	breq	.+4      	; 0x794c <main+0x14c>
    7948:	8c 34       	cpi	r24, 0x4C	; 76
    794a:	21 f4       	brne	.+8      	; 0x7954 <main+0x154>
		{
			SendChar('\r'); // Nothing special to do, just answer OK.
    794c:	8d e0       	ldi	r24, 0x0D	; 13
    794e:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
    7952:	80 cf       	rjmp	.-256    	; 0x7854 <main+0x54>
		}

		// Exit boot loader.
		else if(val=='E')
    7954:	85 34       	cpi	r24, 0x45	; 69
    7956:	69 f4       	brne	.+26     	; 0x7972 <main+0x172>
		{
			boot_spm_busy_wait();
    7958:	07 b6       	in	r0, 0x37	; 55
    795a:	00 fc       	sbrc	r0, 0
    795c:	fd cf       	rjmp	.-6      	; 0x7958 <main+0x158>
			boot_rww_enable();
    795e:	81 e1       	ldi	r24, 0x11	; 17
    7960:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    7964:	e8 95       	spm
			SendChar('\r');
    7966:	8d e0       	ldi	r24, 0x0D	; 13
    7968:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
			// Generate watchdog RESET (starting the application)
			WDTCR = 0b00001000;
    796c:	88 e0       	ldi	r24, 0x08	; 8
    796e:	81 bd       	out	0x21, r24	; 33
			while(1)
			{}
    7970:	ff cf       	rjmp	.-2      	; 0x7970 <main+0x170>
		}

		// Get programmer type.
		else if (val=='p')
    7972:	80 37       	cpi	r24, 0x70	; 112
    7974:	21 f4       	brne	.+8      	; 0x797e <main+0x17e>
		{
			SendChar('S'); // Answer 'SERIAL'.
    7976:	83 e5       	ldi	r24, 0x53	; 83
    7978:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
    797c:	6b cf       	rjmp	.-298    	; 0x7854 <main+0x54>
		}

		// Return supported device codes.
		else if(val=='t')
    797e:	84 37       	cpi	r24, 0x74	; 116
    7980:	39 f4       	brne	.+14     	; 0x7990 <main+0x190>
		{
			SendChar( PARTCODE ); // Supports only this device, of course.
    7982:	83 e7       	ldi	r24, 0x73	; 115
    7984:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
			SendChar( 0 ); // Send list terminator.
    7988:	80 e0       	ldi	r24, 0x00	; 0
    798a:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
    798e:	62 cf       	rjmp	.-316    	; 0x7854 <main+0x54>
		}

		// Set LED, clear LED and set device type.
		else if((val=='x') || (val=='y') || (val=='T'))
    7990:	98 e8       	ldi	r25, 0x88	; 136
    7992:	98 0f       	add	r25, r24
    7994:	92 30       	cpi	r25, 0x02	; 2
    7996:	10 f0       	brcs	.+4      	; 0x799c <main+0x19c>
    7998:	84 35       	cpi	r24, 0x54	; 84
    799a:	31 f4       	brne	.+12     	; 0x79a8 <main+0x1a8>
		{
			ReadChar(); // Ignore the command and its parameter.
    799c:	0e 94 12 3d 	call	0x7a24	; 0x7a24 <ReadChar>
			SendChar('\r'); // Send OK back.
    79a0:	8d e0       	ldi	r24, 0x0D	; 13
    79a2:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
    79a6:	56 cf       	rjmp	.-340    	; 0x7854 <main+0x54>
		}

		// Return programmer identifier.
		else if(val=='S')
    79a8:	83 35       	cpi	r24, 0x53	; 83
    79aa:	b1 f4       	brne	.+44     	; 0x79d8 <main+0x1d8>
		{
			SendChar('A'); // Return 'AVRBOOT'.
    79ac:	81 e4       	ldi	r24, 0x41	; 65
    79ae:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
			SendChar('V'); // Software identifier (programmer signature) is always 7 characters.
    79b2:	86 e5       	ldi	r24, 0x56	; 86
    79b4:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
			SendChar('R');
    79b8:	82 e5       	ldi	r24, 0x52	; 82
    79ba:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
			SendChar('B');
    79be:	82 e4       	ldi	r24, 0x42	; 66
    79c0:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
			SendChar('O');
    79c4:	8f e4       	ldi	r24, 0x4F	; 79
    79c6:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
			SendChar('O');
    79ca:	8f e4       	ldi	r24, 0x4F	; 79
    79cc:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
			SendChar('T');
    79d0:	84 e5       	ldi	r24, 0x54	; 84
    79d2:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
    79d6:	3e cf       	rjmp	.-388    	; 0x7854 <main+0x54>
		}

		// Return software version.
		else if(val=='V')
    79d8:	86 35       	cpi	r24, 0x56	; 86
    79da:	39 f4       	brne	.+14     	; 0x79ea <main+0x1ea>
		{
			SendChar('1');
    79dc:	81 e3       	ldi	r24, 0x31	; 49
    79de:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
			SendChar('5');
    79e2:	85 e3       	ldi	r24, 0x35	; 53
    79e4:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
    79e8:	35 cf       	rjmp	.-406    	; 0x7854 <main+0x54>
		}

		// Return signature bytes.
		else if(val=='s')
    79ea:	83 37       	cpi	r24, 0x73	; 115
    79ec:	51 f4       	brne	.+20     	; 0x7a02 <main+0x202>
		{
			SendChar( SIGNATURE_BYTE_3 );
    79ee:	82 e0       	ldi	r24, 0x02	; 2
    79f0:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
			SendChar( SIGNATURE_BYTE_2 );
    79f4:	85 e9       	ldi	r24, 0x95	; 149
    79f6:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
			SendChar( SIGNATURE_BYTE_1 );
    79fa:	8e e1       	ldi	r24, 0x1E	; 30
    79fc:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
    7a00:	29 cf       	rjmp	.-430    	; 0x7854 <main+0x54>
		}

		// The last command to accept is ESC (synchronization).
		else if(val!=0x1b) // If not ESC, then it is unrecognized...
    7a02:	8b 31       	cpi	r24, 0x1B	; 27
    7a04:	09 f4       	brne	.+2      	; 0x7a08 <main+0x208>
    7a06:	26 cf       	rjmp	.-436    	; 0x7854 <main+0x54>
		{
			SendChar('?');
    7a08:	8f e3       	ldi	r24, 0x3F	; 63
    7a0a:	0e 94 16 3d 	call	0x7a2c	; 0x7a2c <SendChar>
    7a0e:	22 cf       	rjmp	.-444    	; 0x7854 <main+0x54>

00007a10 <InitUART>:

__attribute__ ((section (".bootloader")))
void InitUART()
{
  // "Normal" clock, no multiprocessor mode (= default)
  UCSRA = 0b00100000;
    7a10:	80 e2       	ldi	r24, 0x20	; 32
    7a12:	8b b9       	out	0x0b, r24	; 11
  // No interrupts enabled
  // Receiver enabled
  // Transmitter enabled
  UCSRB = 0b00011000;	
    7a14:	88 e1       	ldi	r24, 0x18	; 24
    7a16:	8a b9       	out	0x0a, r24	; 10
  // Asynchronous operation, 1 stop bit, no parity
  // 8 data bits
  UCSRC = 0b10000110;
    7a18:	86 e8       	ldi	r24, 0x86	; 134
    7a1a:	80 bd       	out	0x20, r24	; 32
  //Baud rate = 115200
  // Write upper part of UBRR
  UBRRH = ((XTAL/16)/115200 - 1) >> 8;
    7a1c:	10 bc       	out	0x20, r1	; 32
  // Write lower part of UBRR
  UBRRL = ((XTAL/16)/115200 - 1);
    7a1e:	81 e0       	ldi	r24, 0x01	; 1
    7a20:	89 b9       	out	0x09, r24	; 9
    7a22:	08 95       	ret

00007a24 <ReadChar>:
*************************************************************************/
__attribute__ ((section (".bootloader")))
char ReadChar()
{
  // Wait for new character received
  while ( (UCSRA & (1<<7)) == 0 )
    7a24:	5f 9b       	sbis	0x0b, 7	; 11
    7a26:	fe cf       	rjmp	.-4      	; 0x7a24 <ReadChar>
  {}                        
  // Then return it
  return UDR;
    7a28:	8c b1       	in	r24, 0x0c	; 12
}
    7a2a:	08 95       	ret

00007a2c <SendChar>:
*************************************************************************/
__attribute__ ((section (".bootloader")))
void SendChar(char Ch)
{
  // Wait for transmitter register empty (ready for new character)
  while ( (UCSRA & (1<<5)) == 0 )
    7a2c:	5d 9b       	sbis	0x0b, 5	; 11
    7a2e:	fe cf       	rjmp	.-4      	; 0x7a2c <SendChar>
  {}
  // Then send the character
  UDR = Ch;
    7a30:	8c b9       	out	0x0c, r24	; 12
    7a32:	08 95       	ret

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
   8:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
   c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  10:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  14:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  18:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  1c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  20:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  24:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  28:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  2c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  30:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  34:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  38:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  3c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  40:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  44:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  48:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  4c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  50:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61
  60:	0e 94 00 3c 	call	0x7800	; 0x7800 <main>
  64:	0c 94 60 00 	jmp	0xc0	; 0xc0 <_exit>

00000068 <__bad_interrupt>:
  68:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000006c <initLEDport>:
	if (led_nr <= MAX_LED_NR)
	{
		// Create mask based on the parameter (led_nr)
		mask = 0b00000001 << led_nr;
		// Turn OFF the actual LED (the rest are unchanged)
		PORTC = PORTC | mask;
  6c:	82 34       	cpi	r24, 0x42	; 66
  6e:	69 f0       	breq	.+26     	; 0x8a <initLEDport+0x1e>
  70:	18 f4       	brcc	.+6      	; 0x78 <initLEDport+0xc>
  72:	81 34       	cpi	r24, 0x41	; 65
  74:	31 f0       	breq	.+12     	; 0x82 <initLEDport+0x16>
  76:	11 c0       	rjmp	.+34     	; 0x9a <initLEDport+0x2e>
  78:	83 34       	cpi	r24, 0x43	; 67
  7a:	59 f0       	breq	.+22     	; 0x92 <initLEDport+0x26>
  7c:	84 34       	cpi	r24, 0x44	; 68
  7e:	81 f0       	breq	.+32     	; 0xa0 <initLEDport+0x34>
  80:	0c c0       	rjmp	.+24     	; 0x9a <initLEDport+0x2e>
  82:	8f ef       	ldi	r24, 0xFF	; 255
  84:	8a bb       	out	0x1a, r24	; 26
  86:	8b bb       	out	0x1b, r24	; 27
  88:	08 95       	ret
  8a:	8f ef       	ldi	r24, 0xFF	; 255
  8c:	87 bb       	out	0x17, r24	; 23
  8e:	88 bb       	out	0x18, r24	; 24
  90:	08 95       	ret
  92:	8f ef       	ldi	r24, 0xFF	; 255
  94:	84 bb       	out	0x14, r24	; 20
  96:	85 bb       	out	0x15, r24	; 21
  98:	08 95       	ret
  9a:	8f ef       	ldi	r24, 0xFF	; 255
  9c:	84 bb       	out	0x14, r24	; 20
  9e:	85 bb       	out	0x15, r24	; 21
  a0:	08 95       	ret

000000a2 <toggleLED>:
void toggleLED(unsigned char led_nr)
{
	// Local variable
	unsigned char mask;
	// We only have to do anything, if led_nr < 8
	if (led_nr <= MAX_LED_NR)
  a2:	88 30       	cpi	r24, 0x08	; 8
  a4:	60 f4       	brcc	.+24     	; 0xbe <toggleLED+0x1c>
	{
		// Create mask based on the parameter (led_nr)
		mask = 0b00000001 << led_nr;
		// Toggle the actual LED (the rest are unchanged)
		PORTC = PORTC ^ mask;
  a6:	45 b3       	in	r20, 0x15	; 21
	unsigned char mask;
	// We only have to do anything, if led_nr < 8
	if (led_nr <= MAX_LED_NR)
	{
		// Create mask based on the parameter (led_nr)
		mask = 0b00000001 << led_nr;
  a8:	21 e0       	ldi	r18, 0x01	; 1
  aa:	30 e0       	ldi	r19, 0x00	; 0
  ac:	b9 01       	movw	r22, r18
  ae:	02 c0       	rjmp	.+4      	; 0xb4 <toggleLED+0x12>
  b0:	66 0f       	add	r22, r22
  b2:	77 1f       	adc	r23, r23
  b4:	8a 95       	dec	r24
  b6:	e2 f7       	brpl	.-8      	; 0xb0 <toggleLED+0xe>
  b8:	cb 01       	movw	r24, r22
		// Toggle the actual LED (the rest are unchanged)
		PORTC = PORTC ^ mask;
  ba:	84 27       	eor	r24, r20
  bc:	85 bb       	out	0x15, r24	; 21
  be:	08 95       	ret

000000c0 <_exit>:
  c0:	f8 94       	cli

000000c2 <__stop_program>:
  c2:	ff cf       	rjmp	.-2      	; 0xc2 <__stop_program>
